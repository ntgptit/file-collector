// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/module_details_bottom_sheet.dart
class ModuleDetailsBottomSheet extends ConsumerWidget {
  final LearningModule module;
  final String? heroTagPrefix;
  const ModuleDetailsBottomSheet({
    super.key,
    required this.module,
    this.heroTagPrefix,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;
    final mediaQuery = MediaQuery.of(context);
    return Container(
      key: const Key('module_details_bottom_sheet'),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(AppDimens.radiusL),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildDragHandle(colorScheme),
          Flexible(
            child: SingleChildScrollView(
              padding: EdgeInsets.only(
                left: AppDimens.paddingL,
                right: AppDimens.paddingL,
                bottom: AppDimens.paddingXL + mediaQuery.padding.bottom,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildModuleTitle(colorScheme, textTheme),
                  _buildBookInfo(colorScheme, textTheme),
                  const Divider(height: AppDimens.paddingXXL),
                  _buildModuleDetailsSection(context, colorScheme, textTheme),
                  const Divider(height: AppDimens.paddingXXL),
                  _buildDatesSection(colorScheme, textTheme),
                  if (module.studyHistory.isNotEmpty) ...[
                    const SizedBox(height: AppDimens.spaceXL),
                    _buildStudyHistorySection(colorScheme, textTheme),
                  ],
                  const SizedBox(height: AppDimens.spaceXL),
                  _buildActionButtons(context),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildDragHandle(ColorScheme colorScheme) {
    return Padding(
      padding: const EdgeInsets.only(
        top: AppDimens.paddingM,
        bottom: AppDimens.paddingS,
      ),
      child: Container(
        key: const Key('drag_handle'),
        width: AppDimens.moduleIndicatorSize,
        height: AppDimens.dividerThickness * 2,
        decoration: BoxDecoration(
          color: colorScheme.onSurfaceVariant.withValues(
            alpha: AppDimens.opacitySemi,
          ),
          borderRadius: BorderRadius.circular(AppDimens.radiusS),
        ),
      ),
    );
  }
  Widget _buildModuleTitle(ColorScheme colorScheme, TextTheme textTheme) {
    Widget titleWidget = Text(
      module.moduleTitle.isEmpty ? 'Unnamed Module' : module.moduleTitle,
      style: textTheme.headlineSmall?.copyWith(color: colorScheme.onSurface),
      key: const Key('module_title'),
    );
    if (heroTagPrefix != null) {
      titleWidget = Hero(
        tag:
            '${heroTagPrefix}_${module.bookNo}_${module.moduleNo}_${module.moduleTitle}',
        child: Material(color: Colors.transparent, child: titleWidget),
      );
    }
    return Padding(
      padding: const EdgeInsets.only(bottom: AppDimens.paddingXS),
      child: titleWidget,
    );
  }
  Widget _buildBookInfo(ColorScheme colorScheme, TextTheme textTheme) {
    return Padding(
      padding: const EdgeInsets.only(
        top: AppDimens.paddingS,
        bottom: AppDimens.paddingM,
      ),
      child: Row(
        children: [
          Icon(
            Icons.book_outlined,
            color: colorScheme.primary,
            size: AppDimens.iconS,
            key: const Key('book_icon'),
          ),
          const SizedBox(width: AppDimens.spaceS),
          Expanded(
            child: Text(
              'From: ${module.bookName.isEmpty ? 'No Book' : module.bookName}',
              style: textTheme.titleMedium?.copyWith(
                color: colorScheme.primary,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              key: const Key('book_info'),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildSectionTitle(
    ColorScheme colorScheme,
    TextTheme textTheme,
    String title, {
    IconData icon = Icons.info_outline,
    Key? key,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: AppDimens.paddingM),
      child: Row(
        children: [
          Icon(icon, size: AppDimens.iconM, color: colorScheme.primary),
          const SizedBox(width: AppDimens.spaceS),
          Text(
            title,
            style: textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: colorScheme.primary,
            ),
            key: key,
          ),
        ],
      ),
    );
  }
  Widget _buildModuleDetailsSection(
    BuildContext context,
    ColorScheme colorScheme,
    TextTheme textTheme,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(
          colorScheme,
          textTheme,
          'Module Details',
          key: const Key('details_section_title'),
        ),
        Wrap(
          spacing: AppDimens.spaceL,
          runSpacing: AppDimens.spaceL,
          children: [
            _buildDetailItem(
              context,
              colorScheme,
              textTheme,
              'Word Count',
              module.moduleWordCount.toString(),
              Icons.text_fields,
              key: const Key('word_count_item'),
            ),
            if (module.progressLatestPercentComplete != null)
              _buildDetailItem(
                context,
                colorScheme,
                textTheme,
                'Progress',
                '${module.progressLatestPercentComplete}%',
                Icons.show_chart_outlined,
                progressValue: module.progressLatestPercentComplete! / 100.0,
                key: const Key('progress_item'),
              ),
            if (module.progressCyclesStudied != null)
              _buildDetailItem(
                context,
                colorScheme,
                textTheme,
                'Cycle',
                CycleFormatter.format(module.progressCyclesStudied!),
                Icons.autorenew,
                color: CycleFormatter.getColor(
                  module.progressCyclesStudied!,
                  context,
                ),
                key: const Key('cycle_item'),
              ),
            if (module.progressDueTaskCount > 0)
              _buildDetailItem(
                context,
                colorScheme,
                textTheme,
                'Tasks',
                module.progressDueTaskCount.toString(),
                Icons.checklist_outlined,
                key: const Key('tasks_item'),
              ),
          ],
        ),
      ],
    );
  }
  Widget _buildDetailItem(
    BuildContext context,
    ColorScheme colorScheme,
    TextTheme textTheme,
    String label,
    String value,
    IconData icon, {
    double? progressValue,
    Color? color,
    Key? key,
  }) {
    final effectiveColor = color ?? colorScheme.primary;
    final bgColor = colorScheme.surfaceContainerLowest;
    final borderColor = colorScheme.outlineVariant;
    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth =
        screenWidth - (AppDimens.paddingL * 2) - AppDimens.spaceL;
    final itemWidth = availableWidth / 2;
    Color progressIndicatorColor = colorScheme.error;
    if (progressValue != null) {
      if (progressValue >= 0.9) {
        progressIndicatorColor = colorScheme.tertiary;
      } else if (progressValue >= 0.7) {
        progressIndicatorColor = colorScheme.secondary;
      }
    }
    return Container(
      key: key,
      width: itemWidth,
      constraints: const BoxConstraints(minHeight: AppDimens.thumbnailSizeS),
      padding: const EdgeInsets.all(AppDimens.paddingM),
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
        border: Border.all(color: borderColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            children: [
              Icon(icon, size: AppDimens.iconS, color: effectiveColor),
              const SizedBox(width: AppDimens.spaceS),
              Expanded(
                child: Text(
                  label,
                  style: textTheme.bodyMedium?.copyWith(
                    color: colorScheme.onSurfaceVariant,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
          const SizedBox(height: AppDimens.spaceXXS),
          Text(
            value,
            style: textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: colorScheme.onSurface,
            ),
            overflow: TextOverflow.ellipsis,
          ),
          const SizedBox(height: AppDimens.spaceS),
          if (progressValue != null)
            LinearProgressIndicator(
              value: progressValue,
              backgroundColor: colorScheme.surfaceContainerHighest,
              valueColor: AlwaysStoppedAnimation<Color>(progressIndicatorColor),
              borderRadius: BorderRadius.circular(AppDimens.radiusXXS),
              minHeight: AppDimens.lineProgressHeight,
            )
          else
            const SizedBox(height: AppDimens.lineProgressHeight),
        ],
      ),
    );
  }
  Widget _buildDatesSection(ColorScheme colorScheme, TextTheme textTheme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(
          colorScheme,
          textTheme,
          'Important Dates',
          icon: Icons.calendar_month_outlined,
          key: const Key('dates_section_title'),
        ),
        const SizedBox(height: AppDimens.spaceS),
        if (module.progressFirstLearningDate != null)
          _buildDateItem(
            colorScheme,
            textTheme,
            'First Learning',
            module.progressFirstLearningDate!,
            Icons.play_circle_outline,
            key: const Key('first_learning_date'),
          ),
        if (module.progressNextStudyDate != null) ...[
          const SizedBox(height: AppDimens.spaceL),
          _buildDateItem(
            colorScheme,
            textTheme,
            'Next Study',
            module.progressNextStudyDate!,
            Icons.event_available_outlined,
            isDue:
                DateUtils.isSameDay(
                  module.progressNextStudyDate,
                  DateTime.now(),
                ) ||
                module.progressNextStudyDate!.isBefore(DateTime.now()),
            key: const Key('next_study_date'),
          ),
        ],
      ],
    );
  }
  Widget _buildDateItem(
    ColorScheme colorScheme,
    TextTheme textTheme,
    String label,
    DateTime date,
    IconData icon, {
    bool isDue = false,
    Key? key,
  }) {
    final Color effectiveColor = isDue
        ? colorScheme.error
        : colorScheme.primary;
    final Color labelColor = colorScheme.onSurfaceVariant;
    final Color dateColor = isDue ? colorScheme.error : colorScheme.onSurface;
    return Row(
      key: key,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, color: effectiveColor, size: AppDimens.iconM),
        const SizedBox(width: AppDimens.spaceM),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: textTheme.bodyMedium?.copyWith(color: labelColor),
              ),
              Text(
                DateFormat('EEEE, MMMM d, yyyy').format(date),
                style: textTheme.titleMedium?.copyWith(
                  color: dateColor,
                  fontWeight: isDue ? FontWeight.bold : null,
                ),
              ),
            ],
          ),
        ),
        if (isDue)
          Padding(
            padding: const EdgeInsets.only(left: AppDimens.spaceS),
            child: Chip(
              label: const Text('Due'),
              labelStyle: textTheme.labelSmall?.copyWith(
                color: colorScheme.onErrorContainer,
              ),
              backgroundColor: colorScheme.errorContainer,
              padding: EdgeInsets.zero,
              visualDensity: VisualDensity.compact,
              side: BorderSide.none,
            ),
          ),
      ],
    );
  }
  Widget _buildStudyHistorySection(
    ColorScheme colorScheme,
    TextTheme textTheme,
  ) {
    final studyHistory =
        module.studyHistory
            .map((s) => DateTime.tryParse(s))
            .whereType<DateTime>()
            .toList()
          ..sort((a, b) => b.compareTo(a));
    final displayHistory = studyHistory.take(7).toList();
    final remainingCount = studyHistory.length - displayHistory.length;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(
          colorScheme,
          textTheme,
          'Study History',
          icon: Icons.history_edu_outlined,
          key: const Key('history_section_title'),
        ),
        const SizedBox(height: AppDimens.spaceS),
        _buildHistoryItems(colorScheme, textTheme, displayHistory),
        if (remainingCount > 0) ...[
          const SizedBox(height: AppDimens.spaceS),
          Padding(
            padding: const EdgeInsets.only(left: AppDimens.paddingS),
            child: Text(
              '+ $remainingCount more session${remainingCount > 1 ? 's' : ''}',
              style: textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
                fontStyle: FontStyle.italic,
              ),
              key: const Key('more_sessions_text'),
            ),
          ),
        ],
      ],
    );
  }
  Widget _buildHistoryItems(
    ColorScheme colorScheme,
    TextTheme textTheme,
    List<DateTime> displayHistory,
  ) {
    final today = DateUtils.dateOnly(DateTime.now());
    return Wrap(
      key: const Key('history_items'),
      spacing: AppDimens.spaceS,
      runSpacing: AppDimens.spaceS,
      children: displayHistory.map((date) {
        final itemDate = DateUtils.dateOnly(date);
        final isToday = itemDate.isAtSameMomentAs(today);
        final Color bgColor;
        final Color fgColor;
        final Border border;
        if (isToday) {
          bgColor = colorScheme.primaryContainer;
          fgColor = colorScheme.onPrimaryContainer;
          border = Border.all(color: colorScheme.primary);
        } else {
          bgColor = colorScheme.surfaceContainerHighest;
          fgColor = colorScheme.onSurfaceVariant;
          border = Border.all(color: colorScheme.outlineVariant);
        }
        final itemTextStyle = textTheme.labelMedium;
        return Tooltip(
          message: DateFormat('MMMM d, yyyy').format(date),
          child: Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppDimens.paddingM,
              vertical: AppDimens.paddingXS,
            ),
            decoration: BoxDecoration(
              color: bgColor,
              borderRadius: BorderRadius.circular(AppDimens.radiusM),
              border: border,
            ),
            child: Text(
              DateFormat('MMM d').format(date),
              style: itemTextStyle?.copyWith(
                fontWeight: isToday ? FontWeight.bold : FontWeight.normal,
                color: fgColor,
              ),
            ),
          ),
        );
      }).toList(),
    );
  }
  Widget _buildActionButtons(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(top: AppDimens.paddingL),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          OutlinedButton.icon(
            key: const Key('close_button'),
            icon: const Icon(Icons.close),
            label: const Text('Close'),
            onPressed: () => Navigator.pop(context),
          ),
          const SizedBox(width: AppDimens.spaceM),
          ElevatedButton.icon(
            key: const Key('study_button'),
            icon: const Icon(Icons.play_arrow),
            label: const Text('Start Studying'),
            onPressed: () {
              Navigator.pop(context);
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) =>
                      ModuleDetailScreen(moduleId: module.moduleId),
                ),
              );
            },
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/settings/reminder_settings_screen.dart
class ReminderConfig {
  static const String noonTime = '12:30 PM';
  static const String eveningFirstTime = '9:00 PM';
  static const String eveningSecondTime = '10:30 PM';
  static const String endOfDayTime = '11:30 PM';
}
class ReminderSettingsScreen extends ConsumerWidget {
  const ReminderSettingsScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return const _ReminderSettingsView();
  }
}
class _ReminderSettingsView extends ConsumerStatefulWidget {
  const _ReminderSettingsView();
  @override
  ConsumerState<_ReminderSettingsView> createState() =>
      _ReminderSettingsViewState();
}
class _ReminderSettingsViewState extends ConsumerState<_ReminderSettingsView> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInitialData();
    });
  }
  Future<void> _loadInitialData() async {
    final settingsState = ref.read(reminderSettingsStateProvider);
    if (settingsState.value == null || !settingsState.hasValue) {
      await ref.read(reminderSettingsStateProvider.notifier).refreshSettings();
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsAsync = ref.watch(reminderSettingsStateProvider);
    final permissionsAsync = ref.watch(devicePermissionsProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Reminder Settings'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () {
            final router = GoRouter.of(context);
            if (router.canPop()) {
              router.pop();
              return;
            }
            router.go('/');
          },
          tooltip: 'Back',
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => ref
                .read(reminderSettingsStateProvider.notifier)
                .refreshSettings(),
            tooltip: 'Refresh settings',
          ),
        ],
      ),
      body: _buildBody(settingsAsync, permissionsAsync, theme),
    );
  }
  Widget _buildBody(
    AsyncValue<Map<String, bool>> settingsAsync,
    AsyncValue<Map<String, dynamic>> permissionsAsync,
    ThemeData theme,
  ) {
    return settingsAsync.when(
      data: (settingsData) {
        final isLoading = settingsAsync.isLoading;
        final isInitialized = settingsData.isNotEmpty;
        if (isLoading && !isInitialized) {
          return const Center(child: SLLoadingIndicator());
        }
        return permissionsAsync.when(
          data: (permissionsData) {
            return Stack(
              children: [
                RefreshIndicator(
                  onRefresh: () => ref
                      .read(reminderSettingsStateProvider.notifier)
                      .refreshSettings(),
                  child: ListView(
                    padding: const EdgeInsets.all(AppDimens.paddingL),
                    children: [
                      _buildInfoCard(theme),
                      const SizedBox(height: AppDimens.spaceL),
                      _buildMasterSwitch(settingsData, theme),
                      const Divider(height: AppDimens.spaceXL),
                      _buildReminderSwitches(settingsData, theme),
                      const SizedBox(height: AppDimens.spaceXL),
                      _buildExplanationsCard(theme),
                      const SizedBox(height: AppDimens.spaceL),
                      _buildDevicePermissionsCard(permissionsData, theme),
                      const SizedBox(height: AppDimens.spaceL * 2),
                    ],
                  ),
                ),
                if (isLoading && isInitialized)
                  Positioned.fill(
                    child: Container(
                      color: Colors.black.withValues(alpha: 0.3),
                      child: const Center(child: CircularProgressIndicator()),
                    ),
                  ),
              ],
            );
          },
          loading: () => const Center(child: SLLoadingIndicator()),
          error: (error, stackTrace) => Center(
            child: SLErrorView(
              message: 'Failed to load device permissions: $error',
              onRetry: () =>
                  ref.read(devicePermissionsProvider.notifier).build(),
            ),
          ),
        );
      },
      loading: () => const Center(child: SLLoadingIndicator()),
      error: (error, stackTrace) => Center(
        child: SLErrorView(
          message: 'Failed to load reminder settings: $error',
          onRetry: () => ref
              .read(reminderSettingsStateProvider.notifier)
              .refreshSettings(),
        ),
      ),
    );
  }
  Widget _buildInfoCard(ThemeData theme) {
    final colorScheme = theme.colorScheme;
    return Card(
      margin: EdgeInsets.zero,
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.alarm, color: colorScheme.primary),
                const SizedBox(width: AppDimens.spaceM),
                Text(
                  'Smart Learning Reminders',
                  style: theme.textTheme.titleLarge,
                ),
              ],
            ),
            const SizedBox(height: AppDimens.spaceM),
            Text(
              'Reminders help you stay on track with your learning schedule. '
              'The app will remind you at specific times to check your learning tasks.',
              style: theme.textTheme.bodyMedium,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildMasterSwitch(Map<String, bool> settingsData, ThemeData theme) {
    final remindersEnabled = settingsData['remindersEnabled'] ?? false;
    return SLToggleSwitch(
      title: 'Enable Learning Reminders',
      subtitle: 'Turn on/off all reminders',
      value: remindersEnabled,
      onChanged: (value) => _updateSetting(
        () => ref
            .read(reminderSettingsStateProvider.notifier)
            .setRemindersEnabled(value),
        'Reminders ${value ? 'enabled' : 'disabled'}',
      ),
      icon: Icons.notifications_active,
      size: SLToggleSwitchSize.large,
      type: SLToggleSwitchType.standard,
    );
  }
  Widget _buildReminderSwitches(
    Map<String, bool> settingsData,
    ThemeData theme,
  ) {
    final remindersEnabled = settingsData['remindersEnabled'] ?? false;
    final noonEnabled = settingsData['noonReminderEnabled'] ?? false;
    final eveningFirstEnabled =
        settingsData['eveningFirstReminderEnabled'] ?? false;
    final eveningSecondEnabled =
        settingsData['eveningSecondReminderEnabled'] ?? false;
    final endOfDayEnabled = settingsData['endOfDayReminderEnabled'] ?? false;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(
            left: AppDimens.paddingL,
            bottom: AppDimens.paddingS,
          ),
          child: Text('Reminder Schedule', style: theme.textTheme.titleMedium),
        ),
        SLToggleSwitch(
          title: 'Noon Reminder (${ReminderConfig.noonTime})',
          subtitle: 'Daily check of your learning schedule',
          value: noonEnabled,
          icon: Icons.wb_sunny,
          enabled: remindersEnabled,
          onChanged: (value) => _updateSetting(
            () => ref
                .read(reminderSettingsStateProvider.notifier)
                .setNoonReminderEnabled(value),
            'Noon reminder ${value ? 'enabled' : 'disabled'}',
          ),
          type: SLToggleSwitchType.standard,
        ),
        SLToggleSwitch(
          title: 'Evening Reminder (${ReminderConfig.eveningFirstTime})',
          subtitle: 'First reminder for unfinished tasks',
          value: eveningFirstEnabled,
          icon: Icons.nights_stay,
          enabled: remindersEnabled,
          onChanged: (value) => _updateSetting(
            () => ref
                .read(reminderSettingsStateProvider.notifier)
                .setEveningFirstReminderEnabled(value),
            'Evening reminder ${value ? 'enabled' : 'disabled'}',
          ),
          type: SLToggleSwitchType.standard,
        ),
        SLToggleSwitch(
          title: 'Late Evening Reminder (${ReminderConfig.eveningSecondTime})',
          subtitle: 'Second reminder for unfinished tasks',
          value: eveningSecondEnabled,
          icon: Icons.nightlight,
          enabled: remindersEnabled,
          onChanged: (value) => _updateSetting(
            () => ref
                .read(reminderSettingsStateProvider.notifier)
                .setEveningSecondReminderEnabled(value),
            'Late evening reminder ${value ? 'enabled' : 'disabled'}',
          ),
          type: SLToggleSwitchType.standard,
        ),
        SLToggleSwitch(
          title: 'End-of-Day Reminder (${ReminderConfig.endOfDayTime})',
          subtitle: 'Final reminder with alarm-style notification',
          value: endOfDayEnabled,
          icon: Icons.bedtime,
          enabled: remindersEnabled,
          onChanged: (value) => _updateSetting(
            () => ref
                .read(reminderSettingsStateProvider.notifier)
                .setEndOfDayReminderEnabled(value),
            'End-of-day reminder ${value ? 'enabled' : 'disabled'}',
          ),
          type: SLToggleSwitchType.standard,
        ),
      ],
    );
  }
  Widget _buildExplanationsCard(ThemeData theme) {
    final colorScheme = theme.colorScheme;
    return Card(
      margin: EdgeInsets.zero,
      color: colorScheme.surfaceContainerLow,
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('How It Works', style: theme.textTheme.titleMedium),
            const SizedBox(height: AppDimens.spaceM),
            Text(
              '• The noon reminder will always show to help you plan your day.',
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: AppDimens.spaceS),
            Text(
              '• Evening reminders will only show if you have unfinished tasks.',
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: AppDimens.spaceS),
            Text(
              '• This app is optimized for Samsung devices, especially the S23 Ultra.',
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: AppDimens.spaceL),
            Container(
              padding: const EdgeInsets.all(AppDimens.paddingM),
              decoration: BoxDecoration(
                color: colorScheme.errorContainer,
                borderRadius: BorderRadius.circular(AppDimens.radiusM),
              ),
              child: Row(
                children: [
                  Icon(Icons.battery_alert, color: colorScheme.error),
                  const SizedBox(width: AppDimens.spaceM),
                  Expanded(
                    child: Text(
                      'Some devices may limit notifications. Please make sure to '
                      'disable battery optimization for this app in your device settings.',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: colorScheme.onErrorContainer,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildDevicePermissionsCard(
    Map<String, dynamic> permissionsData,
    ThemeData theme,
  ) {
    final isIgnoringBatteryOptimizations =
        permissionsData['isIgnoringBatteryOptimizations'] ?? false;
    final hasExactAlarmPermission =
        permissionsData['hasExactAlarmPermission'] ?? false;
    final deviceInfo =
        permissionsData['deviceInfo'] as Map<String, dynamic>? ?? {};
    final sdkVersion = deviceInfo['sdkVersion'] as int? ?? 0;
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Device Permissions', style: theme.textTheme.titleMedium),
            const SizedBox(height: AppDimens.spaceM),
            _buildPermissionItem(
              context,
              'Battery Optimization',
              isIgnoringBatteryOptimizations,
              Icons.battery_charging_full,
              'Allows reminders to work reliably when the app is in background',
              onRequestPermission: () => _requestPermission(
                () => ref
                    .read(devicePermissionsProvider.notifier)
                    .requestBatteryOptimization(),
                'Battery optimization settings requested',
              ),
            ),
            const SizedBox(height: AppDimens.spaceM),
            if (sdkVersion >= 31)
              _buildPermissionItem(
                context,
                'Exact Alarm Permission',
                hasExactAlarmPermission,
                Icons.alarm,
                'Allows scheduling reminders at precise times (required for Android 12+)',
                onRequestPermission: () => _requestPermission(
                  () => ref
                      .read(devicePermissionsProvider.notifier)
                      .requestExactAlarmPermission(),
                  'Exact alarm permission requested',
                ),
              ),
            const SizedBox(height: AppDimens.spaceL),
            SLButton(
              text: 'Disable Device Sleeping Apps',
              type: SLButtonType.outline,
              prefixIcon: Icons.settings,
              onPressed: () => _requestPermission(
                () => ref
                    .read(devicePermissionsProvider.notifier)
                    .disableSleepingApps(),
                'Opening device-specific settings',
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildPermissionItem(
    BuildContext context,
    String title,
    bool isGranted,
    IconData icon,
    String description, {
    required VoidCallback onRequestPermission,
  }) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return SLToggleSwitch(
      title: title,
      subtitle: description,
      value: isGranted,
      icon: icon,
      onChanged: (_) {},
      enabled: false,
      type: SLToggleSwitchType.outlined,
      trailing: !isGranted
          ? SLButton(
              text: 'Request Permission',
              type: SLButtonType.primary,
              size: SLButtonSize.small,
              onPressed: onRequestPermission,
            )
          : null,
      activeColor: colorScheme.primary,
      inactiveThumbColor: colorScheme.error,
    );
  }
  Future<void> _updateSetting(
    Future<bool> Function() updateFunc,
    String successMessage,
  ) async {
    try {
      final success = await updateFunc();
      if (!mounted) return;
      if (success) {
        SnackBarUtils.show(context, successMessage);
        return;
      }
      SnackBarUtils.show(
        context,
        'Failed to update setting',
        backgroundColor: Theme.of(context).colorScheme.errorContainer,
      );
    } catch (e) {
      if (!mounted) return;
      SnackBarUtils.show(
        context,
        'Error: $e',
        backgroundColor: Theme.of(context).colorScheme.errorContainer,
      );
    }
  }
  Future<void> _requestPermission(
    Future<bool> Function() requestFunc,
    String successMessage,
  ) async {
    try {
      final success = await requestFunc();
      if (!mounted) return;
      if (success) {
        SnackBarUtils.show(context, successMessage);
      }
    } catch (e) {
      if (!mounted) return;
      SnackBarUtils.show(
        context,
        'Error: $e',
        backgroundColor: Theme.of(context).colorScheme.errorContainer,
      );
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/books/books_screen.dart
class BooksScreen extends ConsumerStatefulWidget {
  const BooksScreen({super.key});
  @override
  ConsumerState<BooksScreen> createState() => _BooksScreenState();
}
class _BooksScreenState extends ConsumerState<BooksScreen>
    with TickerProviderStateMixin {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  bool _isSearching = false;
  String? _selectedCategory;
  List<String> _categories = [];
  BookStatus? _selectedStatus;
  DifficultyLevel? _selectedDifficulty;
  bool _isFilterExpanded = false;
  bool _isScrolled = false;
  late AnimationController _filterAnimationController;
  late Animation<double> _filterAnimation;
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) => _loadData());
    _filterAnimationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _filterAnimation = CurvedAnimation(
      parent: _filterAnimationController,
      curve: Curves.easeInOut,
    );
    _scrollController.addListener(_onScroll);
  }
  void _onScroll() {
    final isScrolled = _scrollController.offset > 0;
    if (isScrolled != _isScrolled) {
      setState(() {
        _isScrolled = isScrolled;
      });
    }
  }
  @override
  void dispose() {
    _searchController.dispose();
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    _filterAnimationController.dispose();
    super.dispose();
  }
  Future<void> _loadData({bool forceRefresh = false}) async {
    final booksNotifier = ref.read(booksStateProvider.notifier);
    final categoriesNotifier = ref.read(categoriesProvider.notifier);
    try {
      if (_categories.isEmpty || forceRefresh) {
        await categoriesNotifier.reloadCategories();
        if (mounted) {
          setState(() {
            _categories = ref.read(categoriesProvider).valueOrNull ?? [];
          });
        }
      }
      await booksNotifier.loadBooks();
    } catch (e) {
      final errorMessage = e is AppException
          ? e.message
          : 'An unexpected error occurred. Please try again.';
      if (mounted) {
        SnackBarUtils.show(
          context,
          errorMessage,
          backgroundColor: Theme.of(context).colorScheme.error,
        );
      }
    }
  }
  void _applyFilters() {
    ref
        .read(booksStateProvider.notifier)
        .filterBooks(
          status: _selectedStatus,
          difficultyLevel: _selectedDifficulty,
          category: _selectedCategory,
        );
  }
  void _resetFilters() {
    setState(() {
      _selectedCategory = null;
      _selectedStatus = null;
      _selectedDifficulty = null;
    });
    ref.read(booksStateProvider.notifier).loadBooks();
    if (_isFilterExpanded) {
      _toggleFilterPanel();
    }
  }
  Future<void> _searchBooks(String query) async {
    final booksNotifier = ref.read(booksStateProvider.notifier);
    if (query.isEmpty) {
      setState(() {
        _isSearching = false;
      });
      return booksNotifier.filterBooks(
        status: _selectedStatus,
        difficultyLevel: _selectedDifficulty,
        category: _selectedCategory,
      );
    }
    setState(() {
      _isSearching = true;
    });
    await booksNotifier.searchBooks(query);
  }
  void _toggleFilterPanel() {
    setState(() {
      _isFilterExpanded = !_isFilterExpanded;
    });
    if (_isFilterExpanded) {
      _filterAnimationController.forward();
    } else {
      _filterAnimationController.reverse();
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final currentUser = ref.watch(currentUserProvider);
    if (currentUser == null) {
      return _buildLoginPrompt(theme);
    }
    return Scaffold(
      body: NestedScrollView(
        controller: _scrollController,
        headerSliverBuilder: (context, innerBoxIsScrolled) => [
          _buildAppBar(theme, colorScheme, innerBoxIsScrolled),
        ],
        body: Column(
          children: [
            _buildSearchAndFilterBar(theme, colorScheme),
            AnimatedBuilder(
              animation: _filterAnimation,
              builder: (context, child) {
                return SizeTransition(
                  sizeFactor: _filterAnimation,
                  axisAlignment: -1.0,
                  child: child,
                );
              },
              child: _isFilterExpanded
                  ? BookFilterPanel(
                      categories: _categories,
                      selectedCategory: _selectedCategory,
                      selectedStatus: _selectedStatus,
                      selectedDifficulty: _selectedDifficulty,
                      onCategorySelected: (category) {
                        setState(() => _selectedCategory = category);
                        _applyFilters();
                      },
                      onStatusSelected: (status) {
                        setState(() => _selectedStatus = status);
                        _applyFilters();
                      },
                      onDifficultySelected: (difficulty) {
                        setState(() => _selectedDifficulty = difficulty);
                        _applyFilters();
                      },
                      onFiltersApplied: () {
                        _applyFilters();
                        _toggleFilterPanel();
                      },
                      onFilterCleared: _resetFilters,
                    )
                  : const SizedBox.shrink(),
            ),
            Expanded(
              child: Consumer(
                builder: (context, ref, child) {
                  final booksState = ref.watch(booksStateProvider);
                  return booksState.when(
                    data: (books) => _buildBooksList(
                      books,
                      theme,
                      _isSearching ? 'Search results' : 'Books Library',
                    ),
                    error: (error, stackTrace) => Center(
                      child: SLErrorView(
                        message: error.toString(),
                        onRetry: () => _loadData(forceRefresh: true),
                      ),
                    ),
                    loading: () => const Center(child: SLLoadingIndicator()),
                  );
                },
              ),
            ),
          ],
        ),
      ),
      floatingActionButton: currentUser.roles?.contains('ADMIN') == true
          ? FloatingActionButton(
              onPressed: () => GoRouter.of(context).push('/books/create'),
              tooltip: 'Add Book',
              child: const Icon(Icons.add),
            )
          : null,
    );
  }
  Widget _buildLoginPrompt(ThemeData theme) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Books'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => GoRouter.of(context).pop(),
        ),
      ),
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.lock_outline,
              size: AppDimens.iconXXL,
              color: theme.colorScheme.primary.withValues(alpha: 0.6),
            ),
            const SizedBox(height: AppDimens.spaceL),
            Text(
              'Please log in to browse books',
              style: theme.textTheme.titleLarge?.copyWith(
                color: theme.colorScheme.onSurface,
              ),
            ),
            const SizedBox(height: AppDimens.spaceXL),
            ElevatedButton.icon(
              onPressed: () => GoRouter.of(context).go('/login'),
              icon: const Icon(Icons.login),
              label: const Text('Log In'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimens.paddingXL,
                  vertical: AppDimens.paddingM,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  SliverAppBar _buildAppBar(
    ThemeData theme,
    ColorScheme colorScheme,
    bool innerBoxIsScrolled,
  ) {
    return SliverAppBar(
      title: const Text('Books'),
      floating: true,
      pinned: true,
      forceElevated: _isScrolled || innerBoxIsScrolled,
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        onPressed: () {
          final router = GoRouter.of(context);
          if (router.canPop()) {
            router.pop();
            return;
          }
          router.go('/');
        },
        tooltip: 'Back',
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.refresh_outlined),
          onPressed: () => _loadData(forceRefresh: true),
          tooltip: 'Refresh',
        ),
      ],
    );
  }
  Widget _buildSearchAndFilterBar(ThemeData theme, ColorScheme colorScheme) {
    return Container(
      padding: const EdgeInsets.fromLTRB(
        AppDimens.paddingL,
        AppDimens.paddingM,
        AppDimens.paddingL,
        AppDimens.paddingS,
      ),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        boxShadow: _isScrolled || _isFilterExpanded
            ? [
                BoxShadow(
                  color: theme.colorScheme.shadow.withValues(alpha: 0.05),
                  blurRadius: 4,
                  offset: const Offset(0, 2),
                ),
              ]
            : null,
      ),
      child: Row(
        children: [
          Expanded(
            child: SizedBox(
              height: AppDimens.textFieldHeight,
              child: TextField(
                controller: _searchController,
                decoration: InputDecoration(
                  hintText: 'Search books...',
                  prefixIcon: Icon(
                    Icons.search,
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                  suffixIcon: _searchController.text.isNotEmpty
                      ? IconButton(
                          icon: Icon(
                            Icons.clear,
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                          onPressed: () {
                            _searchController.clear();
                            _searchBooks('');
                          },
                          tooltip: 'Clear search',
                        )
                      : null,
                  filled: true,
                  fillColor: theme.colorScheme.surfaceContainerLowest,
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: AppDimens.paddingM,
                  ),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(AppDimens.radiusL),
                    borderSide: BorderSide.none,
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(AppDimens.radiusL),
                    borderSide: BorderSide(
                      color: theme.colorScheme.outlineVariant.withValues(
                        alpha: 0.5,
                      ),
                    ),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(AppDimens.radiusL),
                    borderSide: BorderSide(
                      color: theme.colorScheme.primary,
                      width: 1.5,
                    ),
                  ),
                ),
                onChanged: _searchBooks,
                onSubmitted: _searchBooks,
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(left: AppDimens.paddingM),
            child: Badge(
              label: Text(_getActiveFilterCount().toString()),
              isLabelVisible: _getActiveFilterCount() > 0,
              child: IconButton.filledTonal(
                icon: Icon(
                  _isFilterExpanded ? Icons.filter_list_off : Icons.filter_list,
                ),
                onPressed: _toggleFilterPanel,
                tooltip: _isFilterExpanded ? 'Hide filters' : 'Show filters',
              ),
            ),
          ),
        ],
      ),
    );
  }
  int _getActiveFilterCount() {
    int count = 0;
    if (_selectedCategory != null) count++;
    if (_selectedStatus != null) count++;
    if (_selectedDifficulty != null) count++;
    return count;
  }
  Widget _buildBooksList(
    List<BookSummary> books,
    ThemeData theme,
    String title,
  ) {
    if (books.isEmpty) {
      return _buildEmptyState(theme);
    }
    return RefreshIndicator(
      onRefresh: () => _loadData(forceRefresh: true),
      child: CustomScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        slivers: [
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(
              AppDimens.paddingL,
              AppDimens.paddingL,
              AppDimens.paddingL,
              AppDimens.paddingS,
            ),
            sliver: SliverToBoxAdapter(
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    '$title (${books.length})',
                    style: theme.textTheme.titleLarge,
                  ),
                ],
              ),
            ),
          ),
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(
              AppDimens.paddingL,
              0,
              AppDimens.paddingL,
              AppDimens.paddingXXXL,
            ),
            sliver: SliverList(
              delegate: SliverChildBuilderDelegate((context, index) {
                final book = books[index];
                return BookListCard(
                  book: book,
                  onTap: () {
                    if (book.id.isEmpty) {
                      SnackBarUtils.show(context, 'Invalid book ID');
                      return;
                    }
                    NavigationHelper.pushWithResult(
                      context,
                      '/books/${book.id}',
                    ).then((result) {
                      if (result == true) {
                        _loadData(forceRefresh: true);
                      }
                    });
                  },
                );
              }, childCount: books.length),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildEmptyState(ThemeData theme) {
    return SLEmptyState(
      icon: _isSearching ? Icons.search_off : Icons.book_outlined,
      title: _isSearching ? 'No books found' : 'No books available',
      message: _isSearching
          ? 'Try adjusting your search or filters.'
          : 'Check back later or refresh.',
      buttonText: _isSearching ? 'Clear Search & Filters' : 'Refresh',
      onButtonPressed: _isSearching
          ? _resetFilters
          : () => _loadData(forceRefresh: true),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/reminder_manager.dart
@riverpod
class ReminderManager extends _$ReminderManager {
  static const String _enabledKey = 'reminders_enabled';
  static const String _noonReminderKey = 'noon_reminder_enabled';
  static const String _eveningFirstReminderKey =
      'evening_first_reminder_enabled';
  static const String _eveningSecondReminderKey =
      'evening_second_reminder_enabled';
  static const String _endOfDayReminderKey = 'end_of_day_reminder_enabled';
  bool _isInitialized = false;
  @override
  Future<Map<String, dynamic>> build() async {
    if (!_isInitialized) {
      await initialize();
    }
    return _loadCurrentSettings();
  }
  Future<Map<String, dynamic>> _loadCurrentSettings() async {
    final storageService = ref.read(storageServiceProvider);
    return {
      'remindersEnabled': await storageService.getBool(_enabledKey) ?? true,
      'noonReminderEnabled':
          await storageService.getBool(_noonReminderKey) ?? true,
      'eveningFirstReminderEnabled':
          await storageService.getBool(_eveningFirstReminderKey) ?? true,
      'eveningSecondReminderEnabled':
          await storageService.getBool(_eveningSecondReminderKey) ?? true,
      'endOfDayReminderEnabled':
          await storageService.getBool(_endOfDayReminderKey) ?? true,
      'isInitialized': _isInitialized,
    };
  }
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    try {
      await _loadPreferences();
      final notificationService = await ref.read(
        notificationServiceProvider.future,
      );
      final bool notificationsInitialized = await notificationService
          .initialize();
      if (!notificationsInitialized) {
        debugPrint('Warning: Failed to initialize notification service');
      }
      final deviceSpecificService = await ref.read(
        deviceSpecificServiceProvider.future,
      );
      final bool deviceServicesInitialized = await deviceSpecificService
          .initialize();
      if (!deviceServicesInitialized) {
        debugPrint('Warning: Failed to initialize device-specific services');
      }
      final settings = state.valueOrNull ?? {};
      if (settings['remindersEnabled'] == true) {
        await scheduleAllReminders();
      }
      _isInitialized = true;
      state = AsyncValue.data(await _loadCurrentSettings());
      return true;
    } catch (e) {
      debugPrint('Error initializing ReminderManager: $e');
      state = AsyncValue.error(e, StackTrace.current);
      return false;
    }
  }
  Future<void> _loadPreferences() async {
    try {
      final _ = await SharedPreferences.getInstance();
      final storageService = ref.read(storageServiceProvider);
      final remindersEnabled =
          await storageService.getBool(_enabledKey) ?? true;
      final noonReminderEnabled =
          await storageService.getBool(_noonReminderKey) ?? true;
      final eveningFirstReminderEnabled =
          await storageService.getBool(_eveningFirstReminderKey) ?? true;
      final eveningSecondReminderEnabled =
          await storageService.getBool(_eveningSecondReminderKey) ?? true;
      final endOfDayReminderEnabled =
          await storageService.getBool(_endOfDayReminderKey) ?? true;
      debugPrint('Loaded reminder preferences:');
      debugPrint('- Reminders enabled: $remindersEnabled');
      debugPrint('- Noon reminder: $noonReminderEnabled');
      debugPrint('- Evening first: $eveningFirstReminderEnabled');
      debugPrint('- Evening second: $eveningSecondReminderEnabled');
      debugPrint('- End of day: $endOfDayReminderEnabled');
    } catch (e) {
      debugPrint('Error loading reminder preferences: $e');
    }
  }
  Future<bool> _savePreferences(Map<String, dynamic> settings) async {
    try {
      final storageService = ref.read(storageServiceProvider);
      await storageService.setBool(_enabledKey, settings['remindersEnabled']);
      await storageService.setBool(
        _noonReminderKey,
        settings['noonReminderEnabled'],
      );
      await storageService.setBool(
        _eveningFirstReminderKey,
        settings['eveningFirstReminderEnabled'],
      );
      await storageService.setBool(
        _eveningSecondReminderKey,
        settings['eveningSecondReminderEnabled'],
      );
      await storageService.setBool(
        _endOfDayReminderKey,
        settings['endOfDayReminderEnabled'],
      );
      return true;
    } catch (e) {
      debugPrint('Error saving reminder preferences: $e');
      return false;
    }
  }
  Future<bool> hasPendingTasksToday() async {
    try {
      final storageService = ref.read(storageServiceProvider);
      final userData = await storageService.getUserData();
      final userId = userData?['id'];
      if (userId == null) {
        debugPrint('Cannot check pending tasks: User not logged in');
        return false; // Not logged in
      }
      await ref
          .read(progressStateProvider.notifier)
          .loadDueProgress(userId.toString(), studyDate: DateTime.now());
      final progressRecords = ref.read(progressStateProvider).valueOrNull ?? [];
      final hasTasks = progressRecords.isNotEmpty;
      debugPrint('Pending tasks check: ${hasTasks ? 'Has tasks' : 'No tasks'}');
      return hasTasks;
    } catch (e) {
      debugPrint('Error checking pending tasks: $e');
      return false; // Assume no tasks on error
    }
  }
  Future<bool> scheduleAllReminders() async {
    try {
      if (!_isInitialized) {
        final bool initialized = await initialize();
        if (!initialized) {
          debugPrint('Failed to initialize ReminderManager');
          return false;
        }
      }
      final notificationService = await ref.read(
        notificationServiceProvider.future,
      );
      await notificationService.cancelAllNotifications();
      final settings = state.valueOrNull ?? {};
      final remindersEnabled = settings['remindersEnabled'] ?? true;
      if (!remindersEnabled) {
        debugPrint('Reminders are disabled, not scheduling any reminders');
        return true;
      }
      final noonReminderEnabled = settings['noonReminderEnabled'] ?? true;
      if (noonReminderEnabled) {
        final bool noonResult = await notificationService
            .scheduleNoonReminder();
        debugPrint('Noon reminder scheduled: $noonResult');
      }
      final hasPendingTasks = await hasPendingTasksToday();
      if (hasPendingTasks) {
        final eveningFirstReminderEnabled =
            settings['eveningFirstReminderEnabled'] ?? true;
        if (eveningFirstReminderEnabled) {
          final bool eveningFirstResult = await notificationService
              .scheduleEveningFirstReminder();
          debugPrint('Evening first reminder scheduled: $eveningFirstResult');
        }
        final eveningSecondReminderEnabled =
            settings['eveningSecondReminderEnabled'] ?? true;
        if (eveningSecondReminderEnabled) {
          final bool eveningSecondResult = await notificationService
              .scheduleEveningSecondReminder();
          debugPrint('Evening second reminder scheduled: $eveningSecondResult');
        }
        final endOfDayReminderEnabled =
            settings['endOfDayReminderEnabled'] ?? true;
        if (endOfDayReminderEnabled) {
          final deviceSpecificService = await ref.read(
            deviceSpecificServiceProvider.future,
          );
          final useAlarmStyle =
              deviceSpecificService.isAndroid &&
              (deviceSpecificService.isSamsungDevice ||
                  deviceSpecificService.sdkVersion >= 26);
          final bool endOfDayResult = await notificationService
              .scheduleEndOfDayReminder(useAlarmStyle: useAlarmStyle);
          debugPrint(
            'End of day reminder scheduled: $endOfDayResult (alarm style: $useAlarmStyle)',
          );
        }
      } else {
        debugPrint(
          'No pending tasks today, skipping evening and end-of-day reminders',
        );
      }
      return true;
    } catch (e) {
      debugPrint('Error scheduling reminders: $e');
      return false;
    }
  }
  Future<bool> updateRemindersAfterTaskCompletion() async {
    try {
      final stillHasPendingTasks = await hasPendingTasksToday();
      if (!stillHasPendingTasks) {
        debugPrint(
          'All tasks completed, cancelling evening and end-of-day reminders',
        );
        final notificationService = await ref.read(
          notificationServiceProvider.future,
        );
        await notificationService.cancelNotification(
          NotificationService.eveningFirstReminderId,
        );
        await notificationService.cancelNotification(
          NotificationService.eveningSecondReminderId,
        );
        await notificationService.cancelNotification(
          NotificationService.endOfDayReminderId,
        );
      }
      return true;
    } catch (e) {
      debugPrint('Error updating reminders after task completion: $e');
      return false;
    }
  }
  Future<bool> setRemindersEnabled(bool value) async {
    final currentSettings = state.valueOrNull ?? {};
    if (currentSettings['remindersEnabled'] == value) return true;
    final updatedSettings = {...currentSettings, 'remindersEnabled': value};
    final bool saved = await _savePreferences(updatedSettings);
    if (!saved) return false;
    if (value) {
      final result = await scheduleAllReminders();
      state = AsyncValue.data(updatedSettings);
      return result;
    } else {
      final notificationService = await ref.read(
        notificationServiceProvider.future,
      );
      final result = await notificationService.cancelAllNotifications();
      state = AsyncValue.data(updatedSettings);
      return result;
    }
  }
  Future<bool> setNoonReminderEnabled(bool value) async {
    final currentSettings = state.valueOrNull ?? {};
    if (currentSettings['noonReminderEnabled'] == value) return true;
    final updatedSettings = {...currentSettings, 'noonReminderEnabled': value};
    final bool saved = await _savePreferences(updatedSettings);
    if (!saved) return false;
    if (currentSettings['remindersEnabled'] == true) {
      final notificationService = await ref.read(
        notificationServiceProvider.future,
      );
      if (value) {
        final result = await notificationService.scheduleNoonReminder();
        state = AsyncValue.data(updatedSettings);
        return result;
      } else {
        final result = await notificationService.cancelNotification(
          NotificationService.noonReminderId,
        );
        state = AsyncValue.data(updatedSettings);
        return result;
      }
    }
    state = AsyncValue.data(updatedSettings);
    return true;
  }
  Future<bool> setEveningFirstReminderEnabled(bool value) async {
    final currentSettings = state.valueOrNull ?? {};
    if (currentSettings['eveningFirstReminderEnabled'] == value) return true;
    final updatedSettings = {
      ...currentSettings,
      'eveningFirstReminderEnabled': value,
    };
    final bool saved = await _savePreferences(updatedSettings);
    if (!saved) return false;
    if (currentSettings['remindersEnabled'] == true) {
      final notificationService = await ref.read(
        notificationServiceProvider.future,
      );
      if (value && await hasPendingTasksToday()) {
        final result = await notificationService.scheduleEveningFirstReminder();
        state = AsyncValue.data(updatedSettings);
        return result;
      } else {
        final result = await notificationService.cancelNotification(
          NotificationService.eveningFirstReminderId,
        );
        state = AsyncValue.data(updatedSettings);
        return result;
      }
    }
    state = AsyncValue.data(updatedSettings);
    return true;
  }
  Future<bool> setEveningSecondReminderEnabled(bool value) async {
    final currentSettings = state.valueOrNull ?? {};
    if (currentSettings['eveningSecondReminderEnabled'] == value) return true;
    final updatedSettings = {
      ...currentSettings,
      'eveningSecondReminderEnabled': value,
    };
    final bool saved = await _savePreferences(updatedSettings);
    if (!saved) return false;
    if (currentSettings['remindersEnabled'] == true) {
      final notificationService = await ref.read(
        notificationServiceProvider.future,
      );
      if (value && await hasPendingTasksToday()) {
        final result = await notificationService
            .scheduleEveningSecondReminder();
        state = AsyncValue.data(updatedSettings);
        return result;
      } else {
        final result = await notificationService.cancelNotification(
          NotificationService.eveningSecondReminderId,
        );
        state = AsyncValue.data(updatedSettings);
        return result;
      }
    }
    state = AsyncValue.data(updatedSettings);
    return true;
  }
  Future<bool> setEndOfDayReminderEnabled(bool value) async {
    final currentSettings = state.valueOrNull ?? {};
    if (currentSettings['endOfDayReminderEnabled'] == value) return true;
    final updatedSettings = {
      ...currentSettings,
      'endOfDayReminderEnabled': value,
    };
    final bool saved = await _savePreferences(updatedSettings);
    if (!saved) return false;
    if (currentSettings['remindersEnabled'] == true) {
      final notificationService = await ref.read(
        notificationServiceProvider.future,
      );
      if (value && await hasPendingTasksToday()) {
        final result = await notificationService.scheduleEndOfDayReminder();
        state = AsyncValue.data(updatedSettings);
        return result;
      } else {
        final result = await notificationService.cancelNotification(
          NotificationService.endOfDayReminderId,
        );
        state = AsyncValue.data(updatedSettings);
        return result;
      }
    }
    state = AsyncValue.data(updatedSettings);
    return true;
  }
}
@riverpod
bool isReminderInitialized(Ref ref) {
  final settings = ref.watch(reminderManagerProvider).valueOrNull;
  return settings?['isInitialized'] ?? false;
}
@riverpod
bool areRemindersEnabled(Ref ref) {
  final settings = ref.watch(reminderManagerProvider).valueOrNull;
  return settings?['remindersEnabled'] ?? true;
}
@riverpod
bool isNoonReminderEnabled(Ref ref) {
  final settings = ref.watch(reminderManagerProvider).valueOrNull;
  return settings?['noonReminderEnabled'] ?? true;
}
@riverpod
bool isEveningFirstReminderEnabled(Ref ref) {
  final settings = ref.watch(reminderManagerProvider).valueOrNull;
  return settings?['eveningFirstReminderEnabled'] ?? true;
}
@riverpod
bool isEveningSecondReminderEnabled(Ref ref) {
  final settings = ref.watch(reminderManagerProvider).valueOrNull;
  return settings?['eveningSecondReminderEnabled'] ?? true;
}
@riverpod
bool isEndOfDayReminderEnabled(Ref ref) {
  final settings = ref.watch(reminderManagerProvider).valueOrNull;
  return settings?['endOfDayReminderEnabled'] ?? true;
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/reminder_service.dart
class ReminderService {
  final NotificationService _notificationService;
  final StorageService _storageService;
  final DeviceSpecificService _deviceSpecificService;
  final ProgressRepository _progressRepository;
  final EventBus _eventBus;
  final List<StreamSubscription> _subscriptions = [];
  bool _isInitialized = false;
  bool _isScheduling = false;
  ReminderService({
    required NotificationService notificationService,
    required StorageService storageService,
    required DeviceSpecificService deviceSpecificService,
    required ProgressRepository progressRepository,
    required EventBus eventBus,
  }) : _notificationService = notificationService,
       _storageService = storageService,
       _deviceSpecificService = deviceSpecificService,
       _progressRepository = progressRepository,
       _eventBus = eventBus {
    _listenToEvents();
  }
  void _listenToEvents() {
    _subscriptions.add(
      _eventBus.on<ProgressChangedEvent>().listen(_handleProgressChanged),
    );
    _subscriptions.add(
      _eventBus.on<TaskCompletedEvent>().listen(_handleTaskCompleted),
    );
    _subscriptions.add(
      _eventBus.on<ReminderSettingsChangedEvent>().listen(
        _handleSettingsChanged,
      ),
    );
  }
  void dispose() {
    for (var subscription in _subscriptions) {
      subscription.cancel();
    }
    _subscriptions.clear();
  }
  void _handleProgressChanged(ProgressChangedEvent event) {
    if (event.hasDueTasks) {
      scheduleAllReminders();
    }
  }
  void _handleTaskCompleted(TaskCompletedEvent event) {
    updateRemindersAfterTaskCompletion();
  }
  void _handleSettingsChanged(ReminderSettingsChangedEvent event) {
    if (event.enabled) {
      scheduleAllReminders();
    } else {
      _notificationService.cancelAllNotifications();
    }
  }
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    try {
      await _loadPreferences();
      final bool notificationsInitialized = await _notificationService
          .initialize();
      if (!notificationsInitialized) {
        debugPrint('Warning: Failed to initialize notification service');
      }
      final bool deviceServicesInitialized = await _deviceSpecificService
          .initialize();
      if (!deviceServicesInitialized) {
        debugPrint('Warning: Failed to initialize device-specific services');
      }
      final remindersEnabled =
          await _storageService.getBool('reminders_enabled') ?? true;
      if (remindersEnabled) {
        await scheduleAllReminders();
      }
      _isInitialized = true;
      return true;
    } catch (e) {
      debugPrint('Error initializing ReminderService: $e');
      return false;
    }
  }
  Future<void> _loadPreferences() async {
    try {
      debugPrint('Reminder preferences loaded');
    } catch (e) {
      debugPrint('Error loading reminder preferences: $e');
    }
  }
  Future<bool> hasPendingTasksToday() async {
    final userData = await _storageService.getUserData();
    final userId = userData?['id'];
    if (userId == null) {
      debugPrint('Cannot check pending tasks: User not logged in');
      return false;
    }
    try {
      final today = DateTime.now();
      final progress = await _progressRepository.getDueProgress(
        userId.toString(),
        studyDate: today,
      );
      final hasTasks = progress.isNotEmpty;
      debugPrint('Pending tasks check: ${hasTasks ? 'Has tasks' : 'No tasks'}');
      return hasTasks;
    } catch (e) {
      debugPrint('Error checking pending tasks: $e');
      return false;
    }
  }
  Future<bool> scheduleAllReminders() async {
    if (_isScheduling) return false;
    _isScheduling = true;
    try {
      if (!await _prepareForScheduling()) {
        _isScheduling = false;
        return false;
      }
      final remindersEnabled =
          await _storageService.getBool('reminders_enabled') ?? true;
      if (!remindersEnabled) {
        debugPrint('Reminders are disabled, not scheduling any reminders');
        _isScheduling = false;
        return true;
      }
      await _checkAndLogPermissions();
      if (!await _scheduleNoonReminder()) {
        debugPrint('Failed to schedule noon reminder');
      }
      final hasPendingTasks = await hasPendingTasksToday();
      if (!hasPendingTasks) {
        debugPrint(
          'No pending tasks today, skipping evening and end-of-day reminders',
        );
        _isScheduling = false;
        return true;
      }
      await _scheduleEveningReminders();
      await _scheduleEndOfDayReminder();
      _isScheduling = false;
      return true;
    } catch (e) {
      debugPrint('Error scheduling reminders: $e');
      _isScheduling = false;
      return false;
    }
  }
  Future<bool> _prepareForScheduling() async {
    debugPrint('========== DEBUGGING REMINDERS ==========');
    debugPrint('Initialized: $_isInitialized');
    if (!_isInitialized) {
      final bool initialized = await initialize();
      debugPrint('Initialization result: $initialized');
      if (!initialized) {
        debugPrint('Failed to initialize ReminderService');
        return false;
      }
    }
    await _notificationService.cancelAllNotifications();
    debugPrint('All previous notifications cancelled');
    return true;
  }
  Future<void> _checkAndLogPermissions() async {
    final deviceService = _deviceSpecificService;
    final hasAlarm = await deviceService.hasExactAlarmPermission();
    final ignoresBattery = await deviceService.isIgnoringBatteryOptimizations();
    debugPrint(
      'Permission check - Exact alarm: $hasAlarm, Battery optimization: $ignoresBattery',
    );
  }
  Future<bool> _scheduleNoonReminder() async {
    final noonReminderEnabled =
        await _storageService.getBool('noon_reminder_enabled') ?? true;
    if (!noonReminderEnabled) {
      return true;
    }
    final bool noonResult = await _notificationService.scheduleNoonReminder();
    debugPrint('Noon reminder scheduled: $noonResult');
    return noonResult;
  }
  Future<void> _scheduleEveningReminders() async {
    final eveningFirstReminderEnabled =
        await _storageService.getBool('evening_first_reminder_enabled') ?? true;
    if (eveningFirstReminderEnabled) {
      final bool eveningFirstResult = await _notificationService
          .scheduleEveningFirstReminder();
      debugPrint('Evening first reminder scheduled: $eveningFirstResult');
    }
    final eveningSecondReminderEnabled =
        await _storageService.getBool('evening_second_reminder_enabled') ??
        true;
    if (eveningSecondReminderEnabled) {
      final bool eveningSecondResult = await _notificationService
          .scheduleEveningSecondReminder();
      debugPrint('Evening second reminder scheduled: $eveningSecondResult');
    }
  }
  Future<void> _scheduleEndOfDayReminder() async {
    final endOfDayReminderEnabled =
        await _storageService.getBool('end_of_day_reminder_enabled') ?? true;
    if (!endOfDayReminderEnabled) {
      return;
    }
    final useAlarmStyle =
        _deviceSpecificService.isAndroid &&
        (_deviceSpecificService.isSamsungDevice ||
            _deviceSpecificService.sdkVersion >= 26);
    final bool endOfDayResult = await _notificationService
        .scheduleEndOfDayReminder(useAlarmStyle: useAlarmStyle);
    debugPrint(
      'End of day reminder scheduled: $endOfDayResult (alarm style: $useAlarmStyle)',
    );
  }
  Future<bool> updateRemindersAfterTaskCompletion() async {
    try {
      final stillHasPendingTasks = await hasPendingTasksToday();
      if (stillHasPendingTasks) {
        return true;
      }
      debugPrint(
        'All tasks completed, cancelling evening and end-of-day reminders',
      );
      await _notificationService.cancelNotification(
        NotificationService.eveningFirstReminderId,
      );
      await _notificationService.cancelNotification(
        NotificationService.eveningSecondReminderId,
      );
      await _notificationService.cancelNotification(
        NotificationService.endOfDayReminderId,
      );
      return true;
    } catch (e) {
      debugPrint('Error updating reminders after task completion: $e');
      return false;
    }
  }
  Future<bool> getRemindersEnabled() async {
    return await _storageService.getBool('reminders_enabled') ?? true;
  }
  Future<bool> getNoonReminderEnabled() async {
    return await _storageService.getBool('noon_reminder_enabled') ?? true;
  }
  Future<bool> getEveningFirstReminderEnabled() async {
    return await _storageService.getBool('evening_first_reminder_enabled') ??
        true;
  }
  Future<bool> getEveningSecondReminderEnabled() async {
    return await _storageService.getBool('evening_second_reminder_enabled') ??
        true;
  }
  Future<bool> getEndOfDayReminderEnabled() async {
    return await _storageService.getBool('end_of_day_reminder_enabled') ?? true;
  }
  Future<bool> setRemindersEnabled(bool value) async {
    try {
      await _storageService.setBool('reminders_enabled', value);
      if (value) {
        return await scheduleAllReminders();
      }
      return await _notificationService.cancelAllNotifications();
    } catch (e) {
      debugPrint('Error setting reminders enabled: $e');
      return false;
    }
  }
  Future<bool> setNoonReminderEnabled(bool value) async {
    try {
      await _storageService.setBool('noon_reminder_enabled', value);
      final remindersEnabled =
          await _storageService.getBool('reminders_enabled') ?? true;
      if (!remindersEnabled) {
        return true;
      }
      if (value) {
        return await _notificationService.scheduleNoonReminder();
      }
      return await _notificationService.cancelNotification(
        NotificationService.noonReminderId,
      );
    } catch (e) {
      debugPrint('Error setting noon reminder: $e');
      return false;
    }
  }
  Future<bool> setEveningFirstReminderEnabled(bool value) async {
    try {
      await _storageService.setBool('evening_first_reminder_enabled', value);
      final remindersEnabled =
          await _storageService.getBool('reminders_enabled') ?? true;
      if (!remindersEnabled) {
        return true;
      }
      if (value && await hasPendingTasksToday()) {
        return await _notificationService.scheduleEveningFirstReminder();
      }
      return await _notificationService.cancelNotification(
        NotificationService.eveningFirstReminderId,
      );
    } catch (e) {
      debugPrint('Error setting evening first reminder: $e');
      return false;
    }
  }
  Future<bool> setEveningSecondReminderEnabled(bool value) async {
    try {
      await _storageService.setBool('evening_second_reminder_enabled', value);
      final remindersEnabled =
          await _storageService.getBool('reminders_enabled') ?? true;
      if (!remindersEnabled) {
        return true;
      }
      if (value && await hasPendingTasksToday()) {
        return await _notificationService.scheduleEveningSecondReminder();
      }
      return await _notificationService.cancelNotification(
        NotificationService.eveningSecondReminderId,
      );
    } catch (e) {
      debugPrint('Error setting evening second reminder: $e');
      return false;
    }
  }
  Future<bool> setEndOfDayReminderEnabled(bool value) async {
    try {
      await _storageService.setBool('end_of_day_reminder_enabled', value);
      final remindersEnabled =
          await _storageService.getBool('reminders_enabled') ?? true;
      if (!remindersEnabled) {
        return true;
      }
      if (value && await hasPendingTasksToday()) {
        return await _notificationService.scheduleEndOfDayReminder();
      }
      return await _notificationService.cancelNotification(
        NotificationService.endOfDayReminderId,
      );
    } catch (e) {
      debugPrint('Error setting end of day reminder: $e');
      return false;
    }
  }
}
@riverpod
class ReminderSettings extends _$ReminderSettings {
  @override
  Future<Map<String, bool>> build() async {
    final reminderService = await ref.watch(reminderServiceProvider.future);
    final Map<String, bool> settings = {
      'reminders_enabled': await reminderService.getRemindersEnabled(),
      'noon_reminder_enabled': await reminderService.getNoonReminderEnabled(),
      'evening_first_reminder_enabled': await reminderService
          .getEveningFirstReminderEnabled(),
      'evening_second_reminder_enabled': await reminderService
          .getEveningSecondReminderEnabled(),
      'end_of_day_reminder_enabled': await reminderService
          .getEndOfDayReminderEnabled(),
    };
    return settings;
  }
  Future<void> setRemindersEnabled(bool value) async {
    final reminderService = await ref.read(reminderServiceProvider.future);
    final result = await reminderService.setRemindersEnabled(value);
    if (result) {
      state = AsyncValue.data({
        ...state.valueOrNull ?? {},
        'reminders_enabled': value,
      });
      final eventBus = ref.read(eventBusProvider);
      eventBus.fire(ReminderSettingsChangedEvent(enabled: value));
    }
  }
  Future<void> setNoonReminderEnabled(bool value) async {
    final reminderService = await ref.read(reminderServiceProvider.future);
    final result = await reminderService.setNoonReminderEnabled(value);
    if (result) {
      state = AsyncValue.data({
        ...state.valueOrNull ?? {},
        'noon_reminder_enabled': value,
      });
    }
  }
  Future<void> setEveningFirstReminderEnabled(bool value) async {
    final reminderService = await ref.read(reminderServiceProvider.future);
    final result = await reminderService.setEveningFirstReminderEnabled(value);
    if (result) {
      state = AsyncValue.data({
        ...state.valueOrNull ?? {},
        'evening_first_reminder_enabled': value,
      });
    }
  }
  Future<void> setEveningSecondReminderEnabled(bool value) async {
    final reminderService = await ref.read(reminderServiceProvider.future);
    final result = await reminderService.setEveningSecondReminderEnabled(value);
    if (result) {
      state = AsyncValue.data({
        ...state.valueOrNull ?? {},
        'evening_second_reminder_enabled': value,
      });
    }
  }
  Future<void> setEndOfDayReminderEnabled(bool value) async {
    final reminderService = await ref.read(reminderServiceProvider.future);
    final result = await reminderService.setEndOfDayReminderEnabled(value);
    if (result) {
      state = AsyncValue.data({
        ...state.valueOrNull ?? {},
        'end_of_day_reminder_enabled': value,
      });
    }
  }
  Future<void> scheduleAllReminders() async {
    final reminderService = await ref.read(reminderServiceProvider.future);
    await reminderService.scheduleAllReminders();
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/app_button.dart
enum SLButtonType {
  primary,
  secondary,
  outline,
  text,
  ghost,
  error,
  success,
  warning,
  gradient,
}
enum SLButtonSize { tiny, small, medium, large, xlarge }
class SLButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final SLButtonType type;
  final SLButtonSize size;
  final IconData? prefixIcon;
  final IconData? suffixIcon;
  final Widget? prefixWidget;
  final Widget? suffixWidget;
  final bool isLoading;
  final bool isFullWidth;
  final double? width;
  final Color? backgroundColor;
  final Color? textColor;
  final Color? iconColor;
  final Color? borderColor;
  final Color? loadingColor;
  final double? elevation;
  final BorderRadius? customBorderRadius;
  final LinearGradient? customGradient;
  const SLButton({
    super.key,
    required this.text,
    this.onPressed,
    this.type = SLButtonType.primary,
    this.size = SLButtonSize.medium,
    this.prefixIcon,
    this.suffixIcon,
    this.prefixWidget,
    this.suffixWidget,
    this.isLoading = false,
    this.isFullWidth = false,
    this.width,
    this.backgroundColor,
    this.textColor,
    this.iconColor,
    this.borderColor,
    this.loadingColor,
    this.elevation,
    this.customBorderRadius,
    this.customGradient,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    EdgeInsets padding;
    double height;
    double iconSize;
    double borderRadius;
    TextStyle textStyle;
    switch (size) {
      case SLButtonSize.tiny:
        padding = const EdgeInsets.symmetric(
          horizontal: AppDimens.paddingS,
          vertical: AppDimens.paddingXS,
        );
        height = AppDimens.buttonHeightS;
        iconSize = AppDimens.iconXS;
        borderRadius = AppDimens.radiusXS + 2;
        textStyle = theme.textTheme.bodySmall!.copyWith(
          fontWeight: FontWeight.w600,
          letterSpacing: 0.25,
        );
        break;
      case SLButtonSize.small:
        padding = const EdgeInsets.symmetric(
          horizontal: AppDimens.paddingM,
          vertical: AppDimens.paddingS,
        );
        height = AppDimens.buttonHeightM;
        iconSize = AppDimens.iconS;
        borderRadius = AppDimens.radiusS;
        textStyle = theme.textTheme.bodySmall!.copyWith(
          fontWeight: FontWeight.w600,
          letterSpacing: 0.5,
        );
        break;
      case SLButtonSize.medium:
        padding = const EdgeInsets.symmetric(
          horizontal: AppDimens.paddingL + 4,
          vertical: AppDimens.paddingM,
        );
        height = AppDimens.buttonHeightL;
        iconSize = AppDimens.iconM;
        borderRadius = AppDimens.radiusM;
        textStyle = theme.textTheme.bodyMedium!.copyWith(
          fontWeight: FontWeight.w600,
          letterSpacing: 0.5,
        );
        break;
      case SLButtonSize.large:
        padding = const EdgeInsets.symmetric(
          horizontal: AppDimens.paddingXL,
          vertical: AppDimens.paddingL,
        );
        height = AppDimens.buttonHeightXL;
        iconSize = AppDimens.iconL;
        borderRadius = AppDimens.radiusL;
        textStyle = theme.textTheme.bodyLarge!.copyWith(
          fontWeight: FontWeight.w600,
          letterSpacing: 0.5,
        );
        break;
      case SLButtonSize.xlarge:
        padding = const EdgeInsets.symmetric(
          horizontal: AppDimens.paddingXXL,
          vertical: AppDimens.paddingL + 4,
        );
        height = AppDimens.buttonHeightXL + 8;
        iconSize = AppDimens.iconXL - 4;
        borderRadius = AppDimens.radiusL + 4;
        textStyle = theme.textTheme.titleMedium!.copyWith(
          fontWeight: FontWeight.w600,
          letterSpacing: 0.5,
        );
        break;
    }
    Color defaultBackgroundColor;
    Color defaultTextColor;
    Color defaultBorderColor;
    double defaultElevation;
    LinearGradient? defaultGradient;
    switch (type) {
      case SLButtonType.primary:
        defaultBackgroundColor = colorScheme.primary;
        defaultTextColor = colorScheme.onPrimary;
        defaultBorderColor = Colors.transparent;
        defaultElevation = AppDimens.elevationS;
        break;
      case SLButtonType.secondary:
        defaultBackgroundColor = colorScheme.secondary;
        defaultTextColor = colorScheme.onSecondary;
        defaultBorderColor = Colors.transparent;
        defaultElevation = AppDimens.elevationS;
        break;
      case SLButtonType.outline:
        defaultBackgroundColor = Colors.transparent;
        defaultTextColor = colorScheme.primary;
        defaultBorderColor = colorScheme.outline;
        defaultElevation = 0;
        break;
      case SLButtonType.text:
        defaultBackgroundColor = Colors.transparent;
        defaultTextColor = colorScheme.primary;
        defaultBorderColor = Colors.transparent;
        defaultElevation = 0;
        break;
      case SLButtonType.ghost:
        defaultBackgroundColor = colorScheme.primary.withValues(
          alpha: AppDimens.opacityLight,
        );
        defaultTextColor = colorScheme.primary;
        defaultBorderColor = Colors.transparent;
        defaultElevation = 0;
        break;
      case SLButtonType.error:
        defaultBackgroundColor = colorScheme.error;
        defaultTextColor = colorScheme.onError;
        defaultBorderColor = Colors.transparent;
        defaultElevation = AppDimens.elevationS;
        break;
      case SLButtonType.success:
        defaultBackgroundColor = colorScheme.success;
        defaultTextColor = colorScheme.onSuccess;
        defaultBorderColor = Colors.transparent;
        defaultElevation = AppDimens.elevationS;
        break;
      case SLButtonType.warning:
        defaultBackgroundColor = colorScheme.warning;
        defaultTextColor = colorScheme.onWarning;
        defaultBorderColor = Colors.transparent;
        defaultElevation = AppDimens.elevationS;
        break;
      case SLButtonType.gradient:
        defaultBackgroundColor = Colors.transparent;
        defaultTextColor = Colors.white;
        defaultBorderColor = Colors.transparent;
        defaultElevation = AppDimens.elevationS;
        defaultGradient =
            customGradient ??
            LinearGradient(
              colors: [colorScheme.primary, colorScheme.secondary],
            );
        break;
    }
    final effectiveBackgroundColor = backgroundColor ?? defaultBackgroundColor;
    final effectiveTextColor = textColor ?? defaultTextColor;
    final effectiveIconColor = iconColor ?? effectiveTextColor;
    final effectiveBorderColor = borderColor ?? defaultBorderColor;
    final effectiveLoadingColor = loadingColor ?? effectiveTextColor;
    final effectiveElevation = elevation ?? defaultElevation;
    final effectiveBorderRadius =
        customBorderRadius ?? BorderRadius.circular(borderRadius);
    if (type == SLButtonType.gradient) {
      return SizedBox(
        width: width ?? (isFullWidth ? double.infinity : null),
        height: height,
        child: DecoratedBox(
          decoration: BoxDecoration(
            gradient: defaultGradient,
            borderRadius: effectiveBorderRadius,
            boxShadow: effectiveElevation > 0
                ? [
                    BoxShadow(
                      color: Colors.black.withValues(
                        alpha: AppDimens.opacitySemi,
                      ),
                      spreadRadius: 0,
                      blurRadius: effectiveElevation * 2,
                      offset: Offset(0, effectiveElevation / 2),
                    ),
                  ]
                : null,
          ),
          child: ElevatedButton(
            onPressed: isLoading ? null : onPressed,
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.transparent,
              disabledBackgroundColor: Colors.transparent,
              shadowColor: Colors.transparent,
              padding: padding,
              shape: RoundedRectangleBorder(
                borderRadius: effectiveBorderRadius,
              ),
            ),
            child: _buildContent(
              effectiveTextColor,
              effectiveIconColor,
              effectiveLoadingColor,
              iconSize,
              textStyle,
            ),
          ),
        ),
      );
    }
    Widget button;
    switch (type) {
      case SLButtonType.primary:
      case SLButtonType.secondary:
      case SLButtonType.error:
      case SLButtonType.success:
      case SLButtonType.warning:
      case SLButtonType.ghost:
        button = ElevatedButton(
          onPressed: isLoading ? null : onPressed,
          style: ElevatedButton.styleFrom(
            foregroundColor: effectiveTextColor,
            backgroundColor: effectiveBackgroundColor,
            shape: RoundedRectangleBorder(
              borderRadius: effectiveBorderRadius,
              side: BorderSide(color: effectiveBorderColor),
            ),
            padding: padding,
            minimumSize: Size(0, height),
            elevation: effectiveElevation,
            disabledBackgroundColor: colorScheme.onSurface.withValues(
              alpha: AppDimens.opacityMedium,
            ),
            disabledForegroundColor: colorScheme.onSurface.withValues(
              alpha: AppDimens.opacityDisabled,
            ),
            shadowColor: type == SLButtonType.ghost ? Colors.transparent : null,
          ),
          child: _buildContent(
            effectiveTextColor,
            effectiveIconColor,
            effectiveLoadingColor,
            iconSize,
            textStyle,
          ),
        );
        break;
      case SLButtonType.outline:
        button = OutlinedButton(
          onPressed: isLoading ? null : onPressed,
          style: OutlinedButton.styleFrom(
            foregroundColor: effectiveTextColor,
            shape: RoundedRectangleBorder(borderRadius: effectiveBorderRadius),
            side: BorderSide(
              color: effectiveBorderColor,
              width: AppDimens.outlineButtonBorderWidth,
            ),
            padding: padding,
            minimumSize: Size(0, height),
            backgroundColor: effectiveBackgroundColor,
            disabledForegroundColor: colorScheme.onSurface.withValues(
              alpha: AppDimens.opacityDisabled,
            ),
          ),
          child: _buildContent(
            effectiveTextColor,
            effectiveIconColor,
            effectiveLoadingColor,
            iconSize,
            textStyle,
          ),
        );
        break;
      case SLButtonType.text:
        button = TextButton(
          onPressed: isLoading ? null : onPressed,
          style: TextButton.styleFrom(
            foregroundColor: effectiveTextColor,
            shape: RoundedRectangleBorder(borderRadius: effectiveBorderRadius),
            padding: padding,
            minimumSize: Size(0, height),
            backgroundColor: effectiveBackgroundColor,
            disabledForegroundColor: colorScheme.onSurface.withValues(
              alpha: AppDimens.opacityDisabled,
            ),
          ),
          child: _buildContent(
            effectiveTextColor,
            effectiveIconColor,
            effectiveLoadingColor,
            iconSize,
            textStyle,
          ),
        );
        break;
      case SLButtonType.gradient:
        button = ElevatedButton(
          onPressed: isLoading ? null : onPressed,
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.transparent,
            shadowColor: Colors.transparent,
            foregroundColor: effectiveTextColor,
            padding: padding,
            minimumSize: Size(0, height),
          ),
          child: _buildContent(
            effectiveTextColor,
            effectiveIconColor,
            effectiveLoadingColor,
            iconSize,
            textStyle,
          ),
        );
        break;
    }
    if (width != null) {
      return SizedBox(width: width, child: button);
    }
    return isFullWidth
        ? SizedBox(width: double.infinity, child: button)
        : button;
  }
  Widget _buildContent(
    Color textColor,
    Color iconColor,
    Color loadingColor,
    double iconSize,
    TextStyle baseTextStyle,
  ) {
    if (isLoading) {
      return SizedBox(
        width: size == SLButtonSize.tiny || size == SLButtonSize.small
            ? AppDimens.iconS
            : AppDimens.iconM,
        height: size == SLButtonSize.tiny || size == SLButtonSize.small
            ? AppDimens.iconS
            : AppDimens.iconM,
        child: CircularProgressIndicator(
          strokeWidth: size == SLButtonSize.tiny || size == SLButtonSize.small
              ? AppDimens.lineProgressHeight / 2
              : AppDimens.lineProgressHeight * 0.625,
          valueColor: AlwaysStoppedAnimation<Color>(loadingColor),
        ),
      );
    }
    final List<Widget> children = [];
    if (prefixWidget != null) {
      children.add(prefixWidget!);
      children.add(
        SizedBox(
          width: size == SLButtonSize.tiny
              ? AppDimens.spaceXS
              : AppDimens.spaceS,
        ),
      );
    } else if (prefixIcon != null) {
      children.add(Icon(prefixIcon, size: iconSize, color: iconColor));
      children.add(
        SizedBox(
          width: size == SLButtonSize.tiny
              ? AppDimens.spaceXS
              : AppDimens.spaceS,
        ),
      );
    }
    children.add(Text(text, style: baseTextStyle.copyWith(color: textColor)));
    if (suffixWidget != null) {
      children.add(
        SizedBox(
          width: size == SLButtonSize.tiny
              ? AppDimens.spaceXS
              : AppDimens.spaceS,
        ),
      );
      children.add(suffixWidget!);
    } else if (suffixIcon != null) {
      children.add(
        SizedBox(
          width: size == SLButtonSize.tiny
              ? AppDimens.spaceXS
              : AppDimens.spaceS,
        ),
      );
      children.add(Icon(suffixIcon, size: iconSize, color: iconColor));
    }
    return Row(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment: MainAxisAlignment.center,
      children: children,
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/daily_task_checker_service.dart
class DailyTaskChecker {
  final ProgressRepository _progressRepository;
  final StorageService _storageService;
  final EventBus _eventBus;
  final ReminderService _reminderService;
  final FlutterLocalNotificationsPlugin _notificationsPlugin;
  static const int dailyCheckAlarmId = 1000;
  static const String lastCheckTimeKey = 'last_daily_task_check_time';
  static const String lastCheckResultKey = 'last_daily_task_check_result';
  static const String lastCheckTaskCountKey =
      'last_daily_task_check_task_count';
  static const String lastCheckErrorKey = 'last_daily_task_check_error';
  DailyTaskChecker({
    required ProgressRepository progressRepository,
    required StorageService storageService,
    required EventBus eventBus,
    required ReminderService reminderService,
    required FlutterLocalNotificationsPlugin notificationsPlugin,
  }) : _progressRepository = progressRepository,
       _storageService = storageService,
       _eventBus = eventBus,
       _reminderService = reminderService,
       _notificationsPlugin = notificationsPlugin;
  Future<bool> initialize() async {
    if (kIsWeb) {
      debugPrint('Daily task checker không được hỗ trợ trên web');
      return false;
    }
    try {
      final initResult = await AndroidAlarmManager.initialize();
      if (!initResult) {
        debugPrint('Không thể khởi tạo AndroidAlarmManager');
        return false;
      }
      final scheduledTime = _getNextScheduleTime();
      final scheduleResult = await AndroidAlarmManager.periodic(
        const Duration(days: 1),
        dailyCheckAlarmId,
        _dailyTaskCheckCallback,
        startAt: scheduledTime,
        exact: true,
        wakeup: true,
        rescheduleOnReboot: true,
      );
      debugPrint(
        'Đã lên lịch kiểm tra task hàng ngày vào ${scheduledTime.toString()}: $scheduleResult',
      );
      return scheduleResult;
    } catch (e) {
      debugPrint('Lỗi khi khởi tạo daily task checker: $e');
      return false;
    }
  }
  @pragma('vm:entry-point')
  static Future<void> _dailyTaskCheckCallback() async {
    try {
      debugPrint('Đang thực hiện kiểm tra task hàng ngày...');
      final prefs = await SharedPreferences.getInstance();
      final userData = prefs.getString('user_data');
      if (userData != null) {
        final _ = Map<String, dynamic>.from(
          const JsonDecoder().convert(userData) as Map,
        );
      }
      final now = DateTime.now();
      await prefs.setString(lastCheckTimeKey, now.toIso8601String());
      await prefs.setBool(lastCheckResultKey, false);
      const hasDueTasks = true;
      const taskCount = 2;
      await prefs.setBool(lastCheckResultKey, true);
      await prefs.setInt(lastCheckTaskCountKey, taskCount);
      await _showResultNotification(hasDueTasks, taskCount);
      debugPrint(
        'Kiểm tra task hàng ngày hoàn tất: có $taskCount nhiệm vụ đến hạn',
      );
    } catch (e) {
      debugPrint('Lỗi trong _dailyTaskCheckCallback: $e');
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(lastCheckErrorKey, e.toString());
    }
  }
  Future<DailyTaskCheckEvent> checkDueTasks() async {
    final now = DateTime.now();
    try {
      final userData = await _storageService.getUserData();
      final userId = userData?['id'];
      if (userId == null) {
        debugPrint('Không thể kiểm tra task: Chưa đăng nhập');
        return DailyTaskCheckEvent(
          checkTime: now,
          hasDueTasks: false,
          taskCount: 0,
          userId: 'unknown',
          isSuccess: false,
          errorMessage: 'User not logged in',
        );
      }
      final progress = await _progressRepository.getDueProgress(
        userId.toString(),
        studyDate: now,
      );
      final hasTasks = progress.isNotEmpty;
      final taskCount = progress.length;
      debugPrint(
        'Kiểm tra task: ${hasTasks ? "Có $taskCount task" : "Không có task"}',
      );
      await _saveCheckResults(now, true, taskCount);
      if (hasTasks) {
        await _reminderService.scheduleAllReminders();
      }
      final event = DailyTaskCheckEvent(
        checkTime: now,
        hasDueTasks: hasTasks,
        taskCount: taskCount,
        userId: userId.toString(),
        isSuccess: true,
      );
      _eventBus.fire(event);
      return event;
    } catch (e) {
      debugPrint('Lỗi khi kiểm tra task đến hạn: $e');
      await _saveErrorResult(now, e.toString());
      final event = DailyTaskCheckEvent(
        checkTime: now,
        hasDueTasks: false,
        taskCount: 0,
        userId: 'unknown',
        isSuccess: false,
        errorMessage: e.toString(),
      );
      _eventBus.fire(event);
      return event;
    }
  }
  Future<void> _saveCheckResults(
    DateTime checkTime,
    bool success,
    int taskCount,
  ) async {
    await _storageService.setString(
      lastCheckTimeKey,
      checkTime.toIso8601String(),
    );
    await _storageService.setBool(lastCheckResultKey, success);
    await _storageService.setInt(lastCheckTaskCountKey, taskCount);
  }
  Future<void> _saveErrorResult(DateTime checkTime, String errorMessage) async {
    await _storageService.setString(
      lastCheckTimeKey,
      checkTime.toIso8601String(),
    );
    await _storageService.setBool(lastCheckResultKey, false);
    await _storageService.setInt(lastCheckTaskCountKey, 0);
    await _storageService.setString(lastCheckErrorKey, errorMessage);
  }
  Future<DailyTaskCheckEvent> manualCheck() async {
    final event = await checkDueTasks();
    await _showResultNotificationInstance(event.hasDueTasks, event.taskCount);
    return event;
  }
  static Future<void> _showResultNotification(
    bool hasDueTasks,
    int taskCount,
  ) async {
    try {
      final flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();
      const androidSettings = AndroidInitializationSettings('ic_launcher');
      const iosSettings = DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );
      const initSettings = InitializationSettings(
        android: androidSettings,
        iOS: iosSettings,
      );
      await flutterLocalNotificationsPlugin.initialize(initSettings);
      const androidDetails = AndroidNotificationDetails(
        'daily_task_check_channel',
        'Daily Task Check',
        channelDescription: 'Notifications about daily task checks',
        importance: Importance.high,
        priority: Priority.high,
      );
      const iosDetails = DarwinNotificationDetails();
      const notificationDetails = NotificationDetails(
        android: androidDetails,
        iOS: iosDetails,
      );
      if (hasDueTasks) {
        await flutterLocalNotificationsPlugin.show(
          9000,
          'Có nhiệm vụ học tập hôm nay',
          'Bạn có $taskCount nhiệm vụ cần hoàn thành hôm nay.',
          notificationDetails,
        );
      } else {
        await flutterLocalNotificationsPlugin.show(
          9000,
          'Không có nhiệm vụ học tập hôm nay',
          'Bạn không có nhiệm vụ nào cần hoàn thành hôm nay.',
          notificationDetails,
        );
      }
    } catch (e) {
      debugPrint('Lỗi khi hiển thị thông báo kết quả: $e');
    }
  }
  Future<void> _showResultNotificationInstance(
    bool hasDueTasks,
    int taskCount,
  ) async {
    try {
      const androidDetails = AndroidNotificationDetails(
        'daily_task_check_channel',
        'Daily Task Check',
        channelDescription: 'Notifications about daily task checks',
        importance: Importance.high,
        priority: Priority.high,
      );
      const iosDetails = DarwinNotificationDetails();
      const notificationDetails = NotificationDetails(
        android: androidDetails,
        iOS: iosDetails,
      );
      if (hasDueTasks) {
        await _notificationsPlugin.show(
          9000,
          'Có nhiệm vụ học tập hôm nay',
          'Bạn có $taskCount nhiệm vụ cần hoàn thành hôm nay.',
          notificationDetails,
        );
      } else {
        await _notificationsPlugin.show(
          9000,
          'Không có nhiệm vụ học tập hôm nay',
          'Bạn không có nhiệm vụ nào cần hoàn thành hôm nay.',
          notificationDetails,
        );
      }
    } catch (e) {
      debugPrint('Lỗi khi hiển thị thông báo kết quả: $e');
    }
  }
  Future<Map<String, dynamic>> getLastCheckReport() async {
    try {
      final lastCheckTime = await _storageService.getString(lastCheckTimeKey);
      final lastCheckResult =
          await _storageService.getBool(lastCheckResultKey) ?? false;
      final lastCheckTaskCount =
          await _storageService.getInt(lastCheckTaskCountKey) ?? 0;
      final lastCheckError = await _storageService.getString(lastCheckErrorKey);
      return {
        'lastCheckTime': lastCheckTime != null
            ? DateTime.parse(lastCheckTime)
            : null,
        'lastCheckResult': lastCheckResult,
        'lastCheckTaskCount': lastCheckTaskCount,
        'lastCheckError': lastCheckError,
      };
    } catch (e) {
      debugPrint('Lỗi khi lấy báo cáo kiểm tra gần nhất: $e');
      return {
        'lastCheckTime': null,
        'lastCheckResult': false,
        'lastCheckTaskCount': 0,
        'lastCheckError': e.toString(),
      };
    }
  }
  DateTime _getNextScheduleTime() {
    final now = DateTime.now();
    DateTime scheduledTime = DateTime(
      now.year,
      now.month,
      now.day,
      0, // 00 hour
      5, // 05 minute
    );
    if (scheduledTime.isBefore(now)) {
      scheduledTime = scheduledTime.add(const Duration(days: 1));
    }
    return scheduledTime;
  }
  Future<bool> cancelDailyCheck() async {
    try {
      final result = await AndroidAlarmManager.cancel(dailyCheckAlarmId);
      debugPrint('Hủy lịch kiểm tra task hàng ngày: $result');
      return result;
    } catch (e) {
      debugPrint('Lỗi khi hủy lịch kiểm tra task hàng ngày: $e');
      return false;
    }
  }
}
@riverpod
class DailyTaskCheck extends _$DailyTaskCheck {
  @override
  Future<DailyTaskCheckEvent?> build() async {
    return null;
  }
  Future<void> checkTasks() async {
    state = const AsyncValue.loading();
    final dailyTaskChecker = await ref.read(dailyTaskCheckerProvider.future);
    state = await AsyncValue.guard(() => dailyTaskChecker.checkDueTasks());
  }
  Future<void> manualCheck() async {
    state = const AsyncValue.loading();
    final dailyTaskChecker = await ref.read(dailyTaskCheckerProvider.future);
    state = await AsyncValue.guard(() => dailyTaskChecker.manualCheck());
  }
  Future<Map<String, dynamic>> getLastReport() async {
    final dailyTaskChecker = await ref.read(dailyTaskCheckerProvider.future);
    return dailyTaskChecker.getLastCheckReport();
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/due_tasks_section.dart
class DueTasksSection extends ConsumerWidget {
  final List<ProgressDetail> tasks;
  final VoidCallback onViewAllTasks;
  const DueTasksSection({
    super.key,
    required this.tasks,
    required this.onViewAllTasks,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    debugPrint('[DueTasksSection] Received ${tasks.length} tasks from parent');
    final dueTasks = _getDueAndOverdueTasks(tasks);
    debugPrint(
      '[DueTasksSection] After filtering: ${dueTasks.length} due tasks',
    );
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    for (final task in tasks.take(3)) {
      final dueDate = task.nextStudyDate != null
          ? DateTime(
              task.nextStudyDate!.year,
              task.nextStudyDate!.month,
              task.nextStudyDate!.day,
            )
          : null;
      final isDue = dueDate != null && !dueDate.isAfter(today);
      debugPrint(
        '[DueTasksSection] Task ${task.id.substring(0, 8)}: dueDate=${dueDate?.toString() ?? 'null'}, isDue=$isDue',
      );
    }
    dueTasks.sort((a, b) {
      if (a.nextStudyDate != null && b.nextStudyDate != null) {
        return a.nextStudyDate!.compareTo(b.nextStudyDate!);
      }
      if (a.nextStudyDate != null) return -1;
      if (b.nextStudyDate != null) return 1;
      return 0;
    });
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Due Today',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            if (dueTasks.isNotEmpty)
              TextButton.icon(
                onPressed: onViewAllTasks,
                icon: const Icon(Icons.chevron_right),
                label: const Text('View All'),
              ),
          ],
        ),
        const SizedBox(height: AppDimens.spaceM),
        _buildContent(dueTasks, context, colorScheme, theme),
      ],
    );
  }
  Widget _buildContent(
    List<ProgressDetail> dueTasks,
    BuildContext context,
    ColorScheme colorScheme,
    ThemeData theme,
  ) {
    if (dueTasks.isEmpty) {
      return SLEmptyState(
        icon: Icons.check_circle_outline,
        title: 'No tasks due today',
        message: 'You\'re all caught up! Take a break or explore new modules.',
        buttonText: 'View All Tasks',
        onButtonPressed: onViewAllTasks,
      );
    }
    final overdueCount = _getOverdueTasksCount(dueTasks);
    final todayCount = dueTasks.length - overdueCount;
    return SLCard(
      padding: EdgeInsets.zero,
      elevation: AppDimens.elevationXS,
      backgroundColor: colorScheme.surface,
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: AppDimens.paddingL,
              vertical: AppDimens.paddingM,
            ),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(AppDimens.paddingXS),
                  decoration: BoxDecoration(
                    color: overdueCount > 0
                        ? colorScheme.errorContainer
                        : colorScheme.primaryContainer,
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    overdueCount > 0
                        ? Icons.warning_amber
                        : Icons.calendar_today,
                    size: AppDimens.iconS,
                    color: overdueCount > 0
                        ? colorScheme.error
                        : colorScheme.primary,
                  ),
                ),
                const SizedBox(width: AppDimens.spaceS),
                Expanded(
                  child: Text(
                    overdueCount > 0
                        ? 'You have $overdueCount overdue and $todayCount due today'
                        : 'You have ${dueTasks.length} task(s) due today',
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: overdueCount > 0 ? colorScheme.error : null,
                    ),
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1),
          ...dueTasks
              .take(3)
              .map(
                (progress) => Column(
                  children: [
                    InkWell(
                      onTap: () => _navigateToProgressDetail(context, progress),
                      child: Padding(
                        padding: const EdgeInsets.symmetric(
                          horizontal: AppDimens.paddingL,
                          vertical: AppDimens.paddingM,
                        ),
                        child: _buildProgressItem(
                          progress,
                          theme,
                          colorScheme,
                          isOverdue: _isOverdue(progress),
                        ),
                      ),
                    ),
                    if (progress != dueTasks.take(3).last)
                      const Divider(height: 1, indent: 16, endIndent: 16),
                  ],
                ),
              ),
          if (dueTasks.length > 3) ...[
            const Divider(height: 1),
            InkWell(
              onTap: onViewAllTasks,
              child: Padding(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimens.paddingL,
                  vertical: AppDimens.paddingM,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      'View All (${dueTasks.length} Tasks)',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: colorScheme.primary,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(width: AppDimens.spaceXS),
                    Icon(
                      Icons.arrow_forward,
                      size: AppDimens.iconS,
                      color: colorScheme.primary,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }
  Widget _buildProgressItem(
    ProgressDetail progress,
    ThemeData theme,
    ColorScheme colorScheme, {
    bool isOverdue = false,
  }) {
    final itemColor = isOverdue ? colorScheme.error : colorScheme.primary;
    return Row(
      children: [
        _buildProgressIndicator(progress, colorScheme, isOverdue: isOverdue),
        const SizedBox(width: AppDimens.spaceM),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                progress.moduleTitle ?? 'Module ${progress.moduleId}',
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: isOverdue ? colorScheme.error : null,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: AppDimens.spaceXXS),
              if (progress.nextStudyDate != null)
                Text(
                  isOverdue
                      ? 'Overdue: ${_formatDate(progress.nextStudyDate!)}'
                      : 'Due: ${_formatDate(progress.nextStudyDate!)}',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: isOverdue
                        ? colorScheme.error
                        : colorScheme.onSurfaceVariant,
                    fontWeight: isOverdue ? FontWeight.bold : null,
                  ),
                ),
              const SizedBox(height: AppDimens.spaceXXS),
              Text(
                '${progress.percentComplete.toInt()}% complete',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ),
        Icon(Icons.chevron_right, color: itemColor, size: AppDimens.iconM),
      ],
    );
  }
  Widget _buildProgressIndicator(
    ProgressDetail progress,
    ColorScheme colorScheme, {
    bool isOverdue = false,
  }) {
    final progressPercent = progress.percentComplete / 100;
    Color color;
    if (isOverdue) {
      color = colorScheme.error;
    } else {
      color = _getProgressColor(progressPercent, colorScheme);
    }
    return SizedBox(
      width: AppDimens.iconL,
      height: AppDimens.iconL,
      child: Stack(
        children: [
          CircularProgressIndicator(
            value: progressPercent,
            backgroundColor: colorScheme.surfaceContainerHighest,
            valueColor: AlwaysStoppedAnimation<Color>(color),
            strokeWidth: 3.0,
          ),
          Center(
            child: Icon(
              isOverdue ? Icons.warning_amber : Icons.notifications_active,
              size: AppDimens.iconS,
              color: color,
            ),
          ),
        ],
      ),
    );
  }
  Color _getProgressColor(double percent, ColorScheme colorScheme) {
    if (percent >= 0.9) return colorScheme.tertiary;
    if (percent >= 0.6) return colorScheme.primary;
    if (percent >= 0.3) return colorScheme.secondary;
    return colorScheme.error;
  }
  void _navigateToProgressDetail(
    BuildContext context,
    ProgressDetail progress,
  ) {
    context.push('/progress/${progress.id}');
  }
  List<ProgressDetail> _getDueAndOverdueTasks(List<ProgressDetail> allTasks) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    return allTasks.where((task) {
      if (task.nextStudyDate == null) return false;
      final dueDate = DateTime(
        task.nextStudyDate!.year,
        task.nextStudyDate!.month,
        task.nextStudyDate!.day,
      );
      return !dueDate.isAfter(today);
    }).toList();
  }
  bool _isOverdue(ProgressDetail task) {
    if (task.nextStudyDate == null) return false;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final dueDate = DateTime(
      task.nextStudyDate!.year,
      task.nextStudyDate!.month,
      task.nextStudyDate!.day,
    );
    return dueDate.isBefore(today);
  }
  int _getOverdueTasksCount(List<ProgressDetail> tasks) {
    return tasks.where(_isOverdue).length;
  }
  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = DateTime(now.year, now.month, now.day - 1);
    final dueDate = DateTime(date.year, date.month, date.day);
    if (dueDate.isAtSameMomentAs(today)) {
      return 'Today';
    } else if (dueDate.isAtSameMomentAs(yesterday)) {
      return 'Yesterday';
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/score_input_dialog.dart
class ScoreInputDialog {
  static Future<double?> show(BuildContext context) async {
    final scoreNotifier = ValueNotifier<double>(80.0);
    final confirmed = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (dialogContext) => ProviderScope(
        child: AlertDialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 16,
          ),
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          titlePadding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusL),
          ),
          title: const Text('Enter Test Score'),
          content: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 320, maxWidth: 440),
            child: ScoreInputDialogContent(scoreNotifier: scoreNotifier),
          ),
          actionsPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(dialogContext, false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.pop(dialogContext, true),
              child: const Text('Confirm'),
            ),
          ],
        ),
      ),
    );
    final finalScore = confirmed == true ? scoreNotifier.value : null;
    scoreNotifier.dispose();
    return finalScore;
  }
}
class ScoreInputDialogContent extends ConsumerStatefulWidget {
  final ValueNotifier<double> scoreNotifier;
  const ScoreInputDialogContent({super.key, required this.scoreNotifier});
  @override
  ConsumerState<ScoreInputDialogContent> createState() =>
      _ScoreInputDialogContentState();
}
class _ScoreInputDialogContentState
    extends ConsumerState<ScoreInputDialogContent>
    with SingleTickerProviderStateMixin {
  late double _currentScore;
  late TextEditingController _controller;
  late AnimationController _animationController;
  late Animation<double> _animation;
  @override
  void initState() {
    super.initState();
    _currentScore = widget.scoreNotifier.value.clamp(0.0, 100.0);
    _controller = TextEditingController(text: _currentScore.toInt().toString());
    _controller.addListener(_onTextChanged);
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: AppDimens.durationM),
    );
    _animation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOut,
    );
    _animationController.forward();
  }
  @override
  void dispose() {
    _controller.removeListener(_onTextChanged);
    _controller.dispose();
    _animationController.dispose();
    super.dispose();
  }
  void _onTextChanged() {
    final value = double.tryParse(_controller.text);
    if (value != null && value != _currentScore) {
      _updateScore(value);
    }
  }
  void _updateScore(double newScore) {
    final clampedScore = newScore.clamp(0.0, 100.0);
    if (_currentScore != clampedScore) {
      setState(() {
        _currentScore = clampedScore;
        widget.scoreNotifier.value = _currentScore;
        final scoreText = clampedScore.toInt().toString();
        if (_controller.text != scoreText) {
          final selection = _controller.selection;
          _controller.text = scoreText;
          if (selection.isValid) {
            try {
              final newOffset = selection.baseOffset.clamp(0, scoreText.length);
              _controller.selection = TextSelection.collapsed(
                offset: newOffset,
              );
            } catch (_) {
              _controller.selection = TextSelection.collapsed(
                offset: scoreText.length,
              );
            }
          }
        }
      });
    }
  }
  Color _getContrastTextColor(Color bg) =>
      bg.computeLuminance() > 0.5 ? Colors.black : Colors.white;
  Color _getScoreColor(ColorScheme scheme, double score) {
    if (score >= 90) return Colors.green.shade700;
    if (score >= 75) return scheme.primary;
    if (score >= 60) return scheme.secondary;
    if (score >= 40) return Colors.orange.shade700;
    return scheme.error;
  }
  Widget _buildSlider(ColorScheme colorScheme) {
    final sliderColor = _getScoreColor(colorScheme, _currentScore);
    return SliderTheme(
      data: SliderThemeData(
        activeTrackColor: sliderColor,
        thumbColor: sliderColor,
        overlayColor: sliderColor.withValues(alpha: AppDimens.opacityMedium),
        trackHeight: 8,
        thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 12),
        overlayShape: const RoundSliderOverlayShape(overlayRadius: 24),
        inactiveTrackColor: colorScheme.surfaceContainerHighest,
      ),
      child: Slider(
        value: _currentScore,
        min: 0,
        max: 100,
        divisions: 100,
        label: '${_currentScore.toInt()}%',
        onChanged: _updateScore,
      ),
    );
  }
  Widget _buildScoreDisplay(TextStyle? style, Color color) {
    final textColor = _getContrastTextColor(color);
    return Container(
      height: AppDimens.iconXXL * 2,
      decoration: BoxDecoration(
        color: color.withValues(alpha: AppDimens.opacitySemi),
        borderRadius: BorderRadius.circular(AppDimens.radiusL),
        border: Border.all(
          color: color.withValues(alpha: AppDimens.opacityHigh),
          width: 1.5,
        ),
      ),
      child: Center(
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              '${_currentScore.toInt()}',
              style: style?.copyWith(color: textColor, fontSize: 48),
            ),
            Text('%', style: style?.copyWith(color: textColor, fontSize: 36)),
          ],
        ),
      ),
    );
  }
  Widget _buildExactScore(ThemeData theme, ColorScheme scheme) {
    final scoreColor = _getScoreColor(scheme, _currentScore);
    final bgColor = scoreColor.withValues(
      alpha: scoreColor.computeLuminance() > 0.5 ? 0.2 : 0.1,
    );
    return Padding(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingS,
        vertical: AppDimens.paddingM,
      ),
      child: Row(
        children: [
          Text(
            'Exact score: ',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: scheme.onSurface,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(width: AppDimens.spaceS),
          Expanded(
            child: Container(
              padding: const EdgeInsets.symmetric(
                horizontal: AppDimens.paddingS,
              ),
              decoration: BoxDecoration(
                color: bgColor,
                borderRadius: BorderRadius.circular(AppDimens.radiusM),
                border: Border.all(color: scoreColor, width: 2),
              ),
              child: IntrinsicWidth(
                child: TextField(
                  controller: _controller,
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: false,
                  ),
                  textAlign: TextAlign.center,
                  maxLength: 3,
                  decoration: InputDecoration(
                    filled: true,
                    fillColor: Colors.transparent,
                    suffixText: '%',
                    counterText: '',
                    border: InputBorder.none,
                    suffixStyle: TextStyle(
                      color: scoreColor,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  style: TextStyle(
                    color: scoreColor,
                    fontWeight: FontWeight.bold,
                    fontSize: 18,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildQuickOptions(ColorScheme scheme, TextTheme textTheme) {
    final options = [0, 25, 50, 75, 100];
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: options.map((score) {
        final selected = _currentScore.round() == score;
        return _ScoreButton(
          score: score,
          isSelected: selected,
          onTap: () => _updateScore(score.toDouble()),
          colorScheme: scheme,
          textTheme: textTheme,
        );
      }).toList(),
    );
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final scheme = theme.colorScheme;
    final scoreColor = theme.getScoreColor(_currentScore);
    return FadeTransition(
      opacity: _animation,
      child: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _buildHeader(theme, scheme),
            const SizedBox(height: AppDimens.spaceL),
            _buildScoreDisplay(
              theme.textTheme.displaySmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
              scoreColor,
            ),
            const SizedBox(height: AppDimens.spaceS),
            _buildSlider(scheme),
            _buildExactScore(theme, scheme),
            const SizedBox(height: AppDimens.spaceL),
            _buildQuickOptions(scheme, theme.textTheme),
          ],
        ),
      ),
    );
  }
  Widget _buildHeader(ThemeData theme, ColorScheme scheme) {
    return Container(
      padding: const EdgeInsets.all(AppDimens.paddingM),
      decoration: BoxDecoration(
        color: scheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
      ),
      child: Row(
        children: [
          Icon(Icons.info_outline, color: scheme.primary),
          const SizedBox(width: AppDimens.spaceM),
          Expanded(
            child: Text(
              'Enter the score from your test on Quizlet or another tool:',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: scheme.onSurface,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ],
      ),
    );
  }
}
class _ScoreButton extends StatelessWidget {
  final int score;
  final bool isSelected;
  final VoidCallback onTap;
  final ColorScheme colorScheme;
  final TextTheme textTheme;
  const _ScoreButton({
    required this.score,
    required this.isSelected,
    required this.onTap,
    required this.colorScheme,
    required this.textTheme,
  });
  Color get _color {
    if (score >= 90) return Colors.green.shade700;
    if (score >= 75) return colorScheme.primary;
    if (score >= 60) return colorScheme.secondary;
    if (score >= 40) return Colors.orange.shade700;
    return colorScheme.error;
  }
  Color _getContrastTextColor(Color color) =>
      color.computeLuminance() > 0.5 ? Colors.black : Colors.white;
  @override
  Widget build(BuildContext context) {
    final bgColor = isSelected ? _color : colorScheme.surfaceContainerHighest;
    final fgColor = _getContrastTextColor(bgColor);
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
        child: Container(
          width: AppDimens.iconXL + AppDimens.spaceS,
          height: AppDimens.iconXL + AppDimens.spaceS,
          decoration: BoxDecoration(
            color: bgColor,
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
            border: isSelected ? null : Border.all(color: _color, width: 2),
            boxShadow: isSelected
                ? [
                    BoxShadow(
                      color: _color.withValues(alpha: AppDimens.opacityHigh),
                      blurRadius: 4,
                      offset: const Offset(0, 2),
                    ),
                  ]
                : null,
          ),
          child: Center(
            child: Text(
              '$score%',
              style: textTheme.labelLarge?.copyWith(
                color: fgColor,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.w600,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/repetition_card.dart
class RepetitionCard extends StatefulWidget {
  final Repetition repetition;
  final bool isHistory;
  final VoidCallback? onMarkCompleted;
  final Function(DateTime)? onReschedule;
  const RepetitionCard({
    super.key,
    required this.repetition,
    this.isHistory = false,
    this.onMarkCompleted,
    this.onReschedule,
  });
  @override
  State<RepetitionCard> createState() => _RepetitionCardState();
}
class _RepetitionCardState extends State<RepetitionCard>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  bool _isHovering = false;
  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: AppDimens.durationS),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 1.02,
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeOutCubic));
  }
  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
  void _onHoverChanged(bool isHovering) {
    setState(() {
      _isHovering = isHovering;
    });
    if (isHovering) {
      _controller.forward();
    } else {
      _controller.reverse();
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final isCompleted = widget.repetition.status == RepetitionStatus.completed;
    final isPending = widget.repetition.status == RepetitionStatus.notStarted;
    final isOverdue =
        isPending &&
        widget.repetition.reviewDate != null &&
        widget.repetition.reviewDate!.isBefore(DateTime.now());
    Color cardColor = colorScheme.surfaceContainerLowest;
    Color borderColor = colorScheme.outlineVariant;
    Color textColor = colorScheme.onSurface;
    Color iconColor = colorScheme.primary;
    if (isOverdue) {
      cardColor = colorScheme.errorContainer.withValues(alpha: 0.08);
      borderColor = colorScheme.error.withValues(alpha: 0.6);
      textColor = colorScheme.error;
      iconColor = colorScheme.error;
    } else if (isCompleted) {
      cardColor = colorScheme.surfaceContainerLow;
      borderColor = colorScheme.success.withValues(alpha: 0.4);
      iconColor = colorScheme.success;
    }
    String statusText = 'Pending';
    IconData statusIcon = Icons.pending;
    if (isCompleted) {
      statusText = 'Completed';
      statusIcon = Icons.check_circle;
    } else if (isOverdue) {
      statusText = 'Overdue';
      statusIcon = Icons.warning_amber_rounded;
    }
    final repetitionColor = theme.getRepetitionColor(
      widget.repetition.repetitionOrder.index,
      isHistory: widget.isHistory,
    );
    final reviewDateText = widget.repetition.reviewDate != null
        ? DateFormat('MMM dd, yyyy').format(widget.repetition.reviewDate!)
        : 'Not scheduled';
    return Padding(
      padding: const EdgeInsets.only(bottom: AppDimens.spaceS),
      child: MouseRegion(
        onEnter: (_) => _onHoverChanged(true),
        onExit: (_) => _onHoverChanged(false),
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.scale(scale: _scaleAnimation.value, child: child);
          },
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            decoration: BoxDecoration(
              color: cardColor,
              borderRadius: BorderRadius.circular(AppDimens.radiusM),
              border: Border.all(
                color: _isHovering && !widget.isHistory
                    ? borderColor
                    : borderColor.withValues(alpha: 0.8),
                width: _isHovering && !widget.isHistory ? 2.0 : 1.0,
              ),
              boxShadow: _isHovering && !widget.isHistory
                  ? [
                      BoxShadow(
                        color: colorScheme.shadow.withValues(
                          alpha: AppDimens.opacityLight,
                        ),
                        blurRadius: 8,
                        offset: const Offset(0, 3),
                      ),
                    ]
                  : null,
            ),
            child: Material(
              type: MaterialType.transparency,
              clipBehavior: Clip.antiAlias,
              borderRadius: BorderRadius.circular(AppDimens.radiusM),
              child: InkWell(
                onTap:
                    isPending &&
                        !widget.isHistory &&
                        widget.onMarkCompleted != null
                    ? widget.onMarkCompleted
                    : null,
                splashColor: isPending && !widget.isHistory
                    ? repetitionColor.withValues(alpha: AppDimens.opacityLight)
                    : Colors.transparent,
                highlightColor: isPending && !widget.isHistory
                    ? repetitionColor.withValues(alpha: AppDimens.opacityLight)
                    : Colors.transparent,
                borderRadius: BorderRadius.circular(AppDimens.radiusM),
                child: Padding(
                  padding: const EdgeInsets.all(AppDimens.paddingM),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          _buildOrderBadge(theme, repetitionColor),
                          const SizedBox(width: AppDimens.spaceM),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  widget.repetition.formatFullOrder(),
                                  style: theme.textTheme.titleMedium?.copyWith(
                                    fontWeight: FontWeight.bold,
                                    color: textColor,
                                  ),
                                ),
                                const SizedBox(height: AppDimens.spaceXXS),
                                Row(
                                  children: [
                                    Icon(
                                      statusIcon,
                                      size: AppDimens.iconS,
                                      color: iconColor,
                                    ),
                                    const SizedBox(width: AppDimens.spaceXS),
                                    Text(
                                      statusText,
                                      style: theme.textTheme.bodyMedium
                                          ?.copyWith(
                                            color: iconColor,
                                            fontWeight: FontWeight.w600,
                                          ),
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ),
                          if (isPending &&
                              !widget.isHistory &&
                              widget.onMarkCompleted != null)
                            _buildCompleteButton(
                              theme,
                              colorScheme,
                              repetitionColor,
                            ),
                        ],
                      ),
                      const SizedBox(height: AppDimens.spaceM),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          Expanded(
                            child: _buildDateInfo(
                              theme,
                              colorScheme,
                              reviewDateText,
                              isOverdue,
                              iconColor,
                            ),
                          ),
                          if (isPending &&
                              !widget.isHistory &&
                              widget.onReschedule != null)
                            _buildRescheduleButton(theme, colorScheme),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildOrderBadge(ThemeData theme, Color repetitionColor) {
    return Container(
      width: AppDimens.iconXL,
      height: AppDimens.iconXL,
      decoration: BoxDecoration(
        color: repetitionColor.withValues(alpha: 0.1),
        shape: BoxShape.circle,
        border: Border.all(color: repetitionColor, width: 1.5),
      ),
      child: Center(
        child: Text(
          widget.repetition.formatOrder(),
          style: theme.textTheme.titleMedium?.copyWith(
            color: repetitionColor,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
  Widget _buildDateInfo(
    ThemeData theme,
    ColorScheme colorScheme,
    String reviewDateText,
    bool isOverdue,
    Color textColor,
  ) {
    return Row(
      children: [
        Icon(
          Icons.event,
          size: AppDimens.iconS,
          color: textColor.withValues(alpha: 0.8),
        ),
        const SizedBox(width: AppDimens.spaceXS),
        Text(
          'Review: ',
          style: theme.textTheme.bodyMedium?.copyWith(
            color: colorScheme.onSurfaceVariant,
          ),
        ),
        Flexible(
          child: Text(
            reviewDateText,
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: textColor,
            ),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }
  Widget _buildCompleteButton(
    ThemeData theme,
    ColorScheme colorScheme,
    Color repetitionColor,
  ) {
    return Material(
      color: Colors.transparent,
      child: Ink(
        decoration: BoxDecoration(
          color: _isHovering
              ? colorScheme.success.withValues(alpha: 0.1)
              : Colors.transparent,
          shape: BoxShape.circle,
        ),
        child: IconButton(
          icon: Icon(
            Icons.check_circle_outline,
            color: _isHovering ? colorScheme.success : repetitionColor,
            size: AppDimens.iconL - 4,
          ),
          onPressed: widget.onMarkCompleted,
          tooltip: 'Mark as completed',
          splashRadius: 24,
        ),
      ),
    );
  }
  Widget _buildRescheduleButton(ThemeData theme, ColorScheme colorScheme) {
    return OutlinedButton.icon(
      onPressed: widget.repetition.reviewDate != null
          ? () => widget.onReschedule?.call(widget.repetition.reviewDate!)
          : () => widget.onReschedule?.call(DateTime.now()),
      icon: Icon(
        Icons.calendar_today,
        size: AppDimens.iconS,
        color: colorScheme.primary,
      ),
      label: Text(
        'Reschedule',
        style: theme.textTheme.labelMedium?.copyWith(
          color: colorScheme.primary,
          fontWeight: FontWeight.w600,
        ),
      ),
      style: OutlinedButton.styleFrom(
        visualDensity: VisualDensity.compact,
        padding: const EdgeInsets.symmetric(
          horizontal: AppDimens.paddingS,
          vertical: AppDimens.paddingXXS,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimens.radiusM),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/books/book_detail_screen.dart
class BookDetailScreen extends ConsumerStatefulWidget {
  final String bookId;
  const BookDetailScreen({super.key, required this.bookId});
  @override
  ConsumerState<BookDetailScreen> createState() => _BookDetailScreenState();
}
class _BookDetailScreenState extends ConsumerState<BookDetailScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final ScrollController _scrollController = ScrollController();
  bool _isScrolled = false;
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) => _loadData());
  }
  void _onScroll() {
    final isScrolled = _scrollController.offset > 0;
    if (isScrolled != _isScrolled) {
      setState(() {
        _isScrolled = isScrolled;
      });
    }
  }
  @override
  void dispose() {
    _tabController.dispose();
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }
  Future<void> _loadData() async {
    if (!mounted) return;
    await ref
        .read(selectedBookProvider.notifier)
        .loadBookDetails(widget.bookId);
    await ref
        .read(modulesStateProvider.notifier)
        .loadModulesByBookId(widget.bookId);
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final bookState = ref.watch(selectedBookProvider);
    final moduleState = ref.watch(modulesStateProvider);
    final isAdmin = ref.watch(
      authStateProvider.select(
        (value) =>
            value.valueOrNull == true &&
            (ref.read(currentUserProvider)?.roles?.contains('ADMIN') ?? false),
      ),
    );
    return bookState.when(
      data: (book) {
        if (book == null) {
          return Scaffold(
            appBar: AppBar(title: const Text('Book Details')),
            body: const Center(child: Text('Book not found')),
          );
        }
        return Scaffold(
          body: NestedScrollView(
            controller: _scrollController,
            headerSliverBuilder: (context, innerBoxIsScrolled) => [
              _buildFlexibleAppBar(
                theme,
                colorScheme,
                book,
                isAdmin,
                innerBoxIsScrolled,
              ),
            ],
            body: Column(
              children: [
                TabBar(
                  controller: _tabController,
                  labelColor: colorScheme.primary,
                  unselectedLabelColor: colorScheme.onSurfaceVariant,
                  indicatorColor: colorScheme.primary,
                  indicatorWeight: 3,
                  indicatorSize: TabBarIndicatorSize.label,
                  tabs: const [
                    Tab(icon: Icon(Icons.info_outline), text: 'Overview'),
                    Tab(
                      icon: Icon(Icons.view_module_outlined),
                      text: 'Modules',
                    ),
                  ],
                ),
                Expanded(
                  child: TabBarView(
                    controller: _tabController,
                    children: [
                      BookOverviewTab(book: book),
                      moduleState.when(
                        data: (modules) => BookModulesTab(
                          modules: modules,
                          bookId: widget.bookId,
                          onRetry: () => ref
                              .read(modulesStateProvider.notifier)
                              .loadModulesByBookId(widget.bookId),
                        ),
                        loading: () =>
                            const Center(child: SLLoadingIndicator()),
                        error: (error, stack) => Center(
                          child: SLErrorView(
                            message: error.toString(),
                            onRetry: () => ref
                                .read(modulesStateProvider.notifier)
                                .loadModulesByBookId(widget.bookId),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
      loading: () => Scaffold(
        appBar: AppBar(title: const Text('Book Details')),
        body: const Center(child: SLLoadingIndicator()),
      ),
      error: (error, stack) => Scaffold(
        appBar: AppBar(title: const Text('Book Details')),
        body: Center(
          child: SLErrorView(message: error.toString(), onRetry: _loadData),
        ),
      ),
    );
  }
  SliverAppBar _buildFlexibleAppBar(
    ThemeData theme,
    ColorScheme colorScheme,
    BookDetail book,
    bool isAdmin,
    bool innerBoxIsScrolled,
  ) {
    final statusColor = _getStatusColor(book.status);
    final difficultyData = _getDifficultyData(theme, book.difficultyLevel);
    return SliverAppBar(
      expandedHeight: AppDimens.bannerHeight,
      floating: false,
      pinned: true,
      forceElevated: _isScrolled || innerBoxIsScrolled,
      backgroundColor: _isScrolled
          ? theme.appBarTheme.backgroundColor
          : colorScheme.surfaceContainerHigh,
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        onPressed: () {
          final router = GoRouter.of(context);
          if (router.canPop()) {
            router.pop(true); // Trả về true để indicate cần refresh
          } else {
            router.go('/books');
          }
        },
        color: _isScrolled ? null : colorScheme.onSurfaceVariant,
      ),
      flexibleSpace: FlexibleSpaceBar(
        titlePadding: const EdgeInsets.all(0),
        expandedTitleScale: 1.0,
        title: _isScrolled
            ? Padding(
                padding: const EdgeInsets.only(left: 56.0, right: 56.0),
                child: Text(
                  book.name,
                  style: theme.textTheme.titleMedium,
                  overflow: TextOverflow.ellipsis,
                ),
              )
            : const SizedBox.shrink(),
        background: Padding(
          padding: const EdgeInsets.fromLTRB(
            AppDimens.paddingL,
            AppDimens.paddingL + kToolbarHeight,
            AppDimens.paddingL,
            AppDimens.paddingL,
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Hero(
                    tag: 'book-${book.id}',
                    child: BookCover(book: book.toSummary(), theme: theme),
                  ),
                  const SizedBox(width: AppDimens.spaceL),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          book.name,
                          style: theme.textTheme.headlineSmall,
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: AppDimens.spaceS),
                        Row(
                          children: [
                            InfoChipWidget(
                              label: _formatStatus(book.status),
                              backgroundColor: statusColor.withValues(
                                alpha: 0.2,
                              ),
                              textColor: statusColor,
                            ),
                            if (book.difficultyLevel != null) ...[
                              const SizedBox(width: AppDimens.spaceXS),
                              InfoChipWidget(
                                label: difficultyData.text,
                                backgroundColor: difficultyData.color
                                    .withValues(alpha: 0.2),
                                textColor: difficultyData.color,
                              ),
                            ],
                          ],
                        ),
                        if (book.category != null) ...[
                          const SizedBox(height: AppDimens.spaceXS),
                          InfoChipWidget(
                            label: book.category!,
                            backgroundColor: colorScheme.tertiaryContainer,
                            textColor: colorScheme.onTertiaryContainer,
                            icon: Icons.category_outlined,
                          ),
                        ],
                        const SizedBox(height: AppDimens.spaceS),
                        Row(
                          children: [
                            Icon(
                              Icons.bookmark_border,
                              size: AppDimens.iconS,
                              color: colorScheme.onSurfaceVariant,
                            ),
                            const SizedBox(width: AppDimens.spaceXXS),
                            Text(
                              '${book.modules.length} ${book.modules.length == 1 ? 'module' : 'modules'}',
                              style: theme.textTheme.labelMedium?.copyWith(
                                color: colorScheme.onSurfaceVariant,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  Color _getStatusColor(BookStatus status) {
    switch (status) {
      case BookStatus.published:
        return Colors.green;
      case BookStatus.draft:
        return Colors.orange;
      case BookStatus.archived:
        return Colors.grey;
    }
  }
  ({Color color, String text}) _getDifficultyData(
    ThemeData theme,
    DifficultyLevel? level,
  ) {
    if (level == null) return (color: Colors.grey, text: 'Unknown');
    switch (level) {
      case DifficultyLevel.beginner:
        return (color: Colors.green, text: 'Beginner');
      case DifficultyLevel.intermediate:
        return (color: theme.colorScheme.tertiary, text: 'Intermediate');
      case DifficultyLevel.advanced:
        return (color: theme.colorScheme.secondary, text: 'Advanced');
      case DifficultyLevel.expert:
        return (color: theme.colorScheme.error, text: 'Expert');
    }
  }
  String _formatStatus(BookStatus status) {
    switch (status) {
      case BookStatus.published:
        return 'Published';
      case BookStatus.draft:
        return 'Draft';
      case BookStatus.archived:
        return 'Archived';
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/progress_header_widget.dart
extension ProgressDetailExtension on ProgressDetail {
  int get completedRepetitions =>
      repetitions.where((r) => r.status == RepetitionStatus.completed).length;
  int get totalRepetitions => repetitions.length;
  double get clampedPercentComplete => percentComplete.clamp(0, 100);
  bool get isOverdue =>
      nextStudyDate != null && nextStudyDate!.isBefore(DateTime.now());
  String get formattedStartDate => firstLearningDate != null
      ? DateFormat.yMMMd().format(firstLearningDate!)
      : 'Not started';
  String get formattedNextDate => nextStudyDate != null
      ? DateFormat.yMMMd().format(nextStudyDate!)
      : 'Not scheduled';
}
class ProgressHeaderWidget extends ConsumerWidget {
  final ProgressDetail progress;
  final VoidCallback onCycleCompleteDialogRequested;
  const ProgressHeaderWidget({
    super.key,
    required this.progress,
    required this.onCycleCompleteDialogRequested,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Card(
      elevation: 0,
      color: colorScheme.surface,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(28)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildTitleSection(theme),
            const SizedBox(height: 16),
            _buildProgressSection(theme),
            const SizedBox(height: 16),
            _buildCycleInfoSection(context, ref, theme),
            const SizedBox(height: 16),
            _buildDatesSection(theme),
          ],
        ),
      ),
    );
  }
  Widget _buildTitleSection(ThemeData theme) {
    final colorScheme = theme.colorScheme;
    return Row(
      children: [
        CircleAvatar(
          radius: 28,
          backgroundColor: colorScheme.primaryContainer,
          child: Icon(
            Icons.menu_book_rounded,
            size: 28,
            color: colorScheme.onPrimaryContainer,
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: Text(
            progress.moduleTitle ?? 'Learning Module',
            style: theme.textTheme.titleLarge?.copyWith(
              fontWeight: FontWeight.bold,
              color: colorScheme.onSurface,
            ),
            maxLines: 2,
          ),
        ),
      ],
    );
  }
  Widget _buildProgressSection(ThemeData theme) {
    final colorScheme = theme.colorScheme;
    final progressValue = progress.clampedPercentComplete / 100;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Overall Progress',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.w600,
            color: colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: 8),
        ProgressBar(value: progressValue, colorScheme: colorScheme),
        const SizedBox(height: 6),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Progress',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            Card(
              color: colorScheme.primaryContainer,
              margin: EdgeInsets.zero,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                child: Text(
                  '${progress.clampedPercentComplete.toInt()}%',
                  style: theme.textTheme.labelLarge?.copyWith(
                    color: colorScheme.onPrimaryContainer,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }
  Widget _buildCycleInfoSection(
    BuildContext context,
    WidgetRef ref,
    ThemeData theme,
  ) {
    final colorScheme = theme.colorScheme;
    final cycleInfo = ref.watch(getCycleInfoProvider(progress.cyclesStudied));
    final cycleColor = CycleFormatter.getColor(progress.cyclesStudied, context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              decoration: BoxDecoration(
                color: cycleColor.withValues(alpha: 0.2),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(8),
              child: Icon(
                CycleFormatter.getIcon(progress.cyclesStudied),
                color: cycleColor,
                size: 24,
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                'Cycle: ${CycleFormatter.getDisplayName(progress.cyclesStudied)}',
                style: theme.textTheme.titleMedium?.copyWith(
                  color: cycleColor,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            Card(
              elevation: 0,
              color: colorScheme.surfaceContainerHighest,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(24),
                side: BorderSide(color: cycleColor, width: 1.5),
              ),
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                child: Text(
                  '${progress.completedRepetitions} / ${progress.totalRepetitions}',
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: cycleColor,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Card(
          elevation: 0,
          color: colorScheme.surfaceContainerHighest,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          child: Padding(
            padding: const EdgeInsets.all(8),
            child: Row(
              children: [
                Icon(Icons.info_outline, size: 20, color: cycleColor),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    cycleInfo,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
  Widget _buildDatesSection(ThemeData theme) {
    final colorScheme = theme.colorScheme;
    return Card(
      elevation: 0,
      color: colorScheme.surfaceContainerHighest,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: IntrinsicHeight(
          child: Row(
            children: [
              Expanded(
                child: DateInfoBlock(
                  label: 'Start Date',
                  value: progress.formattedStartDate,
                  icon: Icons.calendar_today_outlined,
                  color: colorScheme.primary,
                  theme: theme,
                ),
              ),
              VerticalDivider(
                width: 24,
                thickness: 1,
                color: colorScheme.outlineVariant,
              ),
              Expanded(
                child: DateInfoBlock(
                  label: 'Next Review',
                  value: progress.formattedNextDate,
                  icon: Icons.event_note,
                  color: progress.isOverdue
                      ? colorScheme.error
                      : colorScheme.secondary,
                  isHighlighted: progress.isOverdue,
                  theme: theme,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
class ProgressBar extends StatelessWidget {
  final double value;
  final ColorScheme colorScheme;
  const ProgressBar({
    super.key,
    required this.value,
    required this.colorScheme,
  });
  @override
  Widget build(BuildContext context) {
    return Container(
      height: 12,
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(8),
      ),
      clipBehavior: Clip.antiAlias,
      child: LayoutBuilder(
        builder: (context, constraints) {
          return TweenAnimationBuilder<double>(
            duration: const Duration(milliseconds: 500),
            curve: Curves.easeInOut,
            tween: Tween(begin: 0, end: value),
            builder: (context, animatedValue, child) {
              return Stack(
                children: [
                  Container(
                    width: constraints.maxWidth * animatedValue,
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: [colorScheme.primary, colorScheme.tertiary],
                      ),
                    ),
                  ),
                ],
              );
            },
          );
        },
      ),
    );
  }
}
class DateInfoBlock extends StatelessWidget {
  final String label;
  final String value;
  final IconData icon;
  final Color color;
  final ThemeData theme;
  final bool isHighlighted;
  const DateInfoBlock({
    super.key,
    required this.label,
    required this.value,
    required this.icon,
    required this.color,
    required this.theme,
    this.isHighlighted = false,
  });
  @override
  Widget build(BuildContext context) {
    final colorScheme = theme.colorScheme;
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          decoration: BoxDecoration(
            color: color.withValues(alpha: 0.2),
            shape: BoxShape.circle,
          ),
          padding: const EdgeInsets.all(4),
          child: Icon(icon, size: 16, color: color),
        ),
        const SizedBox(width: 8),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: theme.textTheme.labelMedium?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(height: 2),
              Text(
                value,
                style: theme.textTheme.titleSmall?.copyWith(
                  color: isHighlighted
                      ? colorScheme.error
                      : colorScheme.onSurface,
                  fontWeight: FontWeight.bold,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/alarm_manager_service.dart
@pragma('vm:entry-point')
void noonReminderCallback() {
  _triggerBackgroundCheck(AppConstants.noonReminderCallbackId);
}
@pragma('vm:entry-point')
void eveningFirstReminderCallback() {
  _triggerBackgroundCheck(AppConstants.eveningFirstReminderCallbackId);
}
@pragma('vm:entry-point')
void eveningSecondReminderCallback() {
  _triggerBackgroundCheck(AppConstants.eveningSecondReminderCallbackId);
}
@pragma('vm:entry-point')
void endOfDayReminderCallback() {
  _triggerBackgroundCheck(AppConstants.endOfDayReminderCallbackId);
}
@pragma('vm:entry-point')
Future<void> _triggerBackgroundCheck(int callbackId) async {
  try {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('last_triggered_callback', callbackId);
    await prefs.setInt(
      'last_triggered_time',
      DateTime.now().millisecondsSinceEpoch,
    );
    debugPrint('Alarm callback triggered: $callbackId at ${DateTime.now()}');
  } catch (e) {
    debugPrint(
      'Error in _triggerBackgroundCheck: $e',
    ); // Use print since debugPrint might not work in background
  }
}
class AlarmManagerService {
  final DeviceSpecificService _deviceSpecificService;
  bool _isInitialized = false;
  AlarmManagerService({required DeviceSpecificService deviceSpecificService})
    : _deviceSpecificService = deviceSpecificService;
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    try {
      if (!_deviceSpecificService.isAndroid) {
        debugPrint('Not on Android, using local notifications only');
        _isInitialized = true;
        return true;
      }
      final bool initialized = await AndroidAlarmManager.initialize();
      if (!initialized) {
        debugPrint('Failed to initialize AndroidAlarmManager');
        return false;
      }
      debugPrint('AlarmManager initialized successfully');
      if (_deviceSpecificService.sdkVersion >= 31) {
        final bool permissionGranted = await _requestExactAlarmPermission();
        debugPrint('Exact alarm permission granted: $permissionGranted');
      }
      _isInitialized = true;
      return true;
    } catch (e) {
      debugPrint('Error initializing AlarmManager: $e');
      debugPrint('Falling back to local notifications only');
      return false;
    }
  }
  Future<bool> _requestExactAlarmPermission() async {
    try {
      const methodChannel = MethodChannel('com.yourapp.device/optimization');
      final bool result = await methodChannel.invokeMethod(
        'requestExactAlarmPermission',
      );
      return result;
    } on PlatformException catch (e) {
      debugPrint('Error requesting exact alarm permission: ${e.message}');
      return false;
    } catch (e) {
      debugPrint('Unexpected error requesting exact alarm permission: $e');
      return false;
    }
  }
  Future<bool> scheduleFixedTimeAlarms() async {
    if (!await _ensureInitialized()) {
      return false;
    }
    if (!_deviceSpecificService.isAndroid) {
      debugPrint('Not on Android, cannot schedule alarms');
      return false;
    }
    try {
      final List<bool> results = await Future.wait([
        _scheduleNoonReminder(),
        _scheduleEveningFirstReminder(),
        _scheduleEveningSecondReminder(),
        _scheduleEndOfDayReminder(),
      ]);
      final bool allSuccessful = results.every((result) => result);
      debugPrint(
        'All fixed-time alarms scheduled successfully: $allSuccessful',
      );
      return allSuccessful;
    } catch (e) {
      debugPrint('Error scheduling fixed-time alarms: $e');
      return false;
    }
  }
  Future<bool> _ensureInitialized() async {
    if (_isInitialized) return true;
    final bool initialized = await initialize();
    return initialized;
  }
  Future<bool> _scheduleNoonReminder() async {
    try {
      final alarmTime = _createTime(
        AppConstants.noonReminderHour,
        AppConstants.noonReminderMinute,
      );
      final bool result = await AndroidAlarmManager.periodic(
        const Duration(days: 1),
        AppConstants.noonReminderCallbackId,
        noonReminderCallback,
        startAt: alarmTime,
        exact: true,
        wakeup: true,
        rescheduleOnReboot: true,
      );
      debugPrint('Noon reminder scheduled: $result at $alarmTime');
      return result;
    } catch (e) {
      debugPrint('Error scheduling noon reminder: $e');
      return false;
    }
  }
  Future<bool> _scheduleEveningFirstReminder() async {
    try {
      final alarmTime = _createTime(
        AppConstants.eveningFirstReminderHour,
        AppConstants.eveningFirstReminderMinute,
      );
      final bool result = await AndroidAlarmManager.periodic(
        const Duration(days: 1),
        AppConstants.eveningFirstReminderCallbackId,
        eveningFirstReminderCallback,
        startAt: alarmTime,
        exact: true,
        wakeup: true,
        rescheduleOnReboot: true,
      );
      debugPrint('Evening first reminder scheduled: $result at $alarmTime');
      return result;
    } catch (e) {
      debugPrint('Error scheduling evening first reminder: $e');
      return false;
    }
  }
  Future<bool> _scheduleEveningSecondReminder() async {
    try {
      final alarmTime = _createTime(
        AppConstants.eveningSecondReminderHour,
        AppConstants.eveningSecondReminderMinute,
      );
      final bool result = await AndroidAlarmManager.periodic(
        const Duration(days: 1),
        AppConstants.eveningSecondReminderCallbackId,
        eveningSecondReminderCallback,
        startAt: alarmTime,
        exact: true,
        wakeup: true,
        rescheduleOnReboot: true,
      );
      debugPrint('Evening second reminder scheduled: $result at $alarmTime');
      return result;
    } catch (e) {
      debugPrint('Error scheduling evening second reminder: $e');
      return false;
    }
  }
  Future<bool> _scheduleEndOfDayReminder() async {
    try {
      final alarmTime = _createTime(
        AppConstants.endOfDayReminderHour,
        AppConstants.endOfDayReminderMinute,
      );
      final bool result = await AndroidAlarmManager.periodic(
        const Duration(days: 1),
        AppConstants.endOfDayReminderCallbackId,
        endOfDayReminderCallback,
        startAt: alarmTime,
        exact: true,
        wakeup: true,
        rescheduleOnReboot: true,
      );
      debugPrint('End-of-day reminder scheduled: $result at $alarmTime');
      return result;
    } catch (e) {
      debugPrint('Error scheduling end-of-day reminder: $e');
      return false;
    }
  }
  DateTime _createTime(int hour, int minute) {
    final now = DateTime.now();
    var scheduledTime = DateTime(now.year, now.month, now.day, hour, minute);
    if (scheduledTime.isBefore(now)) {
      scheduledTime = scheduledTime.add(const Duration(days: 1));
    }
    return scheduledTime;
  }
  Future<bool> cancelAlarm(int id) async {
    try {
      if (!_deviceSpecificService.isAndroid) {
        debugPrint('Not on Android, cannot cancel alarm');
        return false;
      }
      final bool result = await AndroidAlarmManager.cancel(id);
      debugPrint('Alarm $id cancelled: $result');
      return result;
    } catch (e) {
      debugPrint('Error cancelling alarm $id: $e');
      return false;
    }
  }
  Future<bool> cancelAllAlarms() async {
    try {
      if (!_deviceSpecificService.isAndroid) {
        debugPrint('Not on Android, cannot cancel alarms');
        return false;
      }
      final List<bool> results = await Future.wait([
        cancelAlarm(AppConstants.noonReminderCallbackId),
        cancelAlarm(AppConstants.eveningFirstReminderCallbackId),
        cancelAlarm(AppConstants.eveningSecondReminderCallbackId),
        cancelAlarm(AppConstants.endOfDayReminderCallbackId),
      ]);
      final bool allSuccessful = results.every((result) => result);
      debugPrint('All alarms cancelled: $allSuccessful');
      return allSuccessful;
    } catch (e) {
      debugPrint('Error cancelling all alarms: $e');
      return false;
    }
  }
  Future<int?> getLastTriggeredAlarmId() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      return prefs.getInt('last_triggered_callback');
    } catch (e) {
      debugPrint('Error getting last triggered alarm ID: $e');
      return null;
    }
  }
  Future<DateTime?> getLastTriggeredTime() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final timestamp = prefs.getInt('last_triggered_time');
      if (timestamp != null) {
        return DateTime.fromMillisecondsSinceEpoch(timestamp);
      }
      return null;
    } catch (e) {
      debugPrint('Error getting last triggered time: $e');
      return null;
    }
  }
  Future<bool> clearLastTriggeredData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('last_triggered_callback');
      await prefs.remove('last_triggered_time');
      return true;
    } catch (e) {
      debugPrint('Error clearing last triggered data: $e');
      return false;
    }
  }
  bool get isInitialized => _isInitialized;
}
@riverpod
class AlarmStatus extends _$AlarmStatus {
  @override
  Future<Map<String, dynamic>> build() async {
    final alarmManager = ref.watch(alarmManagerServiceProvider);
    final Map<String, dynamic> status = {
      'isInitialized': alarmManager.isInitialized,
    };
    if (alarmManager.isInitialized) {
      final lastTriggeredId = await alarmManager.getLastTriggeredAlarmId();
      final lastTriggeredTime = await alarmManager.getLastTriggeredTime();
      status['lastTriggeredId'] = lastTriggeredId;
      status['lastTriggeredTime'] = lastTriggeredTime;
    }
    return status;
  }
  Future<bool> initialize() async {
    final alarmManager = ref.read(alarmManagerServiceProvider);
    final result = await alarmManager.initialize();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
  Future<bool> scheduleFixedTimeAlarms() async {
    final alarmManager = ref.read(alarmManagerServiceProvider);
    final result = await alarmManager.scheduleFixedTimeAlarms();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
  Future<bool> cancelAllAlarms() async {
    final alarmManager = ref.read(alarmManagerServiceProvider);
    final result = await alarmManager.cancelAllAlarms();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
  Future<bool> clearLastTriggeredData() async {
    final alarmManager = ref.read(alarmManagerServiceProvider);
    final result = await alarmManager.clearLastTriggeredData();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/main/module_card.dart
class ModuleCard extends ConsumerWidget {
  final LearningModule module;
  final int index;
  const ModuleCard({super.key, required this.module, required this.index});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final hasNextStudyDate = module.progressNextStudyDate != null;
    final isOverdue =
        hasNextStudyDate &&
        module.progressNextStudyDate!.isBefore(DateTime.now()) &&
        !DateUtils.isSameDay(module.progressNextStudyDate, DateTime.now());
    final isDueToday =
        hasNextStudyDate &&
        DateUtils.isSameDay(module.progressNextStudyDate, DateTime.now());
    final isDueSoon =
        hasNextStudyDate &&
        module.progressNextStudyDate!.isAfter(DateTime.now()) &&
        module.progressNextStudyDate!.difference(DateTime.now()).inDays <= 2;
    final hasCycleInfo = module.progressCyclesStudied != null;
    const double minCardHeight = 120;
    Color statusColor = colorScheme.primary;
    if (isOverdue) {
      statusColor = colorScheme.error;
    } else if (isDueToday) {
      statusColor = colorScheme.tertiary;
    } else if (isDueSoon) {
      statusColor = colorScheme.warning;
    }
    Color? cycleColor;
    String? cycleText;
    if (hasCycleInfo) {
      cycleText = _formatCycleStudied(module.progressCyclesStudied!);
      cycleColor = _getCycleColor(module.progressCyclesStudied!, colorScheme);
    }
    final dateFormatter = DateFormat('MMM dd, yyyy');
    return ConstrainedBox(
      constraints: const BoxConstraints(minHeight: minCardHeight),
      child: Card(
        margin: const EdgeInsets.only(bottom: AppDimens.spaceS),
        elevation: AppDimens.elevationXS,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimens.radiusM),
          side: BorderSide(
            color: colorScheme.outlineVariant.withValues(
              alpha: AppDimens.opacityMedium,
            ),
            width: 1,
          ),
        ),
        child: InkWell(
          onTap: () => _showModuleDetails(context, module),
          borderRadius: BorderRadius.circular(AppDimens.radiusM),
          child: Padding(
            padding: const EdgeInsets.all(AppDimens.paddingL),
            child: IntrinsicHeight(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    flex: 6,
                    child: Container(
                      padding: const EdgeInsets.only(right: AppDimens.paddingS),
                      child: _buildModuleInfo(
                        theme,
                        colorScheme,
                        cycleText,
                        cycleColor,
                      ),
                    ),
                  ),
                  Expanded(
                    flex: 5,
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: AppDimens.paddingXS,
                      ),
                      child: _buildNextStudyInfo(
                        theme,
                        colorScheme,
                        statusColor,
                        dateFormatter,
                        isOverdue,
                        isDueToday,
                        isDueSoon,
                      ),
                    ),
                  ),
                  Expanded(flex: 2, child: _buildTasksInfo(theme, colorScheme)),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildModuleInfo(
    ThemeData theme,
    ColorScheme colorScheme,
    String? cycleText,
    Color? cycleColor,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: double.infinity),
          child: Text(
            module.moduleTitle.isEmpty ? 'Unnamed Module' : module.moduleTitle,
            style: theme.textTheme.titleSmall?.copyWith(
              fontWeight: FontWeight.w600,
              color: colorScheme.onSurface,
            ),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ),
        const SizedBox(height: AppDimens.spaceXS),
        Row(
          children: [
            Icon(
              Icons.menu_book,
              size: AppDimens.iconXS,
              color: colorScheme.onSurfaceVariant,
            ),
            const SizedBox(width: AppDimens.spaceXS),
            Expanded(
              child: Text(
                module.bookName.isEmpty ? 'No book assigned' : module.bookName,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
        if (cycleText != null) ...[
          const SizedBox(height: AppDimens.spaceS),
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppDimens.paddingS,
              vertical: AppDimens.paddingXXS,
            ),
            decoration: BoxDecoration(
              color:
                  cycleColor?.withValues(alpha: AppDimens.opacityLight) ??
                  colorScheme.secondaryContainer,
              borderRadius: BorderRadius.circular(AppDimens.radiusXS),
            ),
            child: Text(
              cycleText,
              style: theme.textTheme.bodySmall?.copyWith(
                color: cycleColor ?? colorScheme.secondary,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ],
      ],
    );
  }
  Widget _buildNextStudyInfo(
    ThemeData theme,
    ColorScheme colorScheme,
    Color statusColor,
    DateFormat dateFormatter,
    bool isOverdue,
    bool isDueToday,
    bool isDueSoon,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (module.progressNextStudyDate == null)
          Text(
            'Not scheduled',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: colorScheme.onSurfaceVariant,
              fontStyle: FontStyle.italic,
            ),
          )
        else
          Row(
            children: [
              Icon(
                isOverdue
                    ? Icons.event_busy
                    : (isDueToday ? Icons.event_available : Icons.event),
                size: AppDimens.iconS,
                color: statusColor,
              ),
              const SizedBox(width: AppDimens.spaceXS),
              Expanded(
                child: Text(
                  dateFormatter.format(module.progressNextStudyDate!),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: statusColor,
                    fontWeight: isOverdue || isDueToday
                        ? FontWeight.bold
                        : null,
                  ),
                ),
              ),
            ],
          ),
        const SizedBox(height: AppDimens.spaceXS),
        if (isOverdue || isDueToday || isDueSoon)
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppDimens.paddingS,
              vertical: AppDimens.paddingXXS,
            ),
            decoration: BoxDecoration(
              color: statusColor.withValues(alpha: AppDimens.opacityLight),
              borderRadius: BorderRadius.circular(AppDimens.radiusXS),
            ),
            child: Text(
              isOverdue ? 'Overdue' : (isDueToday ? 'Due today' : 'Due soon'),
              style: theme.textTheme.bodySmall?.copyWith(
                color: statusColor,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
      ],
    );
  }
  Widget _buildTasksInfo(ThemeData theme, ColorScheme colorScheme) {
    return Center(
      child: Container(
        width: AppDimens.moduleIndicatorSize + AppDimens.paddingS,
        height: AppDimens.moduleIndicatorSize + AppDimens.paddingS,
        decoration: BoxDecoration(
          color: module.progressDueTaskCount > 0
              ? colorScheme.primaryContainer
              : colorScheme.surfaceContainerHigh,
          shape: BoxShape.circle,
        ),
        child: Center(
          child: Text(
            module.progressDueTaskCount.toString(),
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: module.progressDueTaskCount > 0
                  ? colorScheme.onPrimaryContainer
                  : colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      ),
    );
  }
  void _showModuleDetails(BuildContext context, LearningModule module) {
    if (module.moduleId.isEmpty) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('Invalid module ID')));
      return;
    }
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => ModuleDetailsBottomSheet(
        module: module,
        heroTagPrefix: 'learning_list',
      ),
    );
  }
  String _formatCycleStudied(CycleStudied cycle) {
    switch (cycle) {
      case CycleStudied.firstTime:
        return 'First Time';
      case CycleStudied.firstReview:
        return 'First Review';
      case CycleStudied.secondReview:
        return 'Second Review';
      case CycleStudied.thirdReview:
        return 'Third Review';
      case CycleStudied.moreThanThreeReviews:
        return 'Advanced Review';
    }
  }
  Color _getCycleColor(CycleStudied cycle, ColorScheme colorScheme) {
    switch (cycle) {
      case CycleStudied.firstTime:
        return colorScheme.primary;
      case CycleStudied.firstReview:
        return colorScheme.secondary;
      case CycleStudied.secondReview:
        return colorScheme.tertiary;
      case CycleStudied.thirdReview:
        return colorScheme.warning;
      case CycleStudied.moreThanThreeReviews:
        return Colors.deepPurple;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/device_specific_service.dart
class DeviceSpecificService {
  final DeviceInfoPlugin _deviceInfo = DeviceInfoPlugin();
  final DeviceSettingsService _deviceSettingsService;
  bool _isSamsungDevice = false;
  bool _isS23Ultra = false;
  String? _deviceModel;
  String? _manufacturer;
  int _sdkVersion = 0;
  bool _isInitialized = false;
  DeviceSpecificService({DeviceSettingsService? deviceSettingsService})
    : _deviceSettingsService = deviceSettingsService ?? DeviceSettingsService();
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    try {
      if (kIsWeb) {
        _isInitialized = true;
        return true;
      }
      if (_isAndroid) {
        await _initializeAndroidDevice();
        await _applyDeviceSpecificOptimizations();
        _isInitialized = true;
        return true;
      }
      _isInitialized = true;
      return true;
    } catch (e) {
      debugPrint('Error detecting device: $e');
      return false;
    }
  }
  Future<void> _initializeAndroidDevice() async {
    final androidInfo = await _deviceInfo.androidInfo;
    _deviceModel = androidInfo.model;
    _manufacturer = androidInfo.manufacturer;
    _sdkVersion = androidInfo.version.sdkInt;
    _isSamsungDevice = _manufacturer?.toLowerCase() == 'samsung';
    _isS23Ultra =
        _isSamsungDevice &&
        (_deviceModel?.toLowerCase().contains('sm-s918') ?? false);
    debugPrint(
      'Device detected: $_manufacturer $_deviceModel (SDK: $_sdkVersion)',
    );
  }
  Future<void> _applyDeviceSpecificOptimizations() async {
    if (_isSamsungDevice) {
      await _applySamsungOptimizations();
    } else {
      await _applyGeneralOptimizations();
    }
  }
  Future<void> _applySamsungOptimizations() async {
    try {
      final bool batteryOptResult =
          await _requestBatteryOptimizationExclusion();
      debugPrint('Battery optimization request result: $batteryOptResult');
      if (_isS23Ultra) {
        final bool s23Result = await _configureS23UltraFeatures();
        debugPrint('S23 Ultra specific optimizations result: $s23Result');
      } else {
        final bool samsungResult = await _configureGeneralSamsungFeatures();
        debugPrint('General Samsung optimizations result: $samsungResult');
      }
    } catch (e) {
      debugPrint('Error applying Samsung optimizations: $e');
    }
  }
  Future<void> _applyGeneralOptimizations() async {
    try {
      final bool batteryOptResult =
          await _requestBatteryOptimizationExclusion();
      debugPrint('Battery optimization request result: $batteryOptResult');
      if (_sdkVersion >= 31) {
        final bool android12Result = await _configureAndroid12Features();
        debugPrint('Android 12+ optimizations result: $android12Result');
      } else if (_sdkVersion >= 26) {
        final bool olderAndroidResult = await _configureOlderAndroidFeatures();
        debugPrint('Android 8-11 optimizations result: $olderAndroidResult');
      }
    } catch (e) {
      debugPrint('Error applying general optimizations: $e');
    }
  }
  Future<bool> _configureOlderAndroidFeatures() async {
    debugPrint('Configuring for Android $_sdkVersion');
    return true;
  }
  Future<bool> _configureAndroid12Features() async {
    try {
      if (!_isAndroid) return false;
      const methodChannel = MethodChannel(
        'com.example.spaced_learning_app.device/optimization',
      );
      try {
        return await methodChannel.invokeMethod('requestExactAlarmPermission');
      } on PlatformException catch (e) {
        debugPrint('Failed to configure Android 12 features: ${e.message}');
        return false;
      } on MissingPluginException {
        debugPrint('Plugin not available on this platform');
        return false;
      }
    } catch (e) {
      debugPrint('Unexpected error configuring Android 12 features: $e');
      return false;
    }
  }
  Future<bool> _configureGeneralSamsungFeatures() async {
    try {
      if (!_isAndroid) return false;
      const methodChannel = MethodChannel('com.yourapp.device/optimization');
      try {
        return await methodChannel.invokeMethod('disableSleepingApps');
      } on PlatformException catch (e) {
        debugPrint('Failed to configure Samsung features: ${e.message}');
        return false;
      } on MissingPluginException {
        debugPrint('Plugin not available on this platform');
        return false;
      }
    } catch (e) {
      debugPrint('Unexpected error configuring Samsung features: $e');
      return false;
    }
  }
  Future<bool> _requestBatteryOptimizationExclusion() async {
    try {
      if (!_isAndroid) return true;
      final status = await Permission.ignoreBatteryOptimizations.status;
      if (status.isGranted) {
        debugPrint('Battery optimization already disabled');
        return true;
      }
      final result = await Permission.ignoreBatteryOptimizations.request();
      final bool isGranted = result.isGranted;
      debugPrint('Battery optimization exclusion request result: $isGranted');
      return isGranted;
    } catch (e) {
      debugPrint('Error requesting battery optimization exclusion: $e');
      return false;
    }
  }
  Future<bool> _configureS23UltraFeatures() async {
    if (!_isAndroid) return false;
    bool overallSuccess = true;
    try {
      const methodChannel = MethodChannel('com.yourapp.samsung/optimization');
      try {
        final bool gameOptimizerResult = await methodChannel.invokeMethod(
          'disableGameOptimizer',
        );
        debugPrint('Game Optimizer disabled: $gameOptimizerResult');
        if (!gameOptimizerResult) overallSuccess = false;
      } on PlatformException catch (e) {
        debugPrint('Failed to disable Game Optimizer: ${e.message}');
        overallSuccess = false;
      } on MissingPluginException {
        debugPrint('Plugin not available on this platform');
        overallSuccess = false;
      }
      bool hasEdgePanel = false;
      try {
        hasEdgePanel = await methodChannel.invokeMethod('hasEdgePanel');
        debugPrint('Device has Edge Panel: $hasEdgePanel');
      } on PlatformException catch (e) {
        debugPrint('Failed to check Edge Panel availability: ${e.message}');
      } on MissingPluginException {
        debugPrint('Plugin not available on this platform');
      }
      if (hasEdgePanel) {
        try {
          final bool edgePanelResult = await methodChannel.invokeMethod(
            'registerEdgePanelProvider',
          );
          debugPrint('Edge Panel registration: $edgePanelResult');
          if (!edgePanelResult) overallSuccess = false;
        } on PlatformException catch (e) {
          debugPrint('Failed to register Edge Panel provider: ${e.message}');
          overallSuccess = false;
        } on MissingPluginException {
          debugPrint('Plugin not available on this platform');
          overallSuccess = false;
        }
      }
      return overallSuccess;
    } catch (e) {
      debugPrint('Error configuring S23 Ultra features: $e');
      return false;
    }
  }
  bool get _isAndroid {
    if (kIsWeb) return false;
    try {
      return defaultTargetPlatform == TargetPlatform.android;
    } catch (e) {
      debugPrint('Error checking platform: $e');
      return false;
    }
  }
  bool get isAndroid => _isAndroid;
  bool get isSamsungDevice => _isSamsungDevice;
  bool get isS23Ultra => _isS23Ultra;
  String? get deviceModel => _deviceModel;
  int get sdkVersion => _sdkVersion;
  String? get manufacturer => _manufacturer;
  bool get isInitialized => _isInitialized;
  Future<bool> hasExactAlarmPermission() async {
    return _deviceSettingsService.hasExactAlarmPermission();
  }
  Future<bool> isIgnoringBatteryOptimizations() async {
    return _deviceSettingsService.isIgnoringBatteryOptimizations();
  }
  Future<bool> requestExactAlarmPermission() async {
    return _deviceSettingsService.requestExactAlarmPermission();
  }
  Future<bool> requestBatteryOptimization() async {
    return _deviceSettingsService.requestBatteryOptimization();
  }
  Future<bool> disableSleepingApps() async {
    return _deviceSettingsService.disableSleepingApps();
  }
  Future<Map<String, dynamic>> getDeviceInfo() async {
    return _deviceSettingsService.getDeviceInfo();
  }
}
@riverpod
class DeviceInfo extends _$DeviceInfo {
  @override
  Future<Map<String, dynamic>> build() async {
    final deviceService = await ref.watch(deviceSpecificServiceProvider.future);
    final Map<String, dynamic> info = {
      'isAndroid': deviceService.isAndroid,
      'isSamsungDevice': deviceService.isSamsungDevice,
      'isS23Ultra': deviceService.isS23Ultra,
      'deviceModel': deviceService.deviceModel,
      'manufacturer': deviceService.manufacturer,
      'sdkVersion': deviceService.sdkVersion,
      'isInitialized': deviceService.isInitialized,
    };
    info['isIgnoringBatteryOptimizations'] = await deviceService
        .isIgnoringBatteryOptimizations();
    if (deviceService.isAndroid && deviceService.sdkVersion >= 31) {
      info['hasExactAlarmPermission'] = await deviceService
          .hasExactAlarmPermission();
    }
    return info;
  }
  Future<bool> requestBatteryOptimization() async {
    final deviceService = await ref.read(deviceSpecificServiceProvider.future);
    final result = await deviceService.requestBatteryOptimization();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
  Future<bool> requestExactAlarmPermission() async {
    final deviceService = await ref.read(deviceSpecificServiceProvider.future);
    final result = await deviceService.requestExactAlarmPermission();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
  Future<bool> disableSleepingApps() async {
    final deviceService = await ref.read(deviceSpecificServiceProvider.future);
    return deviceService.disableSleepingApps();
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/auth/register_screen.dart
class RegisterScreen extends ConsumerStatefulWidget {
  const RegisterScreen({super.key});
  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}
class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final TextEditingController _confirmPasswordController =
      TextEditingController();
  final TextEditingController _firstNameController = TextEditingController();
  final TextEditingController _lastNameController = TextEditingController();
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  String? _usernameError;
  String? _emailError;
  String? _passwordError;
  String? _confirmPasswordError;
  String? _firstNameError;
  String? _lastNameError;
  @override
  void dispose() {
    _usernameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    _firstNameController.dispose();
    _lastNameController.dispose();
    super.dispose();
  }
  void _validateUsername() {
    setState(() {
      _usernameError = _usernameController.text.isEmpty
          ? 'Username is required'
          : _usernameController.text.length < 3
          ? 'Username must be at least 3 characters'
          : !RegExp(r'^[a-zA-Z0-9._-]+$').hasMatch(_usernameController.text)
          ? 'Username can only contain letters, numbers, dots, underscores and hyphens'
          : null;
    });
  }
  void _validateEmail() {
    setState(() {
      _emailError = _emailController.text.isEmpty
          ? 'Email is required'
          : !RegExp(
              r'^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$',
            ).hasMatch(_emailController.text)
          ? 'Enter a valid email address'
          : null;
    });
  }
  void _validatePassword() {
    setState(() {
      _passwordError = _passwordController.text.isEmpty
          ? 'Password is required'
          : _passwordController.text.length < 8
          ? 'Password must be at least 8 characters'
          : null;
    });
  }
  void _validateConfirmPassword() {
    setState(() {
      _confirmPasswordError = _confirmPasswordController.text.isEmpty
          ? 'Please confirm your password'
          : _confirmPasswordController.text != _passwordController.text
          ? 'Passwords do not match'
          : null;
    });
  }
  void _validateFirstName() {
    setState(() {
      _firstNameError = _firstNameController.text.isEmpty
          ? 'First name is required'
          : null;
    });
  }
  void _validateLastName() {
    setState(() {
      _lastNameError = _lastNameController.text.isEmpty
          ? 'Last name is required'
          : null;
    });
  }
  Future<void> _register() async {
    _validateUsername();
    _validateEmail();
    _validatePassword();
    _validateConfirmPassword();
    _validateFirstName();
    _validateLastName();
    if (_usernameError == null &&
        _emailError == null &&
        _passwordError == null &&
        _confirmPasswordError == null &&
        _firstNameError == null &&
        _lastNameError == null) {
      final authNotifier = ref.read(authStateProvider.notifier);
      final success = await authNotifier.register(
        _usernameController.text,
        _emailController.text,
        _passwordController.text,
        _firstNameController.text,
        _lastNameController.text,
      );
      if (success &&
          mounted &&
          ref.read(authStateProvider).valueOrNull == true) {
        NavigationHelper.clearStackAndGo(context, '/');
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final authState = ref.watch(authStateProvider);
    final authError = ref.watch(authErrorProvider);
    return Scaffold(
      appBar: AppBar(title: const Text('Register')),
      body: LoadingOverlay(
        isLoading: authState.isLoading,
        child: SafeArea(
          child: Center(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(24.0),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    _buildHeader(theme),
                    _buildSLErrorView(authError, theme),
                    _buildNameFields(),
                    const SizedBox(height: 16),
                    _buildAuthFields(theme),
                    _buildActions(authState.isLoading, theme),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildHeader(ThemeData theme) {
    return Column(
      children: [
        Text(
          AppConstants.appName,
          style: theme.textTheme.headlineMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: theme.colorScheme.primary,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        Text(
          'Create your account',
          style: theme.textTheme.titleMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 32),
      ],
    );
  }
  Widget _buildSLErrorView(String? errorMessage, ThemeData theme) {
    return errorMessage != null
        ? Column(
            children: [
              SLErrorView(
                message: errorMessage,
                compact: true,
                onRetry: () =>
                    ref.read(authErrorProvider.notifier).clearError(),
              ),
              const SizedBox(height: 16),
            ],
          )
        : const SizedBox.shrink();
  }
  Widget _buildNameFields() {
    return Column(
      children: [
        SLTextField(
          label: 'First Name',
          hint: 'Enter your first name',
          controller: _firstNameController,
          keyboardType: TextInputType.name,
          errorText: _firstNameError,
          prefixIcon: Icons.person,
          onChanged: (_) => _firstNameError = null,
          onEditingComplete: _validateFirstName,
        ),
        const SizedBox(height: 16),
        SLTextField(
          label: 'Last Name',
          hint: 'Enter your last name',
          controller: _lastNameController,
          keyboardType: TextInputType.name,
          errorText: _lastNameError,
          prefixIcon: Icons.person,
          onChanged: (_) => _lastNameError = null,
          onEditingComplete: _validateLastName,
        ),
      ],
    );
  }
  Widget _buildAuthFields(ThemeData theme) {
    return Column(
      children: [
        SLTextField(
          label: 'Username',
          hint: 'Enter your username',
          controller: _usernameController,
          keyboardType: TextInputType.text,
          errorText: _usernameError,
          prefixIcon: Icons.account_circle,
          onChanged: (_) => _usernameError = null,
          onEditingComplete: _validateUsername,
        ),
        const SizedBox(height: 16),
        SLTextField(
          label: 'Email',
          hint: 'Enter your email',
          controller: _emailController,
          keyboardType: TextInputType.emailAddress,
          errorText: _emailError,
          prefixIcon: Icons.email,
          onChanged: (_) => _emailError = null,
          onEditingComplete: _validateEmail,
        ),
        const SizedBox(height: 16),
        SLPasswordField(
          label: 'Password',
          hint: 'Enter your password',
          controller: _passwordController,
          textInputAction: TextInputAction.next,
          errorText: _passwordError,
          prefixIcon: Icon(Icons.lock, color: theme.iconTheme.color),
          onChanged: (_) {
            _passwordError = null;
            if (_confirmPasswordController.text.isNotEmpty) {
              _validateConfirmPassword();
            }
          },
          onEditingComplete: _validatePassword,
        ),
        const SizedBox(height: 16),
        SLPasswordField(
          label: 'Confirm Password',
          hint: 'Confirm your password',
          controller: _confirmPasswordController,
          errorText: _confirmPasswordError,
          prefixIcon: Icon(Icons.lock_outline, color: theme.iconTheme.color),
          onChanged: (_) => _confirmPasswordError = null,
          onEditingComplete: _validateConfirmPassword,
        ),
      ],
    );
  }
  Widget _buildActions(bool isLoading, ThemeData theme) {
    return Column(
      children: [
        const SizedBox(height: 24),
        SLButton(
          text: 'Register',
          onPressed: _register,
          isLoading: isLoading,
          isFullWidth: true,
        ),
        const SizedBox(height: 16),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Already have an account? ',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(
                'Login',
                style: TextStyle(color: theme.colorScheme.primary),
              ),
            ),
          ],
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/progress/progress_detail_screen.dart
class ProgressDetailScreen extends ConsumerStatefulWidget {
  final String progressId;
  const ProgressDetailScreen({super.key, required this.progressId});
  @override
  ConsumerState<ProgressDetailScreen> createState() =>
      _ProgressDetailScreenState();
}
class _ProgressDetailScreenState extends ConsumerState<ProgressDetailScreen> {
  late Future<void> _dataLoadingFuture;
  @override
  void initState() {
    super.initState();
    Future(() => _loadInitialData());
  }
  Future<void> _loadInitialData() async {
    try {
      await ref
          .read(selectedProgressProvider.notifier)
          .loadProgressDetails(widget.progressId);
      await ref
          .read(repetitionStateProvider.notifier)
          .loadRepetitionsByProgressId(widget.progressId);
    } catch (e) {
      debugPrint('Error loading initial data: $e');
    }
  }
  Future<void> _reloadData() async {
    setState(() {
      _dataLoadingFuture = _loadInitialData();
    });
  }
  Future<void> _markRepetitionCompleted(String repetitionId) async {
    final score = await ScoreInputDialog.show(context);
    if (score == null) return;
    final updatedRepetition = await ref
        .read(repetitionStateProvider.notifier)
        .updateRepetition(
          repetitionId,
          status: RepetitionStatus.completed,
          percentComplete: score,
        );
    if (updatedRepetition == null) return;
    final allCompleted = await ref
        .read(repetitionStateProvider.notifier)
        .areAllRepetitionsCompleted(updatedRepetition.moduleProgressId);
    if (allCompleted) {
      _showCycleCompletionSnackBar();
    } else {
      _showCompletionSnackBar(score);
    }
    await _reloadData();
  }
  Future<void> _rescheduleRepetition(
    String repetitionId,
    DateTime currentDate,
    bool rescheduleFollowing,
  ) async {
    final repetitions = ref.read(repetitionStateProvider).valueOrNull ?? [];
    final currentRepetition = repetitions.firstWhere(
      (r) => r.id == repetitionId,
      orElse: () => throw Exception('Repetition not found'),
    );
    final result = await RescheduleDialog.show(
      context,
      initialDate: currentDate,
      title: 'Reschedule Repetition #${currentRepetition.formatOrder()}',
    );
    if (result != null) {
      final newDate = result['date'] as DateTime;
      final rescheduleFollowing = result['rescheduleFollowing'] as bool;
      final updatedRepetition = await ref
          .read(repetitionStateProvider.notifier)
          .updateRepetition(
            repetitionId,
            reviewDate: newDate,
            rescheduleFollowing: rescheduleFollowing,
          );
      if (updatedRepetition != null) {
        SnackBarUtils.show(
          context,
          'Repetition rescheduled to ${DateFormat('dd MMM').format(newDate)}',
        );
        await _reloadData();
      }
    }
  }
  void _showCompletionSnackBar(double score) {
    SnackBarUtils.show(context, 'Test score saved: ${score.toInt()}%');
  }
  void _showCycleCompletionSnackBar() {
    final theme = Theme.of(context);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text(
          'Congratulations! You have completed this learning cycle.',
        ),
        backgroundColor: theme.colorScheme.tertiary,
        duration: const Duration(seconds: 5),
        action: SnackBarAction(
          label: 'Details',
          onPressed: _showCycleCompletionDialog,
        ),
      ),
    );
  }
  void _showCycleCompletionDialog() {
    showDialog(
      context: context,
      builder: (context) => const CycleCompletionDialog(),
    );
  }
  @override
  Widget build(BuildContext context) {
    final progressAsync = ref.watch(selectedProgressProvider);
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    if (widget.progressId.isEmpty) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('Progress Details'),
          backgroundColor: colorScheme.surfaceContainerHigh,
        ),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.error_outline, size: 64, color: colorScheme.error),
              const SizedBox(height: 16),
              Text('Invalid progress ID', style: theme.textTheme.titleLarge),
              const SizedBox(height: 24),
              FilledButton.tonal(
                onPressed: () => context.pop(),
                child: const Text('Go Back'),
              ),
            ],
          ),
        ),
      );
    }
    return Scaffold(
      appBar: _buildAppBar(progressAsync.valueOrNull?.moduleTitle),
      body: SafeArea(
        child: progressAsync.when(
          data: (progress) {
            if (progress == null) {
              return _buildProgressNotFoundView();
            }
            return _buildProgressView(progress);
          },
          loading: () => const Center(
            child: SLLoadingIndicator(type: LoadingIndicatorType.circle),
          ),
          error: (error, stack) => Center(
            child: SLErrorView(
              message: error.toString(),
              onRetry: _reloadData,
              icon: Icons.error_outline,
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildProgressNotFoundView() {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Center(
      child: Container(
        padding: const EdgeInsets.all(AppDimens.paddingXL),
        constraints: const BoxConstraints(maxWidth: 400),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(AppDimens.paddingL),
              decoration: BoxDecoration(
                color: colorScheme.errorContainer,
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.warning_amber_rounded,
                size: 64,
                color: colorScheme.error,
              ),
            ),
            const SizedBox(height: AppDimens.spaceL),
            Text(
              'Progress Not Found',
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: colorScheme.error,
              ),
            ),
            const SizedBox(height: AppDimens.spaceM),
            Text(
              'The progress with ID ${widget.progressId} could not be found or may have been deleted.',
              textAlign: TextAlign.center,
              style: theme.textTheme.bodyLarge?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: AppDimens.spaceXL),
            FilledButton.icon(
              onPressed: _reloadData,
              icon: const Icon(Icons.refresh),
              label: const Text('Try Again'),
              style: FilledButton.styleFrom(minimumSize: const Size(200, 50)),
            ),
            const SizedBox(height: AppDimens.spaceM),
            OutlinedButton.icon(
              onPressed: () => context.go('/due-progress'),
              icon: const Icon(Icons.arrow_back),
              label: const Text('Go Back'),
              style: OutlinedButton.styleFrom(minimumSize: const Size(200, 50)),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildProgressView(ProgressDetail progress) {
    return RefreshIndicator(
      onRefresh: _reloadData,
      child: ListView(
        padding: const EdgeInsets.all(AppDimens.paddingM),
        children: [
          ProgressHeaderWidget(
            progress: progress,
            onCycleCompleteDialogRequested: _showCycleCompletionDialog,
          ),
          const SizedBox(height: AppDimens.spaceXL),
          ProgressRepetitionList(
            progressId: widget.progressId,
            currentCycleStudied: progress.cyclesStudied,
            onMarkCompleted: _markRepetitionCompleted,
            onReschedule: _rescheduleRepetition,
            onReload: _reloadData,
          ),
          const SizedBox(height: 100),
        ],
      ),
    );
  }
  AppBar _buildAppBar(String? moduleTitle) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return AppBar(
      title: Text(
        moduleTitle ?? 'Module Progress',
        style: theme.textTheme.titleLarge?.copyWith(
          fontWeight: FontWeight.bold,
        ),
      ),
      centerTitle: true,
      backgroundColor: colorScheme.surfaceContainerHigh,
      elevation: 0,
      scrolledUnderElevation: 4,
      actions: [
        IconButton(
          icon: const Icon(Icons.help_outline),
          tooltip: 'Learn about repetition cycles',
          onPressed: () => context.push('/help/spaced-repetition'),
        ),
        IconButton(
          icon: const Icon(Icons.refresh),
          tooltip: 'Refresh data',
          onPressed: _reloadData,
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/navigation/router.dart
@riverpod
GoRouter router(Ref ref) {
  final authState = ref.watch(authStateProvider);
  return GoRouter(
    initialLocation: '/',
    debugLogDiagnostics: true,
    redirect: (context, state) {
      if (authState.isLoading) {
        return null;
      }
      final isLoggedIn = authState.valueOrNull ?? false;
      final isGoingToLogin = state.matchedLocation == RouteConstants.login;
      final publicRoutes = [
        RouteConstants.login,
        RouteConstants.register,
        RouteConstants.forgotPassword,
      ];
      final isGoingToPublicRoute = publicRoutes.contains(state.matchedLocation);
      if (!isLoggedIn && !isGoingToPublicRoute) {
        return RouteConstants.login;
      }
      if (isLoggedIn && isGoingToLogin) {
        return RouteConstants.home;
      }
      return null;
    },
    observers: [
      AppRouteObserver(),
      GoRouterObserver(
        onPop: (route, result) {
          debugPrint('Popped route: ${route.settings.name}');
        },
      ),
    ],
    routes: [
      GoRoute(
        path: RouteConstants.login,
        name: 'login',
        builder: (context, state) => const LoginScreen(),
      ),
      GoRoute(
        path: RouteConstants.progressDetail,
        name: 'progressDetail',
        builder: (context, state) {
          final progressId = state.pathParameters['id'];
          if (progressId == null || progressId.isEmpty) {
            return Scaffold(
              appBar: AppBar(title: const Text('Error')),
              body: Center(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Text('Invalid progress ID'),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: const Text('Go Back'),
                    ),
                  ],
                ),
              ),
            );
          }
          return ProgressDetailScreen(progressId: progressId);
        },
      ),
      ShellRoute(
        builder: (context, state, child) {
          int currentIndex = 0;
          final location = state.matchedLocation;
          if (location.startsWith('/books')) {
            currentIndex = 1;
          } else if (location.startsWith('/due-progress')) {
            currentIndex = 2;
          } else if (location.startsWith('/learning')) {
            currentIndex = 3;
          } else if (location.startsWith('/profile')) {
            currentIndex = 4;
          }
          return ScaffoldWithBottomBar(
            currentIndex: currentIndex,
            child: child,
          );
        },
        routes: [
          GoRoute(
            path: RouteConstants.home,
            name: 'home',
            builder: (context, state) => const HomeScreen(),
          ),
          GoRoute(
            path: RouteConstants.books,
            name: 'books',
            builder: (context, state) => const BooksScreen(),
            routes: [
              GoRoute(
                path: ':id',
                name: 'bookDetail',
                builder: (context, state) {
                  final bookId = state.pathParameters['id'];
                  if (bookId == null || bookId.isEmpty) {
                    return _buildErrorScreen(
                      'Invalid book ID',
                      () => GoRouter.of(context).go(RouteConstants.books),
                    );
                  }
                  return BookDetailScreen(bookId: bookId);
                },
                routes: [
                  GoRoute(
                    path: 'modules/:moduleId',
                    name: 'moduleDetail',
                    builder: (context, state) {
                      final moduleId = state.pathParameters['moduleId'];
                      if (moduleId == null || moduleId.isEmpty) {
                        return _buildErrorScreen(
                          'Invalid module ID',
                          () => GoRouter.of(context).pop(),
                        );
                      }
                      return ModuleDetailScreen(moduleId: moduleId);
                    },
                  ),
                ],
              ),
            ],
          ),
          GoRoute(
            path: RouteConstants.learning,
            name: 'learning',
            builder: (context, state) => const LearningProgressScreen(),
            routes: [
              GoRoute(
                path: 'progress/:id',
                name: 'learningProgress',
                builder: (context, state) {
                  final progressId = state.pathParameters['id'];
                  if (progressId == null || progressId.isEmpty) {
                    return _buildErrorScreen(
                      'Invalid progress ID',
                      () => GoRouter.of(context).go(RouteConstants.learning),
                    );
                  }
                  return ProgressDetailScreen(progressId: progressId);
                },
              ),
              GoRoute(
                path: 'modules/:id',
                name: 'learningModule',
                builder: (context, state) {
                  final moduleId = state.pathParameters['id'];
                  if (moduleId == null || moduleId.isEmpty) {
                    return _buildErrorScreen(
                      'Invalid module ID',
                      () => GoRouter.of(context).go(RouteConstants.learning),
                    );
                  }
                  return ModuleDetailScreen(moduleId: moduleId);
                },
              ),
            ],
          ),
          GoRoute(
            path: RouteConstants.profile,
            name: 'profile',
            builder: (context, state) => const ProfileScreen(),
          ),
          GoRoute(
            path: RouteConstants.dueProgress,
            name: 'dueProgress',
            builder: (context, state) => const DueProgressScreen(),
          ),
          GoRoute(
            path: RouteConstants.reminderSettings,
            name: 'reminderSettings',
            builder: (context, state) => const ReminderSettingsScreen(),
          ),
          GoRoute(
            path: RouteConstants.help,
            name: 'help',
            builder: (context, state) =>
                const Scaffold(body: Center(child: Text('Help & Support'))),
            routes: [
              GoRoute(
                path: 'spaced-repetition',
                name: 'spacedRepetition',
                builder: (context, state) => const SpacedRepetitionInfoScreen(),
              ),
            ],
          ),
          GoRoute(
            path: RouteConstants.taskReport,
            name: 'taskReport',
            builder: (context, state) => const DailyTaskReportScreen(),
          ),
        ],
      ),
    ],
  );
}
Widget _buildErrorScreen(String message, VoidCallback onBack) {
  return Scaffold(
    appBar: AppBar(title: const Text('Error')),
    body: Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(message, style: const TextStyle(fontSize: 16)),
          const SizedBox(height: 16),
          ElevatedButton(onPressed: onBack, child: const Text('Go Back')),
        ],
      ),
    ),
  );
}
class GoRouterObserver extends NavigatorObserver {
  final Function(Route<dynamic> route, dynamic result)? onPop;
  GoRouterObserver({this.onPop});
  @override
  void didPop(Route route, Route? previousRoute) {
    super.didPop(route, previousRoute);
    onPop?.call(route, null);
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/app_text_field.dart
class SLTextField extends StatefulWidget {
  final String? label;
  final String? hint;
  final String? errorText;
  final String? helperText;
  final TextEditingController? controller;
  final TextInputType keyboardType;
  final bool obscureText;
  final FocusNode? focusNode;
  final ValueChanged<String>? onChanged;
  final VoidCallback? onTap;
  final bool readOnly;
  final bool enabled;
  final IconData? prefixIcon;
  final Widget? prefix;
  final IconData? suffixIcon;
  final Widget? suffix;
  final VoidCallback? onSuffixIconTap;
  final int? maxLength;
  final int? maxLines;
  final int? minLines;
  final List<TextInputFormatter>? inputFormatters;
  final bool showCounter;
  final bool autofocus;
  final TextAlign textAlign;
  final TextCapitalization textCapitalization;
  final String? Function(String?)? validator;
  final AutovalidateMode autovalidateMode;
  final Color? fillColor;
  final Color? labelColor;
  final Color? hintColor;
  final Color? errorColor;
  final Color? borderColor;
  final Color? focusedBorderColor;
  final Color? backgroundColor;
  final EdgeInsetsGeometry? contentPadding;
  final TextInputAction? textInputAction;
  final VoidCallback? onEditingComplete;
  final ValueChanged<String>? onSubmitted;
  const SLTextField({
    super.key,
    this.label,
    this.hint,
    this.errorText,
    this.helperText,
    this.controller,
    this.keyboardType = TextInputType.text,
    this.obscureText = false,
    this.focusNode,
    this.onChanged,
    this.onTap,
    this.readOnly = false,
    this.enabled = true,
    this.prefixIcon,
    this.prefix,
    this.suffixIcon,
    this.suffix,
    this.onSuffixIconTap,
    this.maxLength,
    this.maxLines = 1,
    this.minLines,
    this.inputFormatters,
    this.showCounter = false,
    this.autofocus = false,
    this.textAlign = TextAlign.start,
    this.textCapitalization = TextCapitalization.none,
    this.validator,
    this.autovalidateMode = AutovalidateMode.onUserInteraction,
    this.fillColor,
    this.labelColor,
    this.hintColor,
    this.errorColor,
    this.borderColor,
    this.focusedBorderColor,
    this.backgroundColor,
    this.contentPadding,
    this.textInputAction,
    this.onEditingComplete,
    this.onSubmitted,
  });
  @override
  State<SLTextField> createState() => _SLTextFieldState();
}
class _SLTextFieldState extends State<SLTextField> {
  bool _passwordVisible = false;
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    Widget? suffixIconWidget;
    if (widget.suffixIcon != null) {
      suffixIconWidget = InkWell(
        onTap: widget.onSuffixIconTap,
        borderRadius: BorderRadius.circular(AppDimens.radiusXXL),
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingS),
          child: Icon(
            widget.suffixIcon,
            color: widget.errorText != null
                ? colorScheme.error
                : colorScheme.primary,
            size: AppDimens.iconM,
          ),
        ),
      );
    } else if (widget.obscureText) {
      suffixIconWidget = InkWell(
        onTap: () {
          setState(() {
            _passwordVisible = !_passwordVisible;
          });
        },
        borderRadius: BorderRadius.circular(AppDimens.radiusXXL),
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingS),
          child: Icon(
            _passwordVisible
                ? Icons.visibility_off_outlined
                : Icons.visibility_outlined,
            color: colorScheme.secondary,
            size: AppDimens.iconM,
          ),
        ),
      );
    }
    return Container(
      color: widget.backgroundColor ?? Colors.transparent,
      child: TextFormField(
        controller: widget.controller,
        focusNode: widget.focusNode,
        keyboardType: widget.keyboardType,
        textInputAction: widget.textInputAction,
        textCapitalization: widget.textCapitalization,
        textAlign: widget.textAlign,
        readOnly: widget.readOnly,
        enabled: widget.enabled,
        obscureText: widget.obscureText && !_passwordVisible,
        maxLength: widget.maxLength,
        maxLines: widget.obscureText ? 1 : widget.maxLines,
        minLines: widget.minLines,
        autofocus: widget.autofocus,
        onChanged: widget.onChanged,
        onTap: widget.onTap,
        inputFormatters: widget.inputFormatters,
        onEditingComplete: widget.onEditingComplete,
        onFieldSubmitted: widget.onSubmitted,
        autovalidateMode: widget.autovalidateMode,
        validator: widget.validator,
        style: theme.textTheme.bodyLarge!.copyWith(
          color: widget.enabled
              ? colorScheme.onSurface
              : colorScheme.onSurface.withValues(
                  alpha: AppDimens.opacityDisabled,
                ),
        ),
        decoration: InputDecoration(
          labelText: widget.label,
          hintText: widget.hint,
          errorText: widget.errorText,
          helperText: widget.helperText,
          filled: true,
          fillColor: widget.fillColor ?? colorScheme.surfaceContainerLowest,
          contentPadding:
              widget.contentPadding ??
              const EdgeInsets.symmetric(
                horizontal: AppDimens.paddingL,
                vertical: AppDimens.paddingL,
              ),
          prefixIcon: widget.prefixIcon != null
              ? Icon(
                  widget.prefixIcon,
                  color: widget.errorText != null
                      ? colorScheme.error
                      : colorScheme.primary,
                  size: AppDimens.iconM,
                )
              : widget.prefix,
          suffixIcon: suffixIconWidget ?? widget.suffix,
          counterText: widget.showCounter ? null : '',
          labelStyle: TextStyle(
            color: widget.labelColor ?? colorScheme.onSurface,
          ),
          hintStyle: TextStyle(
            color: widget.hintColor ?? colorScheme.onSurfaceVariant,
          ),
          errorStyle: TextStyle(color: widget.errorColor ?? colorScheme.error),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
            borderSide: BorderSide(color: colorScheme.outline),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
            borderSide: BorderSide(
              color: widget.borderColor ?? colorScheme.outline,
            ),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
            borderSide: BorderSide(
              color: widget.focusedBorderColor ?? colorScheme.primary,
              width: 2,
            ),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
            borderSide: BorderSide(color: colorScheme.error),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
            borderSide: BorderSide(color: colorScheme.error, width: 2),
          ),
          disabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
            borderSide: BorderSide(
              color: colorScheme.onSurface.withValues(
                alpha: AppDimens.opacityDisabled,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
class SLPasswordField extends StatefulWidget {
  final String? label;
  final String? hint;
  final String? errorText;
  final TextEditingController? controller;
  final Widget? prefixIcon;
  final ValueChanged<String>? onChanged;
  final VoidCallback? onEditingComplete;
  final TextInputAction? textInputAction;
  final FocusNode? focusNode;
  final String? Function(String?)? validator;
  final Color? labelColor;
  final Color? hintColor;
  final Color? errorColor;
  final Color? borderColor;
  final Color? focusedBorderColor;
  final Color? backgroundColor;
  const SLPasswordField({
    super.key,
    this.label,
    this.hint,
    this.errorText,
    this.controller,
    this.prefixIcon,
    this.onChanged,
    this.onEditingComplete,
    this.textInputAction = TextInputAction.done,
    this.focusNode,
    this.validator,
    this.labelColor,
    this.hintColor,
    this.errorColor,
    this.borderColor,
    this.focusedBorderColor,
    this.backgroundColor,
  });
  @override
  State<SLPasswordField> createState() => _SLPasswordFieldState();
}
class _SLPasswordFieldState extends State<SLPasswordField> {
  @override
  Widget build(BuildContext context) {
    return SLTextField(
      label: widget.label,
      hint: widget.hint,
      controller: widget.controller,
      errorText: widget.errorText,
      prefix: widget.prefixIcon,
      obscureText: true,
      keyboardType: TextInputType.visiblePassword,
      onChanged: widget.onChanged,
      onEditingComplete: widget.onEditingComplete,
      textInputAction: widget.textInputAction,
      focusNode: widget.focusNode,
      validator: widget.validator,
      labelColor: widget.labelColor,
      hintColor: widget.hintColor,
      errorColor: widget.errorColor,
      borderColor: widget.borderColor,
      focusedBorderColor: widget.focusedBorderColor,
      backgroundColor: widget.backgroundColor,
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/book_filter_panel.dart
class BookFilterPanel extends StatelessWidget {
  final List<String> categories;
  final String? selectedCategory;
  final BookStatus? selectedStatus;
  final DifficultyLevel? selectedDifficulty;
  final Function(String?)? onCategorySelected;
  final Function(BookStatus?)? onStatusSelected;
  final Function(DifficultyLevel?)? onDifficultySelected;
  final VoidCallback? onFiltersApplied;
  final VoidCallback? onFilterCleared;
  const BookFilterPanel({
    super.key,
    required this.categories,
    this.selectedCategory,
    this.selectedStatus,
    this.selectedDifficulty,
    this.onCategorySelected,
    this.onStatusSelected,
    this.onDifficultySelected,
    this.onFiltersApplied,
    this.onFilterCleared,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Container(
      padding: const EdgeInsets.fromLTRB(
        AppDimens.paddingL,
        AppDimens.paddingS,
        AppDimens.paddingL,
        AppDimens.paddingL,
      ),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLowest,
        borderRadius: const BorderRadius.only(
          bottomLeft: Radius.circular(AppDimens.radiusL),
          bottomRight: Radius.circular(AppDimens.radiusL),
        ),
        boxShadow: [
          BoxShadow(
            color: colorScheme.shadow.withValues(alpha: AppDimens.opacityLight),
            blurRadius: AppDimens.shadowRadiusM,
            offset: const Offset(0, AppDimens.shadowOffsetS),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (selectedCategory != null ||
              selectedStatus != null ||
              selectedDifficulty != null)
            Padding(
              padding: const EdgeInsets.only(bottom: AppDimens.paddingM),
              child: Wrap(
                spacing: AppDimens.spaceS,
                runSpacing: AppDimens.spaceS,
                children: [
                  if (selectedCategory != null)
                    FilterChipWidget(
                      label: selectedCategory!,
                      color: colorScheme.tertiary,
                      onDeleted: () {
                        if (onCategorySelected != null) {
                          onCategorySelected!(null);
                        }
                      },
                    ),
                  if (selectedStatus != null)
                    FilterChipWidget(
                      label: BookFormatter.formatStatus(selectedStatus!),
                      color: colorScheme.primary,
                      onDeleted: () {
                        if (onStatusSelected != null) {
                          onStatusSelected!(null);
                        }
                      },
                    ),
                  if (selectedDifficulty != null)
                    FilterChipWidget(
                      label: BookFormatter.formatDifficulty(selectedDifficulty),
                      color: colorScheme.secondary,
                      onDeleted: () {
                        if (onDifficultySelected != null) {
                          onDifficultySelected!(null);
                        }
                      },
                    ),
                  OutlinedButton.icon(
                    onPressed: onFilterCleared,
                    icon: Icon(
                      Icons.clear_all,
                      size: AppDimens.iconS,
                      color: colorScheme.primary,
                    ),
                    label: Text(
                      'Clear All',
                      style: theme.textTheme.labelMedium?.copyWith(
                        color: colorScheme.primary,
                      ),
                    ),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: AppDimens.paddingM,
                        vertical: AppDimens.paddingXS,
                      ),
                      visualDensity: VisualDensity.compact,
                    ),
                  ),
                ],
              ),
            ),
          _buildFilterSection(
            theme,
            colorScheme,
            'Category',
            Icons.category_outlined,
            colorScheme.primary,
            Wrap(
              spacing: AppDimens.spaceXS,
              runSpacing: AppDimens.spaceXS,
              children: [
                for (final category in categories)
                  ChoiceChip(
                    label: Text(category),
                    selected: selectedCategory == category,
                    onSelected: (selected) {
                      if (onCategorySelected != null) {
                        onCategorySelected!(selected ? category : null);
                      }
                    },
                    selectedColor: colorScheme.tertiaryContainer,
                    labelStyle: TextStyle(
                      color: selectedCategory == category
                          ? colorScheme.onTertiaryContainer
                          : colorScheme.onSurfaceVariant,
                    ),
                  ),
              ],
            ),
          ),
          _buildFilterSection(
            theme,
            colorScheme,
            'Status',
            Icons.published_with_changes_outlined,
            colorScheme.primary,
            Wrap(
              spacing: AppDimens.spaceXS,
              runSpacing: AppDimens.spaceXS,
              children: [
                for (final status in BookStatus.values)
                  ChoiceChip(
                    label: Text(BookFormatter.formatStatus(status)),
                    selected: selectedStatus == status,
                    onSelected: (selected) {
                      if (onStatusSelected != null) {
                        onStatusSelected!(selected ? status : null);
                      }
                    },
                    selectedColor: colorScheme.primaryContainer,
                    labelStyle: TextStyle(
                      color: selectedStatus == status
                          ? colorScheme.onPrimaryContainer
                          : colorScheme.onSurfaceVariant,
                    ),
                  ),
              ],
            ),
          ),
          _buildFilterSection(
            theme,
            colorScheme,
            'Difficulty',
            Icons.signal_cellular_alt_outlined,
            colorScheme.primary,
            Wrap(
              spacing: AppDimens.spaceXS,
              runSpacing: AppDimens.spaceXS,
              children: [
                for (final difficulty in DifficultyLevel.values)
                  ChoiceChip(
                    label: Text(BookFormatter.formatDifficulty(difficulty)),
                    selected: selectedDifficulty == difficulty,
                    onSelected: (selected) {
                      if (onDifficultySelected != null) {
                        onDifficultySelected!(selected ? difficulty : null);
                      }
                    },
                    selectedColor: colorScheme.secondaryContainer,
                    labelStyle: TextStyle(
                      color: selectedDifficulty == difficulty
                          ? colorScheme.onSecondaryContainer
                          : colorScheme.onSurfaceVariant,
                    ),
                  ),
              ],
            ),
          ),
          Center(
            child: Padding(
              padding: const EdgeInsets.only(top: AppDimens.paddingM),
              child: ElevatedButton.icon(
                onPressed: onFiltersApplied,
                icon: const Icon(Icons.check),
                label: Text(
                  'Apply Filters',
                  style: theme.textTheme.labelLarge?.copyWith(
                    color: colorScheme.onPrimary,
                  ),
                ),
                style: ElevatedButton.styleFrom(
                  backgroundColor: colorScheme.primary,
                  padding: const EdgeInsets.symmetric(
                    horizontal: AppDimens.paddingL,
                    vertical: AppDimens.paddingM,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildFilterSection(
    ThemeData theme,
    ColorScheme colorScheme,
    String title,
    IconData icon,
    Color iconColor,
    Widget content,
  ) {
    return Padding(
      padding: const EdgeInsets.only(bottom: AppDimens.paddingM),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, color: iconColor, size: AppDimens.iconS),
              const SizedBox(width: AppDimens.spaceXS),
              Text(
                title,
                style: theme.textTheme.titleSmall?.copyWith(
                  color: iconColor,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: AppDimens.spaceXS),
          content,
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/daily_task_report_viewmodel.dart
class LogEntry {
  final DateTime timestamp;
  final String message;
  final String? detail;
  final bool isSuccess;
  LogEntry({
    required this.timestamp,
    required this.message,
    this.detail,
    required this.isSuccess,
  });
  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'message': message,
      'detail': detail,
      'isSuccess': isSuccess,
    };
  }
  factory LogEntry.fromJson(Map<String, dynamic> json) {
    return LogEntry(
      timestamp: DateTime.parse(json['timestamp']),
      message: json['message'],
      detail: json['detail'],
      isSuccess: json['isSuccess'],
    );
  }
}
class CheckResult {
  final DateTime timestamp;
  final bool isSuccess;
  final bool hasDueTasks;
  final int taskCount;
  final String? errorMessage;
  CheckResult({
    required this.timestamp,
    required this.isSuccess,
    required this.hasDueTasks,
    required this.taskCount,
    this.errorMessage,
  });
}
@riverpod
class DailyTaskReportState extends _$DailyTaskReportState {
  static const String _isActiveKey = 'daily_task_checker_active';
  static const String _logEntriesKey = 'daily_task_log_entries';
  @override
  Future<Map<String, dynamic>> build() async {
    return loadReportData();
  }
  Future<Map<String, dynamic>> loadReportData() async {
    try {
      final storageService = ref.read(storageServiceProvider);
      final isCheckerActive =
          await storageService.getBool(_isActiveKey) ?? false;
      final dailyTaskChecker = await ref.read(dailyTaskCheckerProvider.future);
      final report = await dailyTaskChecker.getLastCheckReport();
      final logs = await _loadLogs();
      return {
        'isCheckerActive': isCheckerActive,
        'lastCheckTime': report['lastCheckTime'],
        'lastCheckResult': report['lastCheckResult'],
        'lastCheckTaskCount': report['lastCheckTaskCount'],
        'lastCheckError': report['lastCheckError'],
        'logEntries': logs,
      };
    } catch (e) {
      throw Exception('Error loading report data: $e');
    }
  }
  Future<List<LogEntry>> _loadLogs() async {
    try {
      final storageService = ref.read(storageServiceProvider);
      final logsJson = await storageService.getString(_logEntriesKey);
      if (logsJson == null) {
        return [];
      }
      final List<dynamic> logsData = jsonDecode(logsJson);
      return logsData.map((json) => LogEntry.fromJson(json)).toList();
    } catch (e) {
      debugPrint('Error loading logs: $e');
      return [];
    }
  }
  Future<void> toggleChecker(bool value) async {
    if (value == state.valueOrNull?['isCheckerActive']) return;
    try {
      final storageService = ref.read(storageServiceProvider);
      await storageService.setBool(_isActiveKey, value);
      if (value) {
        final dailyTaskChecker = await ref.read(
          dailyTaskCheckerProvider.future,
        );
        final success = await dailyTaskChecker.initialize();
        if (success) {
          await _addLogEntry(
            message: 'Daily automated check activated',
            isSuccess: true,
          );
        } else {
          await _addLogEntry(
            message: 'Failed to activate automated check',
            isSuccess: false,
          );
          await storageService.setBool(_isActiveKey, false);
        }
      } else {
        final dailyTaskChecker = await ref.read(
          dailyTaskCheckerProvider.future,
        );
        final success = await dailyTaskChecker.cancelDailyCheck();
        await _addLogEntry(
          message: 'Daily automated check deactivated',
          isSuccess: success,
        );
      }
      state = await AsyncValue.guard(() => loadReportData());
    } catch (e) {
      throw Exception('Error changing checker state: $e');
    }
  }
  Future<CheckResult> performManualCheck() async {
    if (state.valueOrNull?['isManualCheckInProgress'] == true) {
      return CheckResult(
        timestamp: DateTime.now(),
        isSuccess: false,
        hasDueTasks: false,
        taskCount: 0,
        errorMessage: 'Check in progress, please wait',
      );
    }
    state = AsyncValue.data({
      ...state.valueOrNull ?? {},
      'isManualCheckInProgress': true,
    });
    try {
      await _addLogEntry(message: 'Starting manual check', isSuccess: true);
      final dailyTaskChecker = await ref.read(dailyTaskCheckerProvider.future);
      final event = await dailyTaskChecker.manualCheck();
      await _addLogEntry(
        message: event.hasDueTasks
            ? 'Manual check: Found ${event.taskCount} due tasks'
            : 'Manual check: No tasks due today',
        detail: event.isSuccess ? null : event.errorMessage,
        isSuccess: event.isSuccess,
      );
      state = await AsyncValue.guard(() => loadReportData());
      return CheckResult(
        timestamp: event.checkTime,
        isSuccess: event.isSuccess,
        hasDueTasks: event.hasDueTasks,
        taskCount: event.taskCount,
        errorMessage: event.errorMessage,
      );
    } catch (e) {
      await _addLogEntry(
        message: 'Manual check failed',
        detail: e.toString(),
        isSuccess: false,
      );
      state = await AsyncValue.guard(() => loadReportData());
      return CheckResult(
        timestamp: DateTime.now(),
        isSuccess: false,
        hasDueTasks: false,
        taskCount: 0,
        errorMessage: e.toString(),
      );
    } finally {
      state = AsyncValue.data({
        ...state.valueOrNull ?? {},
        'isManualCheckInProgress': false,
      });
    }
  }
  Future<void> _addLogEntry({
    required String message,
    String? detail,
    required bool isSuccess,
  }) async {
    try {
      final storageService = ref.read(storageServiceProvider);
      final entry = LogEntry(
        timestamp: DateTime.now(),
        message: message,
        detail: detail,
        isSuccess: isSuccess,
      );
      final currentStateValue = state.valueOrNull;
      List<LogEntry> existingLogs = [];
      if (currentStateValue != null &&
          currentStateValue['logEntries'] != null &&
          currentStateValue['logEntries'] is List<LogEntry>) {
        existingLogs = currentStateValue['logEntries'] as List<LogEntry>;
      } else {
        existingLogs = await _loadLogs();
      }
      final updatedLogs = [entry, ...existingLogs];
      final limitedLogs = updatedLogs.length > 100
          ? updatedLogs.sublist(0, 100)
          : updatedLogs;
      final logsJson = jsonEncode(limitedLogs.map((e) => e.toJson()).toList());
      await storageService.setString(_logEntriesKey, logsJson);
    } catch (e) {
      debugPrint('Error adding log entry: $e');
    }
  }
  Future<void> clearLogs() async {
    try {
      final storageService = ref.read(storageServiceProvider);
      await storageService.setString(_logEntriesKey, '[]');
      state = await AsyncValue.guard(() => loadReportData());
    } catch (e) {
      throw Exception('Error clearing logs: $e');
    }
  }
}
@riverpod
bool isManualCheckInProgress(Ref ref) {
  final reportState = ref.watch(dailyTaskReportStateProvider);
  return reportState.valueOrNull?['isManualCheckInProgress'] ?? false;
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/modules/module_detail_screen.dart
class ModuleDetailScreen extends ConsumerStatefulWidget {
  final String moduleId;
  const ModuleDetailScreen({super.key, required this.moduleId});
  @override
  ConsumerState<ModuleDetailScreen> createState() => _ModuleDetailScreenState();
}
class _ModuleDetailScreenState extends ConsumerState<ModuleDetailScreen> {
  late Future<void> _dataFuture;
  bool _isInitialLoad = true;
  @override
  void initState() {
    super.initState();
    _dataFuture = Future.delayed(Duration.zero, _loadData);
  }
  Future<void> _loadData() async {
    final moduleId = widget.moduleId;
    try {
      await ref
          .read(selectedModuleProvider.notifier)
          .loadModuleDetails(moduleId);
      final module = ref.read(selectedModuleProvider).valueOrNull;
      if (module == null) return;
      if (module.progress.isNotEmpty) {
        final progressId = module.progress[0].id;
        await ref
            .read(selectedProgressProvider.notifier)
            .loadProgressDetails(progressId);
        debugPrint('Loaded progress directly from module: $progressId');
      } else if (ref.read(authStateProvider).valueOrNull ?? false) {
        await ref
            .read(selectedProgressProvider.notifier)
            .loadModuleProgress(moduleId);
      }
      debugPrint(
        'After loading - Progress exists: ${ref.read(selectedProgressProvider).valueOrNull != null}',
      );
      debugPrint('Module progress count: ${module.progress.length}');
      if (mounted) {
        setState(() {
          _isInitialLoad = false;
        });
      }
    } catch (error) {
      debugPrint('Error loading data: $error');
      if (mounted) {
        setState(() {
          _isInitialLoad = false;
        });
      }
    }
  }
  Future<void> _refreshData() async {
    setState(() {
      _dataFuture = Future.delayed(Duration.zero, _loadData);
    });
    return _dataFuture;
  }
  Future<void> _startLearning() async {
    final moduleId = widget.moduleId;
    if (!_isAuthenticated()) {
      _showLoginSnackBar();
      return;
    }
    final module = ref.read(selectedModuleProvider).valueOrNull;
    if (module == null) return;
    final existingProgress = ref.read(selectedProgressProvider).valueOrNull;
    if (existingProgress != null) {
      _navigateToProgress(existingProgress.id);
      return;
    }
    try {
      final newProgress = await _createNewProgress(moduleId);
      if (newProgress != null && mounted) {
        _navigateToProgress(newProgress.id);
      } else if (mounted) {
        SnackBarUtils.show(context, 'Failed to create progress');
      }
    } catch (error) {
      debugPrint('Error creating progress: $error');
      if (mounted) {
        SnackBarUtils.show(context, 'Error: ${error.toString()}');
      }
    }
  }
  bool _isAuthenticated() {
    final isLoggedIn = ref.watch(authStateProvider).valueOrNull ?? false;
    final currentUser = ref.watch(currentUserProvider);
    return isLoggedIn && currentUser != null;
  }
  void _showLoginSnackBar() {
    if (mounted) {
      SnackBarUtils.show(context, 'Please log in to start learning');
    }
  }
  Future<ProgressDetail?> _createNewProgress(String moduleId) async {
    final currentUser = ref.read(currentUserProvider);
    if (currentUser == null) return null;
    return ref
        .read(progressStateProvider.notifier)
        .createProgress(
          moduleId: moduleId,
          userId: currentUser.id,
          firstLearningDate: DateTime.now(),
          nextStudyDate: DateTime.now(),
        );
  }
  void _navigateToProgress(String progressId) {
    if (!mounted) return;
    if (progressId.isEmpty) {
      SnackBarUtils.show(context, 'Invalid progress ID');
      return;
    }
    NavigationHelper.pushWithResult(
      context,
      '/progress/$progressId',
    ).then((_) => _refreshData()); // Refresh khi quay lại
  }
  @override
  Widget build(BuildContext context) {
    final moduleAsync = ref.watch(selectedModuleProvider);
    final progressAsync = ref.watch(selectedProgressProvider);
    final module = moduleAsync.valueOrNull;
    final bool hasProgress =
        progressAsync.valueOrNull != null ||
        (module?.progress != null && module!.progress.isNotEmpty);
    return Scaffold(
      appBar: AppBar(
        title: Text(module?.title ?? 'Module Details'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _refreshData,
            tooltip: 'Refresh data',
          ),
        ],
      ),
      body: FutureBuilder(
        future: _dataFuture,
        builder: (context, snapshot) {
          if (_isInitialLoad &&
              snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: SLLoadingIndicator());
          }
          if (snapshot.hasError) {
            return Center(
              child: SLErrorView(
                message: 'Error loading data: ${snapshot.error}',
                onRetry: _refreshData,
              ),
            );
          }
          return _buildBody(
            module,
            moduleAsync.isLoading,
            moduleAsync.error?.toString(),
            progressAsync.valueOrNull,
            _refreshData,
            _navigateToProgress,
          );
        },
      ),
      floatingActionButton: module != null && !hasProgress
          ? FloatingActionButton.extended(
              onPressed: _startLearning,
              icon: const Icon(Icons.play_arrow),
              label: const Text('Start Learning'),
            )
          : null,
    );
  }
  Widget _buildBody(
    ModuleDetail? module,
    bool isLoading,
    String? errorMessage,
    ProgressDetail? userProgress,
    Future<void> Function() onRefresh,
    void Function(String) onProgressTap,
  ) {
    if (isLoading) {
      return const Center(child: SLLoadingIndicator());
    }
    if (errorMessage != null) {
      return Center(
        child: SLErrorView(message: errorMessage, onRetry: onRefresh),
      );
    }
    if (module == null) {
      return const Center(child: Text('Module not found'));
    }
    return _buildModuleView(
      context,
      module,
      userProgress,
      onRefresh,
      onProgressTap,
    );
  }
  Widget _buildModuleView(
    BuildContext context,
    ModuleDetail module,
    ProgressDetail? userProgress,
    Future<void> Function() onRefresh,
    void Function(String) onProgressTap,
  ) {
    return RefreshIndicator(
      onRefresh: onRefresh,
      child: ListView(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        children: [
          ModuleHeader(module: module),
          const SizedBox(height: AppDimens.spaceXXL),
          if (userProgress != null) ...[
            ModuleProgressSection(
              progress: userProgress,
              moduleTitle: module.title,
              onTap: onProgressTap,
            ),
            const SizedBox(height: AppDimens.spaceXXL),
          ],
          ModuleContentSection(module: module),
          const SizedBox(height: 80),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/book_detail_tabs.dart
class BookOverviewTab extends StatelessWidget {
  final BookDetail book;
  const BookOverviewTab({super.key, required this.book});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return SingleChildScrollView(
      padding: const EdgeInsets.all(AppDimens.paddingL),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (book.description?.isNotEmpty ?? false) ...[
            Text(
              'Description',
              style: theme.textTheme.titleLarge?.copyWith(
                color: colorScheme.onSurface,
              ),
            ),
            const SizedBox(height: AppDimens.spaceM),
            Text(
              book.description ?? '',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: AppDimens.spaceXL),
          ],
          _buildStatsSection(context),
          const SizedBox(height: AppDimens.spaceXL),
          _buildBookMetadataSection(context),
          const SizedBox(height: AppDimens.spaceXXL),
        ],
      ),
    );
  }
  Widget _buildStatsSection(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final totalWords = book.modules.fold<int>(
      0,
      (total, module) => total + (module.wordCount ?? 0),
    );
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Book Stats',
          style: theme.textTheme.titleLarge?.copyWith(
            color: colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: AppDimens.spaceM),
        Container(
          padding: const EdgeInsets.all(AppDimens.paddingL),
          decoration: BoxDecoration(
            color: colorScheme.surfaceContainerLow,
            borderRadius: BorderRadius.circular(AppDimens.radiusL),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              StatItemWidget(
                value: book.modules.length.toString(),
                label: 'Modules',
                icon: Icons.menu_book,
                color: colorScheme.primary,
              ),
              StatItemWidget(
                value: totalWords.toString(),
                label: 'Words',
                icon: Icons.text_fields,
                color: colorScheme.secondary,
              ),
              StatItemWidget(
                value: book.modules
                    .fold<int>(
                      0,
                      (total, module) => total + (module.progress.length),
                    )
                    .toString(),
                label: 'Students',
                icon: Icons.people,
                color: colorScheme.tertiary,
              ),
            ],
          ),
        ),
      ],
    );
  }
  Widget _buildBookMetadataSection(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Book Details',
          style: theme.textTheme.titleLarge?.copyWith(
            color: colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: AppDimens.spaceM),
        Card(
          elevation: 0,
          color: colorScheme.surfaceContainerLow,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusL),
          ),
          child: Padding(
            padding: const EdgeInsets.all(AppDimens.paddingL),
            child: Column(
              children: [
                MetadataItemWidget(
                  label: 'Status',
                  value: BookFormatter.formatStatus(book.status),
                  icon: Icons.info_outline,
                ),
                if (book.difficultyLevel != null) ...[
                  const SizedBox(height: AppDimens.spaceM),
                  MetadataItemWidget(
                    label: 'Difficulty',
                    value: BookFormatter.formatDifficulty(book.difficultyLevel),
                    icon: Icons.signal_cellular_alt_outlined,
                  ),
                ],
                if (book.category != null) ...[
                  const SizedBox(height: AppDimens.spaceM),
                  MetadataItemWidget(
                    label: 'Category',
                    value: book.category!,
                    icon: Icons.category_outlined,
                  ),
                ],
                if (book.createdAt != null) ...[
                  const SizedBox(height: AppDimens.spaceM),
                  MetadataItemWidget(
                    label: 'Created',
                    value: AppDateUtils.formatDate(book.createdAt!),
                    icon: Icons.calendar_today,
                  ),
                ],
                if (book.updatedAt != null) ...[
                  const SizedBox(height: AppDimens.spaceM),
                  MetadataItemWidget(
                    label: 'Updated',
                    value: AppDateUtils.formatDate(book.updatedAt!),
                    icon: Icons.update,
                  ),
                ],
              ],
            ),
          ),
        ),
      ],
    );
  }
}
class BookModulesTab extends StatelessWidget {
  final List<ModuleSummary> modules;
  final String bookId;
  final VoidCallback onRetry;
  const BookModulesTab({
    super.key,
    required this.modules,
    required this.bookId,
    required this.onRetry,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    if (modules.isEmpty) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.menu_book_outlined,
              size: AppDimens.iconXXL,
              color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
            ),
            const SizedBox(height: AppDimens.spaceL),
            Text(
              'No modules available for this book',
              style: theme.textTheme.titleMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: AppDimens.spaceL),
            TextButton.icon(
              onPressed: onRetry,
              icon: const Icon(Icons.refresh),
              label: const Text('Refresh'),
            ),
          ],
        ),
      );
    }
    return ListView.builder(
      padding: const EdgeInsets.all(AppDimens.paddingL),
      itemCount: modules.length,
      itemBuilder: (context, index) {
        final module = modules[index];
        return ModuleCardWidget(
          module: module,
          index: index,
          onTap: () => _navigateToModuleDetail(context, bookId, module.id),
        );
      },
    );
  }
  void _navigateToModuleDetail(
    BuildContext context,
    String bookId,
    String moduleId,
  ) {
    GoRouter.of(context).push('/books/$bookId/modules/$moduleId');
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/sl_toggle_switch.dart
enum SLToggleSwitchSize { small, medium, large }
enum SLToggleSwitchType { standard, outlined, card }
class SLToggleSwitch extends StatelessWidget {
  final String? title;
  final String? subtitle;
  final bool value;
  final ValueChanged<bool> onChanged;
  final IconData? icon;
  final Color? activeColor;
  final Color? activeTrackColor;
  final Color? inactiveThumbColor;
  final Color? inactiveTrackColor;
  final SLToggleSwitchSize size;
  final SLToggleSwitchType type;
  final bool enabled;
  final VoidCallback? onLongPress;
  final EdgeInsetsGeometry? contentPadding;
  final Widget? leading;
  final Widget? trailing;
  const SLToggleSwitch({
    super.key,
    this.title,
    this.subtitle,
    required this.value,
    required this.onChanged,
    this.icon,
    this.activeColor,
    this.activeTrackColor,
    this.inactiveThumbColor,
    this.inactiveTrackColor,
    this.size = SLToggleSwitchSize.medium,
    this.type = SLToggleSwitchType.standard,
    this.enabled = true,
    this.onLongPress,
    this.contentPadding,
    this.leading,
    this.trailing,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final effectiveActiveColor = activeColor ?? colorScheme.primary;
    final effectiveActiveTrackColor =
        activeTrackColor ??
        effectiveActiveColor.withValues(alpha: AppDimens.opacitySemi);
    final effectiveInactiveThumbColor =
        inactiveThumbColor ?? colorScheme.outline;
    final effectiveInactiveTrackColor =
        inactiveTrackColor ?? colorScheme.surfaceContainerHighest;
    final effectiveLeading =
        leading ??
        (icon != null
            ? Icon(
                icon,
                color: value && enabled
                    ? effectiveActiveColor
                    : effectiveInactiveThumbColor,
                size: _getIconSize(),
              )
            : null);
    final effectivePadding =
        contentPadding ??
        EdgeInsets.symmetric(
          horizontal: _getPaddingHorizontal(),
          vertical: _getPaddingVertical(),
        );
    switch (type) {
      case SLToggleSwitchType.standard:
        return SizedBox(
          width: double.infinity,
          child: SwitchListTile(
            title: title != null
                ? Text(title!, style: _getTitleStyle(theme))
                : null,
            subtitle: subtitle != null
                ? Text(subtitle!, style: _getSubtitleStyle(theme, colorScheme))
                : null,
            value: value && enabled,
            onChanged: enabled ? onChanged : null,
            secondary: effectiveLeading,
            activeColor: effectiveActiveColor,
            activeTrackColor: effectiveActiveTrackColor,
            inactiveThumbColor: effectiveInactiveThumbColor,
            inactiveTrackColor: effectiveInactiveTrackColor,
            contentPadding: effectivePadding,
            dense: size == SLToggleSwitchSize.small,
          ),
        );
      case SLToggleSwitchType.outlined:
        return Container(
          width: double.infinity,
          decoration: BoxDecoration(
            border: Border.all(
              color: value && enabled
                  ? effectiveActiveColor
                  : colorScheme.outlineVariant,
              width: 1.5,
            ),
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
          ),
          child: SwitchListTile(
            title: title != null
                ? Text(title!, style: _getTitleStyle(theme))
                : null,
            subtitle: subtitle != null
                ? Text(subtitle!, style: _getSubtitleStyle(theme, colorScheme))
                : null,
            value: value && enabled,
            onChanged: enabled ? onChanged : null,
            secondary: effectiveLeading,
            activeColor: effectiveActiveColor,
            activeTrackColor: effectiveActiveTrackColor,
            inactiveThumbColor: effectiveInactiveThumbColor,
            inactiveTrackColor: effectiveInactiveTrackColor,
            contentPadding: effectivePadding,
            dense: size == SLToggleSwitchSize.small,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(AppDimens.radiusM),
            ),
          ),
        );
      case SLToggleSwitchType.card:
        return SizedBox(
          width: double.infinity,
          child: Card(
            elevation: AppDimens.elevationS,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(AppDimens.radiusM),
              side: BorderSide(
                color: value && enabled
                    ? effectiveActiveColor.withValues(
                        alpha: AppDimens.opacitySemi,
                      )
                    : Colors.transparent,
                width: 1.5,
              ),
            ),
            color: colorScheme.surfaceContainerLowest,
            child: SwitchListTile(
              title: title != null
                  ? Text(title!, style: _getTitleStyle(theme))
                  : null,
              subtitle: subtitle != null
                  ? Text(
                      subtitle!,
                      style: _getSubtitleStyle(theme, colorScheme),
                    )
                  : null,
              value: value && enabled,
              onChanged: enabled ? onChanged : null,
              secondary: effectiveLeading,
              activeColor: effectiveActiveColor,
              activeTrackColor: effectiveActiveTrackColor,
              inactiveThumbColor: effectiveInactiveThumbColor,
              inactiveTrackColor: effectiveInactiveTrackColor,
              contentPadding: effectivePadding,
              dense: size == SLToggleSwitchSize.small,
            ),
          ),
        );
    }
  }
  TextStyle? _getTitleStyle(ThemeData theme) {
    switch (size) {
      case SLToggleSwitchSize.small:
        return theme.textTheme.bodyMedium?.copyWith(
          fontWeight: FontWeight.w500,
        );
      case SLToggleSwitchSize.medium:
        return theme.textTheme.titleSmall;
      case SLToggleSwitchSize.large:
        return theme.textTheme.titleMedium;
    }
  }
  TextStyle? _getSubtitleStyle(ThemeData theme, ColorScheme colorScheme) {
    switch (size) {
      case SLToggleSwitchSize.small:
        return theme.textTheme.bodySmall?.copyWith(
          color: colorScheme.onSurfaceVariant,
          fontSize: AppDimens.fontXS,
        );
      case SLToggleSwitchSize.medium:
        return theme.textTheme.bodySmall?.copyWith(
          color: colorScheme.onSurfaceVariant,
        );
      case SLToggleSwitchSize.large:
        return theme.textTheme.bodyMedium?.copyWith(
          color: colorScheme.onSurfaceVariant,
        );
    }
  }
  double _getIconSize() {
    switch (size) {
      case SLToggleSwitchSize.small:
        return AppDimens.iconS;
      case SLToggleSwitchSize.medium:
        return AppDimens.iconM;
      case SLToggleSwitchSize.large:
        return AppDimens.iconL;
    }
  }
  double _getPaddingHorizontal() {
    switch (size) {
      case SLToggleSwitchSize.small:
        return AppDimens.paddingS;
      case SLToggleSwitchSize.medium:
        return AppDimens.paddingM;
      case SLToggleSwitchSize.large:
        return AppDimens.paddingL;
    }
  }
  double _getPaddingVertical() {
    switch (size) {
      case SLToggleSwitchSize.small:
        return AppDimens.paddingXS;
      case SLToggleSwitchSize.medium:
        return AppDimens.paddingS;
      case SLToggleSwitchSize.large:
        return AppDimens.paddingM;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/app_drawer.dart
class SLDrawer extends ConsumerWidget {
  const SLDrawer({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final themeMode = ref.watch(themeModeStateProvider);
    final isDarkMode = themeMode == ThemeMode.dark;
    final user = ref.watch(currentUserProvider);
    final userEmail = user?.email ?? 'Not signed in';
    final userName = user?.displayName ?? user?.username ?? 'Guest';
    final isSignedIn = ref.watch(authStateProvider).valueOrNull ?? false;
    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          UserAccountsDrawerHeader(
            decoration: BoxDecoration(color: colorScheme.primary),
            accountName: Text(userName),
            accountEmail: Text(userEmail),
            currentAccountPicture: CircleAvatar(
              backgroundColor: colorScheme.primaryContainer,
              child: Text(
                userName.isNotEmpty ? userName[0].toUpperCase() : 'G',
                style: theme.textTheme.headlineMedium?.copyWith(
                  color: colorScheme.onPrimaryContainer,
                ),
              ),
            ),
          ),
          _buildNavItem(
            context,
            'Home',
            Icons.home,
            () => GoRouter.of(context).go('/'),
            colorScheme,
          ),
          _buildNavItem(
            context,
            'Books Library',
            Icons.book,
            () => GoRouter.of(context).go('/books'),
            colorScheme,
          ),
          _buildNavItem(
            context,
            'Learning Progress',
            Icons.bar_chart,
            () => GoRouter.of(context).go('/learning'),
            colorScheme,
          ),
          _buildNavItem(
            context,
            'Due Progress',
            Icons.calendar_today,
            () => GoRouter.of(context).go('/due-progress'),
            colorScheme,
          ),
          _buildNavItem(
            context,
            'Profile',
            Icons.person,
            () => GoRouter.of(context).go('/profile'),
            colorScheme,
          ),
          const Divider(),
          _buildSettingsItem(context, 'App Settings', [
            _buildSettingTile(
              context,
              'Dark Mode',
              Icons.dark_mode,
              Switch(
                value: isDarkMode,
                onChanged: (_) =>
                    ref.read(themeModeStateProvider.notifier).toggleTheme(),
              ),
              colorScheme,
            ),
            _buildSettingTile(
              context,
              'Reminders',
              Icons.notifications,
              IconButton(
                icon: const Icon(Icons.chevron_right),
                onPressed: () => GoRouter.of(context).go('/settings/reminders'),
              ),
              colorScheme,
              onTap: () {
                Navigator.of(
                  context,
                ).pop(); // Đóng drawer trước khi chuyển hướng
                GoRouter.of(context).go('/settings/reminders');
              },
            ),
            _buildSettingTile(
              context,
              'Check Status',
              Icons.checklist,
              IconButton(
                icon: const Icon(Icons.chevron_right),
                onPressed: () => GoRouter.of(context).go('/task-report'),
              ),
              colorScheme,
              onTap: () {
                Navigator.of(
                  context,
                ).pop(); // Đóng drawer trước khi chuyển hướng
                GoRouter.of(context).go('/task-report');
              },
            ),
          ], colorScheme),
          _buildSettingsItem(context, 'Help & Support', [
            _buildSettingTile(
              context,
              'About Spaced Repetition',
              Icons.help_outline,
              IconButton(
                icon: const Icon(Icons.chevron_right),
                onPressed: () =>
                    GoRouter.of(context).go('/help/spaced-repetition'),
              ),
              colorScheme,
              onTap: () {
                Navigator.of(
                  context,
                ).pop(); // Đóng drawer trước khi chuyển hướng
                GoRouter.of(context).go('/help/spaced-repetition');
              },
            ),
            _buildSettingTile(
              context,
              'App Version',
              Icons.info_outline,
              Text(
                'v1.0.0',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
              colorScheme,
            ),
          ], colorScheme),
          if (isSignedIn) ...[
            const Divider(),
            _buildNavItem(
              context,
              'Logout',
              Icons.logout,
              () async {
                await ref.read(authStateProvider.notifier).logout();
                if (context.mounted) {
                  GoRouter.of(context).go('/login');
                }
              },
              colorScheme,
              isDestructive: true,
            ),
          ],
          const SizedBox(height: AppDimens.spaceXL),
          Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: AppDimens.paddingL,
              vertical: AppDimens.paddingS,
            ),
            child: Text(
              AppConstants.appName,
              style: theme.textTheme.titleMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildNavItem(
    BuildContext context,
    String title,
    IconData icon,
    VoidCallback onTap,
    ColorScheme colorScheme, {
    bool isDestructive = false,
  }) {
    return ListTile(
      leading: Icon(
        icon,
        color: isDestructive ? colorScheme.error : colorScheme.primary,
      ),
      title: Text(
        title,
        style: TextStyle(
          color: isDestructive ? colorScheme.error : colorScheme.onSurface,
        ),
      ),
      onTap: () {
        Navigator.of(context).pop(); // Close drawer
        onTap();
      },
    );
  }
  Widget _buildSettingsItem(
    BuildContext context,
    String title,
    List<Widget> children,
    ColorScheme colorScheme,
  ) {
    return ExpansionTile(
      title: Text(title),
      leading: Icon(Icons.settings, color: colorScheme.primary),
      childrenPadding: const EdgeInsets.only(left: AppDimens.paddingXL),
      children: children,
    );
  }
  Widget _buildSettingTile(
    BuildContext context,
    String title,
    IconData icon,
    Widget trailing,
    ColorScheme colorScheme, {
    VoidCallback? onTap,
  }) {
    return ListTile(
      contentPadding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingM,
      ),
      leading: Icon(icon, color: colorScheme.onSurfaceVariant),
      title: Text(title),
      trailing: trailing,
      dense: true,
      onTap: onTap,
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/learning_help_dialog.dart
class LearningHelpDialog extends ConsumerWidget {
  const LearningHelpDialog({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final size = MediaQuery.of(context).size;
    final bool isSmallScreen = size.width < AppDimens.breakpointS;
    final double maxDialogWidth = isSmallScreen ? size.width * 0.95 : 500.0;
    final double maxDialogHeight = size.height * 0.7;
    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimens.radiusL),
      ),
      elevation: AppDimens.elevationM,
      backgroundColor: colorScheme.surface,
      child: Container(
        constraints: BoxConstraints(
          maxWidth: maxDialogWidth,
          maxHeight: maxDialogHeight,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.all(AppDimens.paddingL),
              child: Row(
                children: [
                  Icon(
                    Icons.help_outline,
                    color: colorScheme.primary,
                    size: AppDimens.iconL,
                  ),
                  const SizedBox(width: AppDimens.spaceS),
                  Expanded(
                    child: Text(
                      'Learning Progress Help',
                      style: theme.textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: colorScheme.onSurface,
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () => Navigator.of(context).pop(),
                    tooltip: 'Close',
                    padding: EdgeInsets.zero,
                    color: colorScheme.onSurfaceVariant,
                  ),
                ],
              ),
            ),
            const Divider(height: AppDimens.dividerThickness),
            Flexible(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(AppDimens.paddingL),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'This screen shows your learning progress across all modules.',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: colorScheme.onSurface,
                      ),
                    ),
                    const SizedBox(height: AppDimens.spaceL),
                    _buildHelpSection(
                      context,
                      'Features',
                      [
                        '• Use the Book filter to view modules from a specific book',
                        '• Use the Date filter to see modules due on a specific date',
                        '• Click on any module to see detailed information',
                        '• The Progress column shows your completion percentage',
                        '• Due dates highlighted in red are approaching soon',
                        '• Export your data using the Export button in the footer',
                      ],
                      icon: Icons.list_alt,
                      iconColor: colorScheme.primary,
                    ),
                    const SizedBox(height: AppDimens.spaceL),
                    _buildHelpSection(
                      context,
                      'Learning Cycles',
                      [
                        for (final cycle in CycleStudied.values)
                          '• ${CycleFormatter.format(cycle)}: ${CycleFormatter.getDescription(cycle)}',
                      ],
                      icon: Icons.repeat,
                      iconColor: colorScheme.secondary,
                    ),
                    const SizedBox(height: AppDimens.spaceL),
                    _buildHelpSection(
                      context,
                      'Tips',
                      [
                        '• Review your learning material according to the spaced repetition schedule',
                        '• Focus on modules that are due soon',
                        '• Complete all repetitions in a cycle before moving to the next one',
                        '• Use the export feature to keep track of your progress over time',
                      ],
                      icon: Icons.lightbulb_outline,
                      iconColor: colorScheme.tertiary,
                    ),
                  ],
                ),
              ),
            ),
            const Divider(height: AppDimens.dividerThickness),
            Padding(
              padding: const EdgeInsets.all(AppDimens.paddingM),
              child: TextButton(
                onPressed: () => Navigator.of(context).pop(),
                style: TextButton.styleFrom(
                  foregroundColor: colorScheme.primary,
                  padding: const EdgeInsets.symmetric(
                    horizontal: AppDimens.paddingL,
                    vertical: AppDimens.paddingM,
                  ),
                ),
                child: const Text('Close'),
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildHelpSection(
    BuildContext context,
    String title,
    List<String> items, {
    IconData? icon,
    Color? iconColor,
  }) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final size = MediaQuery.of(context).size;
    final isCompact = size.width < AppDimens.breakpointXS;
    final effectiveIconColor = iconColor ?? colorScheme.primary;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            if (icon != null) ...[
              Icon(icon, size: AppDimens.iconM, color: effectiveIconColor),
              const SizedBox(width: AppDimens.spaceS),
            ],
            Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
                color: effectiveIconColor,
              ),
            ),
          ],
        ),
        const SizedBox(height: AppDimens.spaceXS),
        ...items.map(
          (item) => Padding(
            padding: EdgeInsets.only(
              bottom: isCompact ? AppDimens.spaceXXS : AppDimens.spaceXS,
              left: isCompact ? 0 : AppDimens.paddingXS,
            ),
            child: Text(
              item,
              style: isCompact
                  ? theme.textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurface.withValues(
                        alpha: AppDimens.opacityHigh,
                      ),
                    )
                  : theme.textTheme.bodyMedium?.copyWith(
                      color: colorScheme.onSurface,
                    ),
            ),
          ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/storage_service.dart
class StorageService {
  final FlutterSecureStorage _secureStorage;
  final Future<SharedPreferences> _prefs;
  StorageService({
    FlutterSecureStorage? secureStorage,
    Future<SharedPreferences>? prefs,
  }) : _secureStorage = secureStorage ?? const FlutterSecureStorage(),
       _prefs = prefs ?? SharedPreferences.getInstance();
  Future<String?> getToken() async {
    try {
      return await _secureStorage.read(key: AppConstants.tokenKey);
    } catch (e) {
      debugPrint('Error retrieving token: $e');
      await clearTokens();
      return null;
    }
  }
  Future<String?> getRefreshToken() async {
    try {
      return await _secureStorage.read(key: AppConstants.refreshTokenKey);
    } catch (e) {
      debugPrint('Error retrieving refresh token: $e');
      await clearTokens();
      return null;
    }
  }
  Future<Map<String, dynamic>?> getUserData() async {
    try {
      final prefs = await _prefs;
      final userData = prefs.getString(AppConstants.userKey);
      if (userData == null) {
        return null;
      }
      return jsonDecode(userData) as Map<String, dynamic>;
    } catch (e) {
      debugPrint('Error retrieving user data: $e');
      return null;
    }
  }
  Future<bool> isDarkMode() async {
    try {
      final prefs = await _prefs;
      return prefs.getBool(AppConstants.darkModeKey) ?? false;
    } catch (e) {
      debugPrint('Error retrieving dark mode setting: $e');
      return false;
    }
  }
  Future<void> saveToken(String token) async {
    try {
      await _secureStorage.write(key: AppConstants.tokenKey, value: token);
    } catch (e) {
      debugPrint('Error saving token: $e');
      await clearTokens();
      try {
        await _secureStorage.write(key: AppConstants.tokenKey, value: token);
      } catch (e) {
        debugPrint('Failed to save token after reset: $e');
        await resetSecureStorage();
      }
    }
  }
  Future<void> saveRefreshToken(String refreshToken) async {
    try {
      await _secureStorage.write(
        key: AppConstants.refreshTokenKey,
        value: refreshToken,
      );
    } catch (e) {
      debugPrint('Error saving refresh token: $e');
      await clearTokens();
      try {
        await _secureStorage.write(
          key: AppConstants.refreshTokenKey,
          value: refreshToken,
        );
      } catch (e) {
        debugPrint('Failed to save refresh token after reset: $e');
        await resetSecureStorage();
      }
    }
  }
  Future<void> saveUserData(Map<String, dynamic> userData) async {
    try {
      final prefs = await _prefs;
      await prefs.setString(AppConstants.userKey, jsonEncode(userData));
    } catch (e) {
      debugPrint('Error saving user data: $e');
    }
  }
  Future<void> saveDarkMode(bool isDarkMode) async {
    try {
      final prefs = await _prefs;
      await prefs.setBool(AppConstants.darkModeKey, isDarkMode);
    } catch (e) {
      debugPrint('Error saving dark mode setting: $e');
    }
  }
  Future<void> clearTokens() async {
    try {
      await _secureStorage.delete(key: AppConstants.tokenKey);
      await _secureStorage.delete(key: AppConstants.refreshTokenKey);
    } catch (e) {
      debugPrint('Error clearing tokens: $e');
      await resetSecureStorage();
    }
  }
  Future<void> clearUserData() async {
    try {
      final prefs = await _prefs;
      await prefs.remove(AppConstants.userKey);
    } catch (e) {
      debugPrint('Error clearing user data: $e');
    }
  }
  Future<void> resetSecureStorage() async {
    try {
      await _secureStorage.deleteAll();
      debugPrint('Reset all secure storage due to cryptographic error');
    } catch (e) {
      debugPrint('Error resetting secure storage: $e');
    }
  }
  Future<String?> getString(String key) async {
    try {
      final prefs = await _prefs;
      return prefs.getString(key);
    } catch (e) {
      debugPrint('Error retrieving string ($key): $e');
      return null;
    }
  }
  Future<void> setString(String key, String value) async {
    try {
      final prefs = await _prefs;
      await prefs.setString(key, value);
    } catch (e) {
      debugPrint('Error setting string ($key): $e');
    }
  }
  Future<bool?> getBool(String key) async {
    try {
      final prefs = await _prefs;
      return prefs.getBool(key);
    } catch (e) {
      debugPrint('Error retrieving boolean ($key): $e');
      return null;
    }
  }
  Future<void> setBool(String key, bool value) async {
    try {
      final prefs = await _prefs;
      await prefs.setBool(key, value);
    } catch (e) {
      debugPrint('Error setting boolean ($key): $e');
    }
  }
  Future<int?> getInt(String key) async {
    try {
      final prefs = await _prefs;
      return prefs.getInt(key);
    } catch (e) {
      debugPrint('Error retrieving int ($key): $e');
      return null;
    }
  }
  Future<void> setInt(String key, int value) async {
    try {
      final prefs = await _prefs;
      await prefs.setInt(key, value);
    } catch (e) {
      debugPrint('Error setting int ($key): $e');
    }
  }
  Future<double?> getDouble(String key) async {
    try {
      final prefs = await _prefs;
      return prefs.getDouble(key);
    } catch (e) {
      debugPrint('Error retrieving double ($key): $e');
      return null;
    }
  }
  Future<void> setDouble(String key, double value) async {
    try {
      final prefs = await _prefs;
      await prefs.setDouble(key, value);
    } catch (e) {
      debugPrint('Error setting double ($key): $e');
    }
  }
  Future<List<String>?> getStringList(String key) async {
    try {
      final prefs = await _prefs;
      return prefs.getStringList(key);
    } catch (e) {
      debugPrint('Error retrieving string list ($key): $e');
      return null;
    }
  }
  Future<void> setStringList(String key, List<String> value) async {
    try {
      final prefs = await _prefs;
      await prefs.setStringList(key, value);
    } catch (e) {
      debugPrint('Error setting string list ($key): $e');
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/app_card.dart
class SLCard extends StatelessWidget {
  final Widget? title;
  final Widget? subtitle;
  final Widget? leading;
  final Widget? trailing;
  final Widget? content;
  final Widget? child;
  final List<Widget>? actions;
  final VoidCallback? onTap;
  final EdgeInsetsGeometry padding;
  final EdgeInsetsGeometry margin;
  final double? elevation;
  final double borderRadius;
  final ShapeBorder? shape;
  final Color? backgroundColor;
  final Color? highlightColor;
  final Color? shadowColor;
  final bool useGradient;
  final LinearGradient? customGradient;
  final bool applyOuterShadow;
  const SLCard({
    super.key,
    this.title,
    this.subtitle,
    this.leading,
    this.trailing,
    this.content,
    this.child,
    this.actions,
    this.onTap,
    this.padding = const EdgeInsets.all(AppDimens.paddingL),
    this.margin = const EdgeInsets.symmetric(vertical: AppDimens.paddingS),
    this.elevation,
    this.borderRadius = AppDimens.radiusL,
    this.shape,
    this.backgroundColor,
    this.highlightColor,
    this.shadowColor,
    this.useGradient = false,
    this.customGradient,
    this.applyOuterShadow = false,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final effectiveBackgroundColor =
        backgroundColor ?? colorScheme.surfaceContainerLowest;
    final effectiveShadowColor = shadowColor ?? colorScheme.shadow;
    final effectiveShape =
        shape ??
        RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(borderRadius),
        );
    final Widget cardContent = Container(
      decoration: useGradient
          ? BoxDecoration(
              gradient:
                  customGradient ??
                  LinearGradient(
                    colors: [
                      colorScheme.surfaceContainerLow,
                      colorScheme.surfaceContainerHigh,
                    ],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
            )
          : null,
      child: InkWell(
        onTap: onTap,
        highlightColor: highlightColor ?? colorScheme.primaryContainer,
        splashColor: colorScheme.primary.withValues(
          alpha: AppDimens.opacitySemi,
        ),
        borderRadius: shape == null
            ? BorderRadius.circular(borderRadius)
            : null,
        customBorder: shape,
        child: child ?? _buildDefaultContent(theme, colorScheme),
      ),
    );
    if (applyOuterShadow) {
      return Container(
        margin: margin,
        decoration: BoxDecoration(
          borderRadius: shape == null
              ? BorderRadius.circular(borderRadius)
              : null,
          boxShadow: [
            BoxShadow(
              color: effectiveShadowColor.withValues(
                alpha: AppDimens.opacitySemi,
              ),
              blurRadius: AppDimens.shadowRadiusL,
              spreadRadius: AppDimens.shadowOffsetS,
              offset: const Offset(0, 3),
            ),
          ],
        ),
        child: Card(
          margin: EdgeInsets.zero,
          elevation: elevation ?? AppDimens.elevationS,
          shape: effectiveShape,
          color: effectiveBackgroundColor,
          clipBehavior: Clip.antiAlias,
          child: cardContent,
        ),
      );
    }
    return Card(
      margin: margin,
      elevation: elevation ?? AppDimens.elevationS,
      shape: effectiveShape,
      color: effectiveBackgroundColor,
      clipBehavior: Clip.antiAlias,
      child: cardContent,
    );
  }
  Widget _buildDefaultContent(ThemeData theme, ColorScheme colorScheme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisAlignment: MainAxisAlignment.center,
      mainAxisSize: MainAxisSize.min,
      children: [
        if (title != null ||
            subtitle != null ||
            leading != null ||
            trailing != null)
          Padding(
            padding: padding,
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                if (leading != null)
                  Padding(
                    padding: const EdgeInsets.only(right: AppDimens.paddingL),
                    child: leading,
                  ),
                if (title != null || subtitle != null)
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        if (title != null)
                          DefaultTextStyle(
                            style: theme.textTheme.titleMedium!.copyWith(
                              color: colorScheme.onSurface,
                            ),
                            child: title!,
                          ),
                        if (title != null && subtitle != null)
                          const SizedBox(height: AppDimens.spaceXS),
                        if (subtitle != null)
                          DefaultTextStyle(
                            style: theme.textTheme.bodyMedium!.copyWith(
                              color: colorScheme.onSurfaceVariant,
                            ),
                            child: subtitle!,
                          ),
                      ],
                    ),
                  ),
                if (trailing != null)
                  Padding(
                    padding: const EdgeInsets.only(left: AppDimens.paddingS),
                    child: trailing,
                  ),
              ],
            ),
          ),
        if (content != null)
          Padding(
            padding:
                title != null ||
                    subtitle != null ||
                    leading != null ||
                    trailing != null
                ? EdgeInsets.only(
                    left: padding is EdgeInsets
                        ? (padding as EdgeInsets).left
                        : AppDimens.paddingL,
                    right: padding is EdgeInsets
                        ? (padding as EdgeInsets).right
                        : AppDimens.paddingL,
                    bottom: padding is EdgeInsets
                        ? (padding as EdgeInsets).bottom
                        : AppDimens.paddingL,
                  )
                : padding,
            child: content,
          ),
        if (actions != null && actions!.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(
              left: AppDimens.paddingS,
              right: AppDimens.paddingS,
              bottom: AppDimens.paddingS,
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: actions!.map((action) {
                final int index = actions!.indexOf(action);
                return Padding(
                  padding: EdgeInsets.only(
                    left: index > 0 ? AppDimens.paddingS : 0,
                  ),
                  child: action,
                );
              }).toList(),
            ),
          ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/progress_viewmodel.dart
@riverpod
class ProgressState extends _$ProgressState {
  @override
  Future<List<ProgressDetail>> build() async {
    final user = ref.read(currentUserProvider);
    if (user == null) return [];
    final result = await ref
        .read(progressRepositoryProvider)
        .getDueProgress(user.id);
    debugPrint('[ProgressState.build] Loaded ${result.length} items');
    return result;
  }
  Future<void> loadDueProgress(
    String userId, {
    DateTime? studyDate,
    int page = 0,
    int size = 20,
  }) async {
    final sanitizedId = StringUtils.sanitizeId(
      userId,
      source: 'ProgressViewModel',
    );
    if (sanitizedId == null) {
      throw Exception('Invalid user ID: Empty ID provided');
    }
    state = const AsyncValue.loading();
    try {
      final result = await ref
          .read(progressRepositoryProvider)
          .getDueProgress(
            sanitizedId,
            studyDate: studyDate,
            page: page,
            size: size,
          );
      debugPrint(
        '[ProgressViewModel] Received ${result.length} records from repository for due progress.',
      );
      state = AsyncValue.data(result);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
  Future<ProgressDetail?> createProgress({
    required String moduleId,
    String? userId,
    DateTime? firstLearningDate,
    CycleStudied? cyclesStudied,
    DateTime? nextStudyDate,
    double? percentComplete,
  }) async {
    final sanitizedModuleId = StringUtils.sanitizeId(
      moduleId,
      source: 'ProgressViewModel',
    );
    if (sanitizedModuleId == null) {
      throw Exception('Invalid module ID: Empty ID provided');
    }
    try {
      debugPrint('Creating progress for moduleId: $sanitizedModuleId');
      final progress = await ref
          .read(progressRepositoryProvider)
          .createProgress(
            moduleId: sanitizedModuleId,
            userId: userId,
            firstLearningDate: firstLearningDate,
            cyclesStudied: cyclesStudied,
            nextStudyDate: nextStudyDate,
            percentComplete: percentComplete,
          );
      if (userId != null) {
        ref
            .read(eventBusProvider)
            .fire(ProgressChangedEvent(userId: userId, hasDueTasks: true));
      }
      debugPrint('Progress created successfully: ${progress.id}');
      return progress;
    } catch (e) {
      debugPrint('Failed to create progress: $e');
      return null;
    }
  }
  Future<ProgressDetail?> updateProgress(
    String id, {
    DateTime? firstLearningDate,
    CycleStudied? cyclesStudied,
    DateTime? nextStudyDate,
    double? percentComplete,
  }) async {
    final sanitizedId = StringUtils.sanitizeId(id, source: 'ProgressViewModel');
    if (sanitizedId == null) {
      throw Exception('Invalid progress ID: Empty ID provided');
    }
    try {
      debugPrint('Updating progress with id: $sanitizedId');
      final progress = await ref
          .read(progressRepositoryProvider)
          .updateProgress(
            sanitizedId,
            firstLearningDate: firstLearningDate,
            cyclesStudied: cyclesStudied,
            nextStudyDate: nextStudyDate,
            percentComplete: percentComplete,
          );
      final userData = await ref.read(storageServiceProvider).getUserData();
      final userId = userData?['id'];
      if (userId != null) {
        ref
            .read(eventBusProvider)
            .fire(
              TaskCompletedEvent(
                userId: userId.toString(),
                progressId: sanitizedId,
              ),
            );
      }
      debugPrint('Progress updated successfully');
      return progress;
    } catch (e) {
      debugPrint('Error updating progress: $e');
      return null;
    }
  }
}
@riverpod
class SelectedProgress extends _$SelectedProgress {
  @override
  Future<ProgressDetail?> build() async {
    return null;
  }
  Future<void> loadProgressDetails(String id) async {
    final sanitizedId = StringUtils.sanitizeId(id, source: 'SelectedProgress');
    if (sanitizedId == null) {
      state = const AsyncValue.data(null);
      return;
    }
    state = const AsyncValue.loading();
    try {
      final progress = await ref
          .read(progressRepositoryProvider)
          .getProgressById(sanitizedId);
      state = AsyncValue.data(progress);
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
    }
  }
  Future<void> loadModuleProgress(String moduleId) async {
    final sanitizedId = StringUtils.sanitizeId(
      moduleId,
      source: 'SelectedProgress',
    );
    if (sanitizedId == null) {
      state = const AsyncValue.data(null);
      return;
    }
    state = const AsyncValue.loading();
    try {
      final progressList = await ref
          .read(progressRepositoryProvider)
          .getProgressByModuleId(sanitizedId, page: 0, size: 1);
      if (progressList.isEmpty) {
        state = const AsyncValue.data(null);
        return;
      }
      final progressId = progressList[0].id;
      debugPrint('Found progress with ID: $progressId for module: $moduleId');
      final progressDetail = await ref
          .read(progressRepositoryProvider)
          .getProgressById(progressId);
      state = AsyncValue.data(progressDetail);
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
    }
  }
  void clearSelectedProgress() {
    state = const AsyncValue.data(null);
  }
}
@riverpod
bool isUpdatingProgress(Ref ref) {
  final progressState = ref.watch(progressStateProvider);
  return progressState.isLoading;
}
@riverpod
List<ProgressDetail> todayDueTasks(Ref ref) {
  final progressList = ref.watch(progressStateProvider).valueOrNull ?? [];
  if (progressList.isEmpty) return [];
  final now = DateTime.now().toUtc();
  final todayUtc = DateTime.utc(now.year, now.month, now.day);
  final dueTasks = progressList.where((progress) {
    final next = progress.nextStudyDate;
    if (next == null) return false;
    final normalized = DateTime.utc(next.year, next.month, next.day);
    final isDue = !normalized.isAfter(todayUtc);
    debugPrint(
      '[todayDueTasksProvider] id=${progress.id} '
      'nextStudyDate=$next normalized=$normalized today=$todayUtc => isDue=$isDue',
    );
    return isDue;
  }).toList();
  debugPrint('[todayDueTasksProvider] Total due tasks: ${dueTasks.length}');
  return dueTasks;
}
@riverpod
Future<List<ProgressDetail>> trackedProgressState(Ref ref) {
  debugPrint(
    '[TrackedProgressState] >>> Triggered build() at ${DateTime.now()}',
  );
  return ref.watch(progressStateProvider.future);
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/learning_filter_bar/learning_filter_bar.dart
class LearningFilterBar extends ConsumerWidget {
  final int totalCount;
  final int dueCount;
  final int completeCount;
  const LearningFilterBar({
    super.key,
    required this.totalCount,
    required this.dueCount,
    required this.completeCount,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedBook = ref.watch(selectedBookFilterProvider);
    final selectedDate = ref.watch(selectedDateFilterProvider);
    final books = ref.watch(
      learningProgressStateProvider.select(
        (value) => value.valueOrNull != null
            ? ref.read(learningProgressStateProvider.notifier).getUniqueBooks()
            : ['All'],
      ),
    );
    return _FilterBarContent(
      selectedBook: selectedBook,
      selectedDate: selectedDate,
      books: books,
      onBookChanged: (book) => ref
          .read(selectedBookFilterProvider.notifier)
          .setSelectedBook(book ?? 'All'),
      onDateSelected: () => _selectDate(context, ref),
      onDateCleared: () =>
          ref.read(selectedDateFilterProvider.notifier).clearDateFilter(),
      totalCount: totalCount,
      dueCount: dueCount,
      completeCount: completeCount,
      hasActiveFilters: selectedBook != 'All' || selectedDate != null,
    );
  }
  Future<void> _selectDate(BuildContext context, WidgetRef ref) async {
    final selectedDate = ref.read(selectedDateFilterProvider);
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: selectedDate ?? DateTime.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime(2030),
      builder: (BuildContext context, Widget? child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: Theme.of(context).colorScheme,
            dialogTheme: DialogThemeData(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(AppDimens.radiusL),
              ),
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null) {
      ref.read(selectedDateFilterProvider.notifier).setSelectedDate(picked);
    }
  }
}
class _FilterBarContent extends StatefulWidget {
  final String selectedBook;
  final DateTime? selectedDate;
  final List<String> books;
  final Function(String?) onBookChanged;
  final Function() onDateSelected;
  final Function() onDateCleared;
  final int totalCount;
  final int dueCount;
  final int completeCount;
  final bool hasActiveFilters;
  const _FilterBarContent({
    required this.selectedBook,
    required this.selectedDate,
    required this.books,
    required this.onBookChanged,
    required this.onDateSelected,
    required this.onDateCleared,
    required this.totalCount,
    required this.dueCount,
    required this.completeCount,
    required this.hasActiveFilters,
  });
  @override
  State<_FilterBarContent> createState() => _FilterBarContentState();
}
class _FilterBarContentState extends State<_FilterBarContent> {
  bool _isExpanded = false;
  @override
  void initState() {
    super.initState();
    _isExpanded = widget.hasActiveFilters;
  }
  @override
  void didUpdateWidget(_FilterBarContent oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.hasActiveFilters != oldWidget.hasActiveFilters) {
      setState(() {
        _isExpanded = widget.hasActiveFilters;
      });
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Card(
      elevation: AppDimens.elevationS,
      margin: const EdgeInsets.symmetric(
        vertical: AppDimens.paddingS,
        horizontal: AppDimens.paddingXS,
      ),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimens.radiusL),
        side: BorderSide(
          color: colorScheme.outlineVariant.withValues(
            alpha: AppDimens.opacityMedium,
          ),
          width: 1.0,
        ),
      ),
      child: Column(
        children: [
          GestureDetector(
            onTap: () {
              setState(() {
                _isExpanded = !_isExpanded;
              });
            },
            child: FilterStatsRow(
              totalCount: widget.totalCount,
              dueCount: widget.dueCount,
              completeCount: widget.completeCount,
              activeFilterCount: _getActiveFilterCount(),
              showFilter: _isExpanded,
              onToggleFilter: () {
                setState(() {
                  _isExpanded = !_isExpanded;
                });
              },
            ),
          ),
          AnimatedContainer(
            duration: const Duration(milliseconds: AppDimens.durationM),
            height: _isExpanded ? null : 0,
            curve: Curves.easeInOut,
            child: ClipRect(
              child: Visibility(
                visible: _isExpanded,
                maintainState: true,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Divider(
                      height: AppDimens.dividerThickness,
                      thickness: AppDimens.dividerThickness,
                    ),
                    Padding(
                      padding: const EdgeInsets.all(AppDimens.paddingM),
                      child: Row(
                        children: [
                          Expanded(
                            child: FilterBookSelector(
                              selectedBook: widget.selectedBook,
                              books: widget.books,
                              onBookChanged: widget.onBookChanged,
                            ),
                          ),
                          const SizedBox(width: AppDimens.spaceM),
                          Expanded(
                            child: FilterDateSelector(
                              selectedDate: widget.selectedDate,
                              onDateSelected: widget.onDateSelected,
                              onDateCleared: widget.onDateCleared,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
  int _getActiveFilterCount() {
    int count = 0;
    if (widget.selectedBook != 'All') count++;
    if (widget.selectedDate != null) count++;
    return count;
  }
}

// D:/workspace/spaced_learning_app/lib/core/theme/app_dimens.dart
class AppDimens {
  static const double paddingXXS = 2.0;
  static const double paddingXS = 4.0;
  static const double paddingS = 8.0;
  static const double paddingM = 12.0;
  static const double paddingL = 16.0;
  static const double paddingXL = 20.0;
  static const double paddingXXL = 24.0;
  static const double paddingXXXL = 32.0;
  static const double paddingSection = 40.0;
  static const double paddingPage = 48.0;
  static const double radiusXXS = 2.0;
  static const double radiusXS = 4.0;
  static const double radiusS = 8.0;
  static const double radiusM = 12.0;
  static const double radiusL = 16.0;
  static const double radiusXL = 20.0;
  static const double radiusXXL = 24.0;
  static const double radiusXXXL = 32.0;
  static const double radiusCircular = 100.0;
  static const double iconXXS = 10.0;
  static const double iconXS = 12.0;
  static const double iconS = 16.0;
  static const double iconM = 20.0;
  static const double iconL = 24.0;
  static const double iconXL = 32.0;
  static const double iconXXL = 48.0;
  static const double iconXXXL = 64.0;
  static const double buttonHeightXS = 24.0;
  static const double buttonHeightS = 28.0;
  static const double buttonHeightM = 36.0;
  static const double buttonHeightL = 48.0;
  static const double buttonHeightXL = 56.0;
  static const double textFieldHeightS = 36.0;
  static const double textFieldHeight = 48.0;
  static const double textFieldHeightL = 56.0;
  static const double appBarHeight = 56.0;
  static const double tabBarHeight = 48.0;
  static const double bottomNavBarHeight = 56.0;
  static const double listTileHeightS = 48.0;
  static const double listTileHeight = 56.0;
  static const double listTileHeightL = 72.0;
  static const double bottomSheetMinHeight = 120.0;
  static const double bottomSheetHeaderHeight = 56.0;
  static const double badgeHeight = 24.0;
  static const double chipHeight = 32.0;
  static const double snackbarHeight = 48.0;
  static const double fabSize = 56.0;
  static const double fabSizeSmall = 40.0;
  static const double dividerThickness = 1.0;
  static const double thickDividerHeight = 4.0;
  static const double buttonMinWidth = 64.0;
  static const double dialogMinWidth = 280.0;
  static const double dialogMaxWidth = 560.0;
  static const double menuMaxWidth = 320.0;
  static const double tooltipMinWidth = 40.0;
  static const double outlineButtonBorderWidth = 1.5; // Added
  static const double tabIndicatorThickness = 3.0; // Added
  static const double elevationNone = 0.0;
  static const double elevationXS = 1.0;
  static const double elevationS = 2.0;
  static const double elevationM = 4.0;
  static const double elevationL = 8.0;
  static const double elevationXL = 16.0;
  static const double elevationXXL = 24.0;
  static const double shadowRadiusS = 2.0;
  static const double shadowRadiusM = 4.0;
  static const double shadowRadiusL = 8.0;
  static const double shadowOffsetS = 1.0;
  static const double shadowOffsetM = 2.0;
  static const double fontXXS = 8.0;
  static const double fontXS = 10.0;
  static const double fontS = 11.0; // labelSmall
  static const double fontM = 12.0; // bodySmall, labelMedium
  static const double fontL = 14.0; // titleSmall, bodyMedium, labelLarge
  static const double fontXL = 16.0; // titleMedium, bodyLarge
  static const double fontXXL = 18.0;
  static const double fontXXXL = 20.0;
  static const double fontTitle = 22.0; // titleLarge
  static const double fontHeadlineS = 24.0; // headlineSmall
  static const double fontHeadlineM = 28.0; // headlineMedium
  static const double fontHeadlineL = 32.0; // headlineLarge
  static const double fontDisplayS = 36.0; // displaySmall
  static const double fontDisplayM = 45.0; // displayMedium
  static const double fontDisplayL = 57.0; // displayLarge
  static const double spaceXXS = 2.0;
  static const double spaceXS = 4.0;
  static const double spaceS = 8.0;
  static const double spaceM = 12.0;
  static const double spaceL = 16.0;
  static const double spaceXL = 24.0;
  static const double spaceXXL = 32.0;
  static const double spaceXXXL = 48.0;
  static const double spaceSectionGap = 40.0;
  static const double spacePageGap = 64.0;
  static const double gridSpacingXS = 2.0;
  static const double gridSpacingS = 4.0;
  static const double gridSpacingM = 8.0;
  static const double gridSpacingL = 16.0;
  static const double gridItemMinWidth = 120.0;
  static const double gridItemMaxWidth = 180.0;
  static const double gridGutter = 16.0;
  static const double avatarSizeXS = 24.0;
  static const double avatarSizeS = 32.0;
  static const double avatarSizeM = 40.0;
  static const double avatarSizeL = 48.0;
  static const double avatarSizeXL = 64.0;
  static const double avatarSizeXXL = 96.0;
  static const double thumbnailSizeS = 80.0;
  static const double thumbnailSizeM = 120.0;
  static const double thumbnailSizeL = 160.0;
  static const int durationXXS = 50;
  static const int durationXS = 100;
  static const int durationS = 200;
  static const int durationM = 300;
  static const int durationL = 500;
  static const int durationXL = 800;
  static const int durationFade = 250;
  static const int durationSlide = 400;
  static const double moduleIndicatorSize = 36.0;
  static const double circularProgressSize = 24.0;
  static const double circularProgressSizeL = 48.0;
  static const double lineProgressHeight = 4.0;
  static const double lineProgressHeightL = 8.0;
  static const double badgeIconPadding = 2.0;
  static const double shimmerHeight = 16.0;
  static const double touchTargetMinSize = 48.0;
  static const double maxContentWidth = 1200.0;
  static const double sideMenuWidth = 280.0;
  static const double compactSideMenuWidth = 80.0;
  static const double bannerHeight = 200.0;
  static const double cardMinHeight = 80.0;
  static const double breakpointXS = 360.0;
  static const double breakpointS = 480.0;
  static const double breakpointM = 768.0;
  static const double breakpointL = 1024.0;
  static const double breakpointXL = 1440.0;
  static const double keyboardInset = 80.0;
  static const double safeAreaTop = 44.0;
  static const double safeAreaBottom = 34.0;
  static const double opacityFull = 1.0; // Added for clarity
  static const double opacityTextSubtle = 0.9; // Added for bodySmall
  static const double opacityVeryHigh = 0.8; // Added for IconTheme
  static const double opacityHigh =
      0.7; // For labelStyle, TabBarTheme unselected
  static const double opacityUnselected =
      0.6; // Added for BottomNavBar unselected
  static const double opacityMediumHigh =
      0.5; // Added for ChipTheme border, hintStyle
  static const double opacitySemi = 0.2; // For ChipTheme selected, Input border
  static const double opacityMedium = 0.12; // For Divider
  static const double opacityLight = 0.04; // For Input fill
  static const double opacityDisabled = 0.38; // Standard disabled opacity
  static const double opacityNone = 0.0; // Added for clarity
  static const double scaleFactorSmall = 0.85; // Cho màn hình nhỏ
  static const double scaleFactorLarge = 1.15; // Cho màn hình lớn
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/report/daily_task_report_screen.dart
class DailyTaskReportScreen extends ConsumerStatefulWidget {
  const DailyTaskReportScreen({super.key});
  @override
  ConsumerState<DailyTaskReportScreen> createState() =>
      _DailyTaskReportScreenState();
}
class _DailyTaskReportScreenState extends ConsumerState<DailyTaskReportScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInitialData();
    });
  }
  Future<void> _loadInitialData() async {
    await ref.read(dailyTaskReportStateProvider.notifier).loadReportData();
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final viewModelState = ref.watch(dailyTaskReportStateProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Daily Task Report'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () {
            final router = GoRouter.of(context);
            if (router.canPop()) {
              router.pop();
              return;
            }
            router.go('/');
          },
          tooltip: 'Back',
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => ref
                .read(dailyTaskReportStateProvider.notifier)
                .loadReportData(),
            tooltip: 'Refresh data',
          ),
        ],
      ),
      body: _buildBody(theme, colorScheme, viewModelState),
      bottomNavigationBar: BottomBarWidget(
        onPerformManualCheck: _handleManualCheck,
        isManualCheckInProgress: ref.watch(isManualCheckInProgressProvider),
      ),
    );
  }
  Widget _buildBody(
    ThemeData theme,
    ColorScheme colorScheme,
    AsyncValue<Map<String, dynamic>> viewModelState,
  ) {
    return viewModelState.when(
      data: (data) {
        final bool isLoading = data['isManualCheckInProgress'] == true;
        if (isLoading && !data.containsKey('isCheckerActive')) {
          return const Center(child: SLLoadingIndicator());
        }
        final errorMessage = data['errorMessage'];
        if (errorMessage != null && !data.containsKey('isCheckerActive')) {
          return Center(
            child: SLErrorView(
              message: errorMessage,
              onRetry: () => ref
                  .read(dailyTaskReportStateProvider.notifier)
                  .loadReportData(),
            ),
          );
        }
        return Stack(
          children: [
            RefreshIndicator(
              onRefresh: () => ref
                  .read(dailyTaskReportStateProvider.notifier)
                  .loadReportData(),
              child: ListView(
                padding: const EdgeInsets.all(AppDimens.paddingL),
                children: [
                  StatusCardWidget(
                    isActive: data['isCheckerActive'] ?? false,
                    onToggle: (value) => ref
                        .read(dailyTaskReportStateProvider.notifier)
                        .toggleChecker(value),
                  ),
                  const SizedBox(height: AppDimens.spaceXL),
                  LastCheckCardWidget(
                    lastCheckTime: data['lastCheckTime'],
                    lastCheckResult: data['lastCheckResult'] ?? false,
                    lastCheckTaskCount: data['lastCheckTaskCount'] ?? 0,
                    lastCheckError: data['lastCheckError'],
                  ),
                  const SizedBox(height: AppDimens.spaceXL),
                  LogCardWidget(
                    logEntries: data['logEntries'] ?? [],
                    onClearLogs: () {
                      ref
                          .read(dailyTaskReportStateProvider.notifier)
                          .clearLogs()
                          .then((_) {
                            SnackBarUtils.show(
                              context,
                              'Logs cleared successfully',
                              backgroundColor: colorScheme.primary,
                            );
                            return ref
                                .read(dailyTaskReportStateProvider.notifier)
                                .loadReportData();
                          });
                    },
                  ),
                ],
              ),
            ),
            if (isLoading && data.containsKey('isCheckerActive'))
              Positioned.fill(
                child: Container(
                  color: Colors.black.withValues(alpha: 0.3),
                  child: const Center(child: CircularProgressIndicator()),
                ),
              ),
          ],
        );
      },
      loading: () => const Center(child: SLLoadingIndicator()),
      error: (error, stackTrace) => Center(
        child: SLErrorView(
          message: error.toString(),
          onRetry: () =>
              ref.read(dailyTaskReportStateProvider.notifier).loadReportData(),
        ),
      ),
    );
  }
  Future<void> _handleManualCheck() async {
    final result = await ref
        .read(dailyTaskReportStateProvider.notifier)
        .performManualCheck();
    if (!mounted) return;
    if (result.isSuccess) {
      SnackBarUtils.show(
        context,
        result.hasDueTasks
            ? 'Found ${result.taskCount} tasks due today'
            : 'No tasks due today',
      );
    } else {
      final currentTheme = Theme.of(context);
      SnackBarUtils.show(
        context,
        'Check failed: ${result.errorMessage ?? "Unknown error"}',
        backgroundColor: currentTheme.colorScheme.errorContainer,
      );
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/repetition_viewmodel.dart
@riverpod
class RepetitionState extends _$RepetitionState {
  @override
  Future<List<Repetition>> build() async {
    return [];
  }
  Future<void> loadRepetitionsByProgressId(String progressId) async {
    final sanitizedId = StringUtils.sanitizeId(
      progressId,
      source: 'RepetitionViewModel',
    );
    if (sanitizedId == null) {
      state = AsyncValue.error(
        'Invalid progress ID: Empty ID provided',
        StackTrace.current,
      );
      return;
    }
    state = const AsyncValue.loading();
    try {
      debugPrint('Loading repetitions for progressId: $sanitizedId');
      final repetitions = await ref
          .read(repetitionRepositoryProvider)
          .getRepetitionsByProgressId(sanitizedId);
      debugPrint('Loaded ${repetitions.length} repetitions');
      if (repetitions.isNotEmpty) {
        for (int i = 0; i < min(repetitions.length, 3); i++) {
          final rep = repetitions[i];
          debugPrint(
            'Repetition $i: ID=${rep.id}, Order=${rep.repetitionOrder}, Status=${rep.status}',
          );
        }
      }
      state = AsyncValue.data(repetitions);
    } catch (e) {
      debugPrint('Failed to load repetitions by progress: $e');
      state = AsyncValue.error(e, StackTrace.current);
    }
  }
  Future<List<Repetition>> createDefaultSchedule(
    String moduleProgressId,
  ) async {
    final sanitizedId = StringUtils.sanitizeId(
      moduleProgressId,
      source: 'RepetitionViewModel',
    );
    if (sanitizedId == null) {
      throw Exception('Invalid progress ID: Empty ID provided');
    }
    try {
      debugPrint('Creating default schedule for progressId: $sanitizedId');
      final schedule = await ref
          .read(repetitionRepositoryProvider)
          .createDefaultSchedule(sanitizedId);
      debugPrint('Created schedule with ${schedule.length} repetitions');
      await loadRepetitionsByProgressId(sanitizedId);
      return schedule;
    } catch (e) {
      debugPrint('Failed to create repetition schedule: $e');
      rethrow;
    }
  }
  Future<Repetition?> updateRepetition(
    String id, {
    RepetitionStatus? status,
    DateTime? reviewDate,
    bool rescheduleFollowing = false,
    double? percentComplete,
  }) async {
    final sanitizedId = StringUtils.sanitizeId(
      id,
      source: 'RepetitionViewModel',
    );
    if (sanitizedId == null) {
      throw Exception('Invalid repetition ID: Empty ID provided');
    }
    try {
      debugPrint('Updating repetition: $sanitizedId');
      debugPrint(
        'Status: $status, ReviewDate: $reviewDate, RescheduleFollowing: $rescheduleFollowing',
      );
      final repetition = await ref
          .read(repetitionRepositoryProvider)
          .updateRepetition(
            sanitizedId,
            status: status,
            reviewDate: reviewDate,
            rescheduleFollowing: rescheduleFollowing,
            percentComplete: percentComplete,
          );
      ref
          .read(selectedRepetitionProvider.notifier)
          .updateSelectedRepetition(repetition);
      final repetitions = state.valueOrNull ?? [];
      final index = repetitions.indexWhere((r) => r.id == sanitizedId);
      if (index >= 0) {
        final updatedList = [...repetitions]
          ..replaceRange(index, index + 1, [repetition]);
        state = AsyncValue.data(updatedList);
      }
      if (rescheduleFollowing) {
        await loadRepetitionsByProgressId(repetition.moduleProgressId);
      }
      debugPrint('Repetition updated successfully');
      return repetition;
    } catch (e) {
      debugPrint('Failed to update repetition: $e');
      return null;
    }
  }
  Future<bool> areAllRepetitionsCompleted(String progressId) async {
    final sanitizedId = StringUtils.sanitizeId(
      progressId,
      source: 'RepetitionViewModel',
    );
    if (sanitizedId == null) {
      throw Exception('Invalid progress ID: Empty ID provided');
    }
    try {
      debugPrint('Checking completion status for progressId: $sanitizedId');
      List<Repetition> repetitionsToCheck;
      final currentData = state.valueOrNull ?? [];
      final bool currentDataValid =
          currentData.isNotEmpty &&
          currentData.first.moduleProgressId == sanitizedId;
      if (!currentDataValid) {
        debugPrint(
          'No cached repetitions for progressId: $sanitizedId, loading from repository',
        );
        repetitionsToCheck = await ref
            .read(repetitionRepositoryProvider)
            .getRepetitionsByProgressId(sanitizedId);
      } else {
        repetitionsToCheck = currentData;
      }
      if (repetitionsToCheck.isEmpty) {
        debugPrint('No repetitions found for this progress');
        return false;
      }
      final totalCount = repetitionsToCheck.length;
      final completedCount = repetitionsToCheck
          .where((r) => r.status == RepetitionStatus.completed)
          .length;
      final isCompleted = completedCount >= totalCount;
      debugPrint(
        'Completion check: $completedCount/$totalCount completed. All completed: $isCompleted',
      );
      return isCompleted;
    } catch (e) {
      debugPrint('Error checking completion status: $e');
      return false;
    }
  }
  void clearRepetitions() {
    state = const AsyncValue.data([]);
    ref.read(selectedRepetitionProvider.notifier).clearSelectedRepetition();
  }
  int min(int a, int b) {
    return a < b ? a : b;
  }
}
@riverpod
class SelectedRepetition extends _$SelectedRepetition {
  @override
  Repetition? build() {
    return null;
  }
  void updateSelectedRepetition(Repetition repetition) {
    state = repetition;
  }
  void clearSelectedRepetition() {
    state = null;
  }
}
@riverpod
String getCycleInfo(Ref ref, CycleStudied cycle) {
  switch (cycle) {
    case CycleStudied.firstTime:
      return 'You are in the first learning cycle. Complete 5 review sessions to move to the next cycle.';
    case CycleStudied.firstReview:
      return 'You are in the first review cycle. Complete all 5 review sessions to proceed.';
    case CycleStudied.secondReview:
      return 'You are in the second review cycle. You\'re doing great!';
    case CycleStudied.thirdReview:
      return 'You are in the third review cycle. You almost have this mastered!';
    case CycleStudied.moreThanThreeReviews:
      return 'You\'ve completed more than 3 review cycles. The knowledge is well reinforced!';
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/help/spaced_repetition_info_screen.dart
class SpacedRepetitionInfoScreen extends ConsumerWidget {
  const SpacedRepetitionInfoScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Scaffold(
      appBar: AppBar(
        title: const Text('Spaced Repetition'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () {
            final router = GoRouter.of(context);
            if (router.canPop()) {
              router.pop();
              return;
            }
            router.go('/');
          },
          tooltip: 'Back',
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'How Spaced Repetition Works',
              style: theme.textTheme.headlineSmall,
            ),
            const SizedBox(height: AppDimens.spaceL),
            Text(
              'Spaced repetition is a learning technique that incorporates increasing intervals of time between subsequent review of previously learned material to exploit the psychological spacing effect.',
              style: theme.textTheme.bodyLarge,
            ),
            const SizedBox(height: AppDimens.spaceL),
            _buildSection(
              context,
              'The Science Behind It',
              'Spaced repetition takes advantage of the psychological spacing effect, which demonstrates that learning is more effective when study sessions are spaced out over time, rather than crammed into a single session. This technique directly addresses the "forgetting curve" - our natural tendency to forget information over time.',
              Icons.psychology,
              colorScheme.onSurfaceVariant,
            ),
            _buildSection(
              context,
              'How It Works In This App',
              'Our app schedules your learning into optimal review intervals. After initial learning, you\'ll review the material at gradually increasing intervals: 1 day, 7 days, 16 days, and 35 days. This schedule is optimized for long-term retention.',
              Icons.schedule,
              colorScheme.primary,
            ),
            Text('Learning Cycles', style: theme.textTheme.titleLarge),
            const SizedBox(height: AppDimens.spaceM),
            _buildCycleTable(context),
            const SizedBox(height: AppDimens.spaceXL),
            _buildSection(
              context,
              'Tips for Effective Learning',
              '• Complete all repetitions in a cycle to maximize learning\n'
                  '• Be consistent with your study schedule\n'
                  '• Actively recall information before checking answers\n'
                  '• Connect new information to things you already know\n'
                  '• Take brief notes during each study session\n'
                  '• Review right before sleep to improve memory consolidation',
              Icons.tips_and_updates,
              colorScheme.tertiary,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildSection(
    BuildContext context,
    String title,
    String content,
    IconData icon,
    Color color,
  ) {
    final theme = Theme.of(context);
    return Container(
      margin: const EdgeInsets.only(bottom: AppDimens.spaceXL),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, color: color),
              const SizedBox(width: AppDimens.spaceM),
              Text(
                title,
                style: theme.textTheme.titleLarge?.copyWith(color: color),
              ),
            ],
          ),
          const SizedBox(height: AppDimens.spaceM),
          Text(content, style: theme.textTheme.bodyMedium),
        ],
      ),
    );
  }
  Widget _buildCycleTable(BuildContext context) {
    final theme = Theme.of(context);
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          children: [
            Row(
              children: [
                Expanded(
                  flex: 2,
                  child: Text(
                    'Cycle',
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                Expanded(
                  flex: 3,
                  child: Text(
                    'Description',
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
            const Divider(height: AppDimens.spaceXL),
            ...CycleStudied.values.map(
              (cycle) => _buildCycleRow(context, cycle),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildCycleRow(BuildContext context, CycleStudied cycle) {
    final theme = Theme.of(context);
    final color = CycleFormatter.getColor(cycle, context);
    return Padding(
      padding: const EdgeInsets.only(bottom: AppDimens.spaceM),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            flex: 2,
            child: Container(
              padding: const EdgeInsets.symmetric(
                horizontal: AppDimens.paddingS,
                vertical: AppDimens.paddingXXS,
              ),
              decoration: BoxDecoration(
                color: color.withValues(alpha: 0.2),
                borderRadius: BorderRadius.circular(AppDimens.radiusS),
                border: Border.all(color: color),
              ),
              child: Text(
                CycleFormatter.format(cycle),
                textAlign: TextAlign.center,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: color,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
          const SizedBox(width: AppDimens.spaceM),
          Expanded(
            flex: 3,
            child: Text(
              CycleFormatter.getDescription(cycle),
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/data/repositories/progress_repository_impl.dart
class ProgressRepositoryImpl implements ProgressRepository {
  final ApiClient _apiClient;
  ProgressRepositoryImpl(this._apiClient);
  @override
  Future<List<ProgressSummary>> getAllProgress({
    int page = 0,
    int size = 20,
  }) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.progress,
        queryParameters: {'page': page, 'size': size},
      );
      if (response['success'] != true || response['content'] == null) {
        return [];
      }
      final List<dynamic> progressList = response['content'];
      return progressList
          .map((item) => ProgressSummary.fromJson(item))
          .toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get progress records: $e');
    }
  }
  @override
  Future<ProgressDetail> getProgressById(String id) async {
    try {
      final response = await _apiClient.get('${ApiEndpoints.progress}/$id');
      if (response['success'] != true || response['data'] == null) {
        throw NotFoundException('Progress not found: ${response['message']}');
      }
      return ProgressDetail.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get progress: $e');
    }
  }
  @override
  Future<List<ProgressSummary>> getProgressByModuleId(
    String moduleId, {
    int page = 0,
    int size = 20,
  }) async {
    try {
      final response = await _apiClient.get(
        '${ApiEndpoints.progress}/module/$moduleId',
        queryParameters: {'page': page, 'size': size},
      );
      if (response['success'] != true || response['content'] == null) {
        return [];
      }
      final List<dynamic> progressList = response['content'];
      return progressList
          .map((item) => ProgressSummary.fromJson(item))
          .toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get progress by module: $e');
    }
  }
  @override
  Future<ProgressDetail?> getCurrentUserProgressByModule(
    String moduleId,
  ) async {
    try {
      final progressList = await getProgressByModuleId(moduleId, size: 1);
      if (progressList.isEmpty) {
        return null;
      }
      return await getProgressById(progressList[0].id);
    } on NotFoundException {
      return null;
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get module progress: $e');
    }
  }
  @override
  Future<List<ProgressDetail>> getDueProgress(
    String userId, {
    DateTime? studyDate,
    int page = 0,
    int size = 20,
  }) async {
    try {
      final Map<String, dynamic> queryParams = {'page': page, 'size': size};
      studyDate ??= DateTime.now();
      queryParams['studyDate'] = _formatDate(studyDate);
      final response = await _apiClient.get(
        ApiEndpoints.dueProgress(userId),
        queryParameters: queryParams,
      );
      if (response is! Map<String, dynamic> || response['content'] is! List) {
        return [];
      }
      final List<dynamic> progressList = response['content'];
      try {
        final parsedList = progressList
            .map((item) {
              if (item is! Map<String, dynamic>) {
                return null;
              }
              return ProgressDetail.fromJson(item);
            })
            .whereType<ProgressDetail>()
            .toList();
        return parsedList;
      } catch (e) {
        throw DataFormatException('Failed to parse progress data: $e');
      }
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get due progress: $e');
    }
  }
  @override
  Future<ProgressDetail> createProgress({
    required String moduleId,
    String? userId,
    DateTime? firstLearningDate,
    CycleStudied? cyclesStudied,
    DateTime? nextStudyDate,
    double? percentComplete,
  }) async {
    try {
      final data = <String, dynamic>{'moduleId': moduleId};
      if (userId != null) {
        data['userId'] = userId;
      }
      if (firstLearningDate != null) {
        data['firstLearningDate'] = _formatDate(firstLearningDate);
      }
      if (cyclesStudied != null) {
        data['cyclesStudied'] = cyclesStudied
            .toString()
            .split('.')
            .last
            .toUpperCase();
      }
      if (nextStudyDate != null) {
        data['nextStudyDate'] = _formatDate(nextStudyDate);
      }
      if (percentComplete != null) {
        data['percentComplete'] = percentComplete;
      }
      final response = await _apiClient.post(ApiEndpoints.progress, data: data);
      if (response['success'] != true || response['data'] == null) {
        throw BadRequestException(
          'Failed to create progress: ${response['message']}',
        );
      }
      return ProgressDetail.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to create progress: $e');
    }
  }
  @override
  Future<ProgressDetail> updateProgress(
    String id, {
    DateTime? firstLearningDate,
    CycleStudied? cyclesStudied,
    DateTime? nextStudyDate,
    double? percentComplete,
  }) async {
    try {
      final data = <String, dynamic>{};
      if (firstLearningDate != null) {
        data['firstLearningDate'] = _formatDate(firstLearningDate);
      }
      if (cyclesStudied != null) {
        data['cyclesStudied'] = cyclesStudied
            .toString()
            .split('.')
            .last
            .toUpperCase();
      }
      if (nextStudyDate != null) {
        data['nextStudyDate'] = _formatDate(nextStudyDate);
      }
      if (percentComplete != null) {
        data['percentComplete'] = percentComplete;
      }
      final response = await _apiClient.put(
        '${ApiEndpoints.progress}/$id',
        data: data,
      );
      if (response['success'] != true || response['data'] == null) {
        throw BadRequestException(
          'Failed to update progress: ${response['message']}',
        );
      }
      return ProgressDetail.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to update progress: $e');
    }
  }
  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/learning/learning_progress_screen.dart
class LearningProgressScreen extends ConsumerStatefulWidget {
  const LearningProgressScreen({super.key});
  @override
  ConsumerState<LearningProgressScreen> createState() =>
      _LearningProgressScreenState();
}
class _LearningProgressScreenState extends ConsumerState<LearningProgressScreen>
    with WidgetsBindingObserver {
  final ScrollController _mainScrollController = ScrollController();
  final ScrollController _moduleListScrollController = ScrollController();
  final ScreenRefreshManager _refreshManager = ScreenRefreshManager();
  bool _isScrolled = false;
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _refreshManager.registerRefreshCallback('/learning', _refreshData);
    _mainScrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initializeViewModel();
    });
  }
  void _onScroll() {
    final isScrolled = _mainScrollController.offset > AppDimens.paddingL;
    if (isScrolled != _isScrolled) {
      setState(() {
        _isScrolled = isScrolled;
      });
    }
  }
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      _refreshData();
    }
  }
  @override
  void dispose() {
    _refreshManager.unregisterRefreshCallback('/learning', _refreshData);
    WidgetsBinding.instance.removeObserver(this);
    _mainScrollController.removeListener(_onScroll);
    _mainScrollController.dispose();
    _moduleListScrollController.dispose();
    super.dispose();
  }
  void _refreshData() {
    _runSafe(() {
      ref.read(learningProgressStateProvider.notifier).loadData();
    });
  }
  void _initializeViewModel() => _runSafe(() {
    ref.read(learningProgressStateProvider.notifier).loadData();
  });
  void _safeRefreshData() => _runSafe(() {
    try {
      ref.read(learningProgressStateProvider.notifier).refreshData();
    } catch (e) {
      _showSnackBar(
        'Failed to refresh data: $e',
        Theme.of(context).colorScheme.error,
        retryAction: _safeRefreshData,
      );
    }
  });
  void _showHelpDialog() {
    showDialog(
      context: context,
      builder: (context) => const LearningHelpDialog(),
    );
  }
  void _showSnackBar(
    String message,
    Color backgroundColor, {
    VoidCallback? retryAction,
    Duration? duration,
  }) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: backgroundColor,
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimens.radiusL),
        ),
        margin: const EdgeInsets.all(AppDimens.paddingL),
        duration: duration ?? const Duration(seconds: 4),
        action: retryAction != null
            ? SnackBarAction(
                label: 'Retry',
                onPressed: retryAction,
                textColor: Colors.white,
              )
            : null,
      ),
    );
  }
  @override
  Widget build(BuildContext context) {
    final modulesAsync = ref.watch(learningProgressStateProvider);
    return Scaffold(
      body: CustomScrollView(
        controller: _mainScrollController,
        physics: const AlwaysScrollableScrollPhysics(),
        slivers: [
          LearningAppBar(
            isScrolled: _isScrolled,
            onRefresh: _safeRefreshData,
            onHelp: _showHelpDialog,
          ),
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.symmetric(
                horizontal: AppDimens.paddingM,
                vertical: AppDimens.paddingS,
              ),
              child: _buildFilterBar(),
            ),
          ),
          SliverFillRemaining(
            hasScrollBody: true,
            child: modulesAsync.when(
              data: (modules) => Padding(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimens.paddingM,
                ),
                child: ModuleList(
                  modules: ref.watch(filteredModulesProvider),
                  scrollController: _moduleListScrollController,
                  onRefresh: _refreshData,
                ),
              ),
              loading: () => const Center(
                child: Padding(
                  padding: EdgeInsets.all(AppDimens.paddingL),
                  child: CircularProgressIndicator(),
                ),
              ),
              error: (error, stackTrace) => LearningErrorView(
                errorMessage: error.toString(),
                onRetry: _safeRefreshData,
              ),
            ),
          ),
        ],
      ),
      floatingActionButton: AnimatedOpacity(
        opacity: _isScrolled ? 1.0 : 0.0,
        duration: const Duration(milliseconds: AppDimens.durationS),
        child: FloatingActionButton(
          onPressed: () {
            _mainScrollController.animateTo(
              0,
              duration: const Duration(milliseconds: AppDimens.durationM),
              curve: Curves.easeOut,
            );
          },
          mini: true,
          child: const Icon(Icons.arrow_upward),
        ),
      ),
    );
  }
  Widget _buildFilterBar() {
    return Consumer(
      builder: (context, ref, _) {
        final filteredModules = ref.watch(filteredModulesProvider);
        final dueCount = ref.watch(dueModulesCountProvider);
        final completedCount = ref.watch(completedModulesCountProvider);
        return LearningFilterBar(
          totalCount: filteredModules.length,
          dueCount: dueCount,
          completeCount: completedCount,
        );
      },
    );
  }
  void _runSafe(VoidCallback block) {
    if (!mounted) return;
    Future.microtask(block);
  }
}

// D:/workspace/spaced_learning_app/.dart_tool/flutter_build/dart_plugin_registrant.dart
@pragma('vm:entry-point')
class _PluginRegistrant {
  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        AndroidFlutterLocalNotificationsPlugin.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
    } else if (Platform.isIOS) {
      try {
        IOSFlutterLocalNotificationsPlugin.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
    } else if (Platform.isLinux) {
      try {
        DeviceInfoPlusLinuxPlugin.registerWith();
      } catch (err) {
        print(
          '`device_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        LinuxFlutterLocalNotificationsPlugin.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
    } else if (Platform.isMacOS) {
      try {
        MacOSFlutterLocalNotificationsPlugin.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
    } else if (Platform.isWindows) {
      try {
        DeviceInfoPlusWindowsPlugin.registerWith();
      } catch (err) {
        print(
          '`device_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        FlutterLocalNotificationsWindows.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        FlutterSecureStorageWindows.registerWith();
      } catch (err) {
        print(
          '`flutter_secure_storage_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/compact_repetition_list.dart
class CompactRepetitionList extends ConsumerWidget {
  final String progressId;
  final CycleStudied currentCycleStudied;
  final Future<void> Function(String) onMarkCompleted;
  final Future<void> Function(String, DateTime, bool) onReschedule;
  final Future<void> Function() onReload;
  const CompactRepetitionList({
    super.key,
    required this.progressId,
    required this.currentCycleStudied,
    required this.onMarkCompleted,
    required this.onReschedule,
    required this.onReload,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final repetitionsState = ref.watch(repetitionStateProvider);
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return repetitionsState.when(
      data: (repetitions) {
        if (repetitions.isEmpty) {
          return _buildEmptyState(context, ref, colorScheme);
        }
        return _buildContent(context, repetitions, colorScheme);
      },
      loading: () => _buildLoadingState(theme, colorScheme),
      error: (error, stackTrace) => SLErrorView(
        message: error.toString(),
        onRetry: () => ref
            .read(repetitionStateProvider.notifier)
            .loadRepetitionsByProgressId(progressId),
        compact: true,
      ),
    );
  }
  Widget _buildContent(
    BuildContext context,
    List<Repetition> repetitions,
    ColorScheme colorScheme,
  ) {
    final notStarted =
        repetitions
            .where((r) => r.status == RepetitionStatus.notStarted)
            .toList()
          ..sort(
            (a, b) =>
                a.repetitionOrder.index.compareTo(b.repetitionOrder.index),
          );
    final completed =
        repetitions
            .where((r) => r.status == RepetitionStatus.completed)
            .toList()
          ..sort(RepetitionUtils.compareReviewDates);
    final notStartedByCycle = RepetitionUtils.groupByCycle(notStarted);
    final completedByCycle = RepetitionUtils.groupByCycle(completed);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (notStarted.isNotEmpty)
          StatusSection(
            title: 'Pending Tasks',
            icon: Icons.assignment_outlined,
            containerColor: colorScheme.primary,
            textColor: colorScheme.primary,
            cycleGroups: notStartedByCycle,
            isHistory: false,
            currentCycleStudied: currentCycleStudied,
            onMarkCompleted: onMarkCompleted,
            onReschedule: onReschedule,
          ),
        if (completed.isNotEmpty)
          StatusSection(
            title: 'Completed Tasks',
            icon: Icons.check_circle_outline,
            containerColor: colorScheme.success,
            textColor: colorScheme.success,
            cycleGroups: completedByCycle,
            isHistory: true,
            currentCycleStudied: currentCycleStudied,
            onMarkCompleted: null,
            onReschedule: null,
          ),
      ],
    );
  }
  Widget _buildLoadingState(ThemeData theme, ColorScheme colorScheme) {
    return Container(
      height: 160,
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(color: colorScheme.primary),
            const SizedBox(height: 12),
            Text(
              'Loading repetitions...',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurface,
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildEmptyState(
    BuildContext context,
    WidgetRef ref,
    ColorScheme colorScheme,
  ) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.all(AppDimens.paddingXL),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(AppDimens.radiusL),
        border: Border.all(color: colorScheme.outlineVariant, width: 1.5),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: const EdgeInsets.all(AppDimens.paddingL),
            decoration: BoxDecoration(
              color: colorScheme.primary.withValues(alpha: 0.1),
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.schedule,
              size: 64,
              color: colorScheme.primary.withValues(alpha: 0.7),
            ),
          ),
          const SizedBox(height: AppDimens.spaceL),
          Text(
            'No Review Schedule Yet',
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
              color: colorScheme.onSurface,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: AppDimens.spaceM),
          Text(
            'Create a review schedule to start the spaced repetition learning process',
            style: theme.textTheme.bodyLarge?.copyWith(
              color: colorScheme.onSurfaceVariant,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: AppDimens.spaceXL),
          SLButton(
            text: 'Create Review Schedule',
            type: SLButtonType.primary,
            prefixIcon: Icons.add_circle_outline,
            onPressed: () async {
              await ref
                  .read(repetitionStateProvider.notifier)
                  .createDefaultSchedule(progressId);
              await onReload();
            },
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/auth/login_screen.dart
class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});
  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}
class _LoginScreenState extends ConsumerState<LoginScreen> {
  final TextEditingController _usernameOrEmailController =
      TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  String? _usernameOrEmailError;
  String? _passwordError;
  @override
  void dispose() {
    _usernameOrEmailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }
  void _validateUsernameOrEmail() {
    setState(() {
      _usernameOrEmailError = _usernameOrEmailController.text.isEmpty
          ? 'Username or email is required'
          : null;
    });
  }
  void _validatePassword() {
    setState(() {
      _passwordError = _passwordController.text.isEmpty
          ? 'Password is required'
          : _passwordController.text.length < 8
          ? 'Password must be at least 8 characters'
          : null;
    });
  }
  Future<void> _login() async {
    _validateUsernameOrEmail();
    _validatePassword();
    if (_usernameOrEmailError == null && _passwordError == null) {
      final authNotifier = ref.read(authStateProvider.notifier);
      final success = await authNotifier.login(
        _usernameOrEmailController.text,
        _passwordController.text,
      );
      if (success &&
          mounted &&
          ref.read(authStateProvider).valueOrNull == true) {
        GoRouter.of(context).go('/');
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final authState = ref.watch(authStateProvider);
    final authError = ref.watch(authErrorProvider);
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      body: LoadingOverlay(
        isLoading: authState.isLoading,
        color: theme.colorScheme.surfaceContainerHighest,
        child: SafeArea(
          child: Center(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(24.0),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    _buildHeader(theme),
                    _buildSLErrorView(authError, theme),
                    _buildFormFields(theme),
                    _buildActions(authState.isLoading, theme),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildHeader(ThemeData theme) {
    return Column(
      children: [
        Text(
          AppConstants.appName,
          style: theme.textTheme.headlineMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: theme.colorScheme.primary,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        Text(
          'Login to your account',
          style: theme.textTheme.titleMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 32),
      ],
    );
  }
  Widget _buildSLErrorView(String? errorMessage, ThemeData theme) {
    return errorMessage != null
        ? Column(
            children: [
              SLErrorView(
                message: errorMessage,
                compact: true,
                onRetry: () =>
                    ref.read(authErrorProvider.notifier).clearError(),
              ),
              const SizedBox(height: 16),
            ],
          )
        : const SizedBox.shrink();
  }
  Widget _buildFormFields(ThemeData theme) {
    return Column(
      children: [
        SLTextField(
          label: 'Username or Email',
          hint: 'Enter your username or email',
          controller: _usernameOrEmailController,
          keyboardType: TextInputType.text,
          errorText: _usernameOrEmailError,
          prefixIcon: Icons.person,
          onChanged: (_) => _usernameOrEmailError = null,
          onEditingComplete: _validateUsernameOrEmail,
        ),
        const SizedBox(height: 16),
        SLPasswordField(
          label: 'Password',
          hint: 'Enter your password',
          controller: _passwordController,
          errorText: _passwordError,
          prefixIcon: Icon(Icons.lock, color: theme.iconTheme.color),
          onChanged: (_) => _passwordError = null,
          onEditingComplete: _validatePassword,
        ),
      ],
    );
  }
  Widget _buildActions(bool isLoading, ThemeData theme) {
    return Column(
      children: [
        const SizedBox(height: 24),
        SLButton(
          text: 'Login',
          onPressed: _login,
          isLoading: isLoading,
          isFullWidth: true,
        ),
        const SizedBox(height: 16),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              "Don't have an account? ",
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
            TextButton(
              onPressed: () => Navigator.of(
                context,
              ).push(MaterialPageRoute(builder: (_) => const RegisterScreen())),
              child: const Text('Register'),
            ),
          ],
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/platform/device_settings_service.dart
class DeviceSettingsService {
  static const MethodChannel _channel = MethodChannel(
    'com.example.spaced_learning_app.device/optimization',
  );
  bool get isAndroid {
    if (kIsWeb) return false;
    try {
      return defaultTargetPlatform == TargetPlatform.android;
    } catch (e) {
      debugPrint('Error checking platform: $e');
      return false;
    }
  }
  Future<bool> hasExactAlarmPermission() async {
    if (!isAndroid) {
      return true; // Mặc định true cho các platform khác Android
    }
    try {
      final bool hasPermission = await _channel.invokeMethod(
        'hasExactAlarmPermission',
      );
      return hasPermission;
    } on PlatformException catch (e) {
      debugPrint('Error checking exact alarm permission: ${e.message}');
      return false;
    } on MissingPluginException {
      debugPrint('Device optimization plugin not available');
      return false;
    } catch (e) {
      debugPrint('Unexpected error checking exact alarm permission: $e');
      return false;
    }
  }
  Future<bool> isIgnoringBatteryOptimizations() async {
    if (!isAndroid) {
      return true; // Mặc định true cho các platform khác Android
    }
    try {
      final bool isIgnoring = await _channel.invokeMethod(
        'isIgnoringBatteryOptimizations',
      );
      return isIgnoring;
    } on PlatformException catch (e) {
      debugPrint('Error checking battery optimization status: ${e.message}');
      return false;
    } on MissingPluginException {
      debugPrint('Device optimization plugin not available');
      return false;
    } catch (e) {
      debugPrint('Unexpected error checking battery optimization: $e');
      return false;
    }
  }
  Future<bool> requestExactAlarmPermission() async {
    if (!isAndroid) {
      return true; // Mặc định true cho các platform khác Android
    }
    try {
      final bool result = await _channel.invokeMethod(
        'requestExactAlarmPermission',
      );
      return result;
    } on PlatformException catch (e) {
      debugPrint('Error requesting exact alarm permission: ${e.message}');
      return false;
    } on MissingPluginException {
      debugPrint('Device optimization plugin not available');
      return false;
    } catch (e) {
      debugPrint('Unexpected error requesting exact alarm permission: $e');
      return false;
    }
  }
  Future<bool> requestBatteryOptimization() async {
    if (!isAndroid) {
      return true; // Mặc định true cho các platform khác Android
    }
    try {
      final bool result = await _channel.invokeMethod(
        'requestBatteryOptimization',
      );
      return result;
    } on PlatformException catch (e) {
      debugPrint('Error requesting battery optimization: ${e.message}');
      return false;
    } on MissingPluginException {
      debugPrint('Device optimization plugin not available');
      return false;
    } catch (e) {
      debugPrint('Unexpected error requesting battery optimization: $e');
      return false;
    }
  }
  Future<bool> disableSleepingApps() async {
    if (!isAndroid) {
      return true; // Mặc định true cho các platform khác Android
    }
    try {
      final bool result = await _channel.invokeMethod('disableSleepingApps');
      return result;
    } on PlatformException catch (e) {
      debugPrint('Error disabling sleeping apps: ${e.message}');
      return false;
    } on MissingPluginException {
      debugPrint('Device optimization plugin not available');
      return false;
    } catch (e) {
      debugPrint('Unexpected error disabling sleeping apps: $e');
      return false;
    }
  }
  Future<Map<String, dynamic>> getDeviceInfo() async {
    if (!isAndroid) {
      return {
        'sdkVersion': 0,
        'manufacturer': defaultTargetPlatform.toString(),
        'model': 'Unknown',
      };
    }
    try {
      final Map<dynamic, dynamic> info = await _channel.invokeMethod(
        'getDeviceInfo',
      );
      return Map<String, dynamic>.from(info);
    } on PlatformException catch (e) {
      debugPrint('Error getting device info: ${e.message}');
      return {'sdkVersion': 0, 'manufacturer': 'Unknown', 'model': 'Unknown'};
    } on MissingPluginException {
      debugPrint('Device optimization plugin not available');
      return {'sdkVersion': 0, 'manufacturer': 'Unknown', 'model': 'Unknown'};
    } catch (e) {
      debugPrint('Unexpected error getting device info: $e');
      return {'sdkVersion': 0, 'manufacturer': 'Unknown', 'model': 'Unknown'};
    }
  }
}
@riverpod
class DeviceSettings extends _$DeviceSettings {
  @override
  Future<Map<String, dynamic>> build() async {
    final deviceSettingsService = ref.watch(deviceSettingsServiceProvider);
    final Map<String, dynamic> settings = {
      'isAndroid': deviceSettingsService.isAndroid,
    };
    if (deviceSettingsService.isAndroid) {
      settings['isIgnoringBatteryOptimizations'] = await deviceSettingsService
          .isIgnoringBatteryOptimizations();
      settings['hasExactAlarmPermission'] = await deviceSettingsService
          .hasExactAlarmPermission();
      settings['deviceInfo'] = await deviceSettingsService.getDeviceInfo();
    }
    return settings;
  }
  Future<bool> requestBatteryOptimization() async {
    final deviceSettingsService = ref.read(deviceSettingsServiceProvider);
    final result = await deviceSettingsService.requestBatteryOptimization();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
  Future<bool> requestExactAlarmPermission() async {
    final deviceSettingsService = ref.read(deviceSettingsServiceProvider);
    final result = await deviceSettingsService.requestExactAlarmPermission();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
  Future<bool> disableSleepingApps() async {
    final deviceSettingsService = ref.read(deviceSettingsServiceProvider);
    final result = await deviceSettingsService.disableSleepingApps();
    if (result) {
      ref.invalidateSelf();
    }
    return result;
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/cycle_group_card.dart
class CycleGroupCard extends StatelessWidget {
  final String cycleKey;
  final List<Repetition> repetitions;
  final bool isHistory;
  final CycleStudied currentCycleStudied;
  final Future<void> Function(String)? onMarkCompleted;
  final Future<void> Function(String, DateTime, bool)? onReschedule;
  const CycleGroupCard({
    super.key,
    required this.cycleKey,
    required this.repetitions,
    required this.isHistory,
    required this.currentCycleStudied,
    this.onMarkCompleted,
    this.onReschedule,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final isCurrentCycle = RepetitionUtils.isCurrentCycle(
      repetitions,
      currentCycleStudied,
    );
    final cycleNumber = int.tryParse(cycleKey.replaceAll('Cycle ', '')) ?? 1;
    final cycleName = isCurrentCycle
        ? currentCycleStudied
        : CycleFormatter.mapNumberToCycleStudied(cycleNumber);
    final baseCycleColor = CycleFormatter.getColor(cycleName, context);
    final cycleColor = isHistory
        ? baseCycleColor.withValues(alpha: AppDimens.opacityVeryHigh)
        : isCurrentCycle
        ? baseCycleColor
        : baseCycleColor.withValues(alpha: AppDimens.opacityVeryHigh);
    if (!isHistory) {
      repetitions.sort(
        (a, b) => a.repetitionOrder.index.compareTo(b.repetitionOrder.index),
      );
    }
    final borderColor = isHistory
        ? cycleColor.withValues(alpha: AppDimens.opacitySemi)
        : isCurrentCycle
        ? cycleColor
        : cycleColor.withValues(alpha: AppDimens.opacitySemi);
    final backgroundColor = isHistory
        ? colorScheme.surfaceContainerLowest
        : isCurrentCycle
        ? cycleColor.withValues(alpha: 0.05)
        : colorScheme.surfaceContainerLowest;
    return Padding(
      padding: const EdgeInsets.only(bottom: AppDimens.spaceM),
      child: Card(
        elevation: 0,
        margin: EdgeInsets.zero,
        color: backgroundColor,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimens.radiusM),
          side: BorderSide(
            color: borderColor,
            width: isCurrentCycle ? 1.5 : 1.0,
          ),
        ),
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingM),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildCycleHeader(
                theme,
                isHistory,
                isCurrentCycle,
                cycleColor,
                cycleName,
                colorScheme,
              ),
              Divider(
                height: AppDimens.spaceL,
                thickness: 1,
                color: borderColor.withValues(alpha: 0.3),
              ),
              ...repetitions.map(
                (repetition) => RepetitionCard(
                  repetition: repetition,
                  isHistory: isHistory,
                  onMarkCompleted: isHistory
                      ? null
                      : () => onMarkCompleted?.call(repetition.id),
                  onReschedule: isHistory
                      ? null
                      : (currentDate) => onReschedule?.call(
                          repetition.id,
                          currentDate,
                          false,
                        ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildCycleHeader(
    ThemeData theme,
    bool isHistory,
    bool isCurrentCycle,
    Color cycleColor,
    CycleStudied cycleName,
    ColorScheme colorScheme,
  ) {
    return Row(
      children: [
        Container(
          padding: const EdgeInsets.all(AppDimens.paddingXS),
          decoration: BoxDecoration(
            color: cycleColor.withValues(alpha: 0.1),
            shape: BoxShape.circle,
          ),
          child: Icon(
            CycleFormatter.getIcon(cycleName),
            size: AppDimens.iconM,
            color: cycleColor,
          ),
        ),
        const SizedBox(width: AppDimens.spaceS),
        Text(
          CycleFormatter.format(cycleName),
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: isCurrentCycle ? FontWeight.bold : FontWeight.w500,
            color: cycleColor,
          ),
        ),
        const SizedBox(width: AppDimens.spaceM),
        if (isCurrentCycle) _buildCurrentCycleBadge(colorScheme),
        if (isHistory) _buildCompletedBadge(colorScheme),
      ],
    );
  }
  Widget _buildCurrentCycleBadge(ColorScheme colorScheme) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingM,
        vertical: AppDimens.paddingXXS,
      ),
      decoration: BoxDecoration(
        color: Colors.amber,
        borderRadius: BorderRadius.circular(AppDimens.radiusXL),
      ),
      child: const Text(
        'CURRENT',
        style: TextStyle(
          color: Colors.black,
          fontWeight: FontWeight.bold,
          fontSize: 12,
        ),
      ),
    );
  }
  Widget _buildCompletedBadge(ColorScheme colorScheme) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingM,
        vertical: AppDimens.paddingXXS,
      ),
      decoration: BoxDecoration(
        color: colorScheme.success,
        borderRadius: BorderRadius.circular(AppDimens.radiusXL),
      ),
      child: Text(
        'COMPLETED',
        style: TextStyle(
          color: colorScheme.onSuccess,
          fontWeight: FontWeight.bold,
          fontSize: 12,
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/profile/profile_screen.dart
class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({super.key});
  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}
class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  final _displayNameController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  bool _isEditing = false;
  @override
  void initState() {
    super.initState();
    _runSafe(_loadUserData);
  }
  @override
  void dispose() {
    _displayNameController.dispose();
    super.dispose();
  }
  Future<void> _loadUserData() async {
    await ref.read(userStateProvider.notifier).loadCurrentUser();
    if (mounted) {
      final currentUser = ref.read(userStateProvider).valueOrNull;
      if (currentUser != null) {
        _displayNameController.text = currentUser.displayName ?? '';
      }
    }
  }
  Future<void> _updateProfile() async {
    if (!(_formKey.currentState?.validate() ?? false)) return;
    final success = await ref
        .read(userStateProvider.notifier)
        .updateProfile(displayName: _displayNameController.text.trim());
    if (!mounted) return;
    if (success) {
      await _loadUserData();
      setState(() => _isEditing = false);
      _showSnackBar('Profile updated successfully', Colors.green);
    } else {
      _showSnackBar('Failed to update profile', Colors.red);
    }
  }
  Future<void> _logout() async {
    await ref.read(authStateProvider.notifier).logout();
    if (!mounted) return;
    if (!(ref.read(authStateProvider).valueOrNull ?? false)) {
      NavigationHelper.clearStackAndGo(context, '/login');
    }
  }
  void _toggleEditing() {
    setState(() {
      _isEditing = !_isEditing;
      if (!_isEditing) _resetForm();
    });
  }
  void _resetForm() {
    final currentUser = ref.read(userStateProvider).valueOrNull;
    if (currentUser != null) {
      _displayNameController.text = currentUser.displayName ?? '';
    }
  }
  void _showSnackBar(String msg, Color color) {
    if (!mounted) return;
    SnackBarUtils.show(context, msg, backgroundColor: color);
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Scaffold(
      backgroundColor: colorScheme.surface,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.transparent,
        centerTitle: true,
        title: Text(
          'User Profile',
          style: theme.textTheme.headlineSmall?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: colorScheme.onSurface),
          onPressed: () {
            final router = GoRouter.of(context);
            if (router.canPop()) {
              router.pop();
              return;
            }
            router.go('/');
          },
          tooltip: 'Back',
        ),
      ),
      body: SafeArea(
        child: RefreshIndicator(
          onRefresh: _loadUserData,
          child: _buildContent(),
        ),
      ),
    );
  }
  Widget _buildContent() {
    final authState = ref.watch(authStateProvider);
    final user = authState.valueOrNull == true
        ? ref.watch(currentUserProvider)
        : null;
    if (user == null) {
      return const ProfileLoginPrompt();
    }
    final userStateAsync = ref.watch(userStateProvider);
    return userStateAsync.when(
      data: (currentUser) {
        final effectiveUser = currentUser ?? user;
        return _buildProfileContent(effectiveUser);
      },
      loading: () => const Center(child: SLLoadingIndicator()),
      error: (error, stack) => SLErrorView(
        message: error.toString(),
        onRetry: () {
          ref.read(userStateProvider.notifier).clearError();
          _runSafe(_loadUserData);
        },
        compact: true,
      ),
    );
  }
  Widget _buildProfileContent(user) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return ListView(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingL,
        vertical: AppDimens.spaceL,
      ),
      children: [
        ProfileHeader(user: user),
        const SizedBox(height: AppDimens.spaceXL),
        _isEditing
            ? ProfileEditForm(
                controller: _displayNameController,
                formKey: _formKey,
                onCancel: _toggleEditing,
                onSave: _updateProfile,
              )
            : ProfileInfoCard(user: user, onEditPressed: _toggleEditing),
        const SizedBox(height: AppDimens.spaceXL),
        const ThemeToggleCard(),
        const SizedBox(height: AppDimens.spaceXL),
        SLButton(
          text: 'Logout',
          type: SLButtonType.outline,
          prefixIcon: Icons.logout,
          isFullWidth: true,
          backgroundColor: colorScheme.surfaceContainerHighest,
          textColor: colorScheme.error,
          borderColor: colorScheme.error.withValues(alpha: 0.3),
          onPressed: _logout,
        ),
        const SizedBox(height: AppDimens.spaceXXL),
      ],
    );
  }
  void _runSafe(VoidCallback cb) {
    if (!mounted) return;
    Future.microtask(cb);
  }
}

// D:/workspace/spaced_learning_app/lib/core/extensions/color_extensions.dart
extension ColorExtensions on Color {
  Color withValues({int? red, int? green, int? blue, double? alpha}) {
    return Color.fromRGBO(
      red ?? (r * 255.0).round() & 0xff,
      green ?? (g * 255.0).round() & 0xff,
      blue ?? (b * 255.0).round() & 0xff,
      alpha ?? a,
    );
  }
  Color lighten([double amount = 0.1]) {
    assert(amount >= 0 && amount <= 1);
    final hsl = HSLColor.fromColor(this);
    final lightness = (hsl.lightness + amount).clamp(0.0, 1.0);
    return hsl.withLightness(lightness).toColor();
  }
  Color darken([double amount = 0.1]) {
    assert(amount >= 0 && amount <= 1);
    final hsl = HSLColor.fromColor(this);
    final lightness = (hsl.lightness - amount).clamp(0.0, 1.0);
    return hsl.withLightness(lightness).toColor();
  }
  Color withSaturation(double saturation) {
    assert(saturation >= 0 && saturation <= 1);
    final hsl = HSLColor.fromColor(this);
    return hsl.withSaturation(saturation).toColor();
  }
  Color saturate([double amount = 0.1]) {
    assert(amount >= 0 && amount <= 1);
    final hsl = HSLColor.fromColor(this);
    final saturation = (hsl.saturation + amount).clamp(0.0, 1.0);
    return hsl.withSaturation(saturation).toColor();
  }
  Color desaturate([double amount = 0.1]) {
    assert(amount >= 0 && amount <= 1);
    final hsl = HSLColor.fromColor(this);
    final saturation = (hsl.saturation - amount).clamp(0.0, 1.0);
    return hsl.withSaturation(saturation).toColor();
  }
  bool hasGoodContrastWith(Color background) {
    final foregroundLuminance = computeLuminance();
    final backgroundLuminance = background.computeLuminance();
    final ratio = (foregroundLuminance > backgroundLuminance)
        ? (foregroundLuminance + 0.05) / (backgroundLuminance + 0.05)
        : (backgroundLuminance + 0.05) / (foregroundLuminance + 0.05);
    return ratio >= 4.5; // Ngưỡng độ tương phản tối thiểu là 4.5:1 theo WCAG
  }
  Color ensureContrastWith(Color background) {
    if (hasGoodContrastWith(background)) {
      return this;
    }
    Color result = this;
    final backgroundLuminance = background.computeLuminance();
    if (backgroundLuminance > 0.5) {
      double darkenAmount = 0.1;
      while (darkenAmount <= 0.9 && !result.hasGoodContrastWith(background)) {
        result = darken(darkenAmount);
        darkenAmount += 0.1;
      }
    } else {
      double lightenAmount = 0.1;
      while (lightenAmount <= 0.9 && !result.hasGoodContrastWith(background)) {
        result = lighten(lightenAmount);
        lightenAmount += 0.1;
      }
    }
    return result;
  }
}
extension CustomColorScheme on ColorScheme {
  Color get success => successGreen; // Defined in app_color_scheme.dart
  Color get onSuccess =>
      brightness == Brightness.light ? Colors.white : Colors.black;
  Color get successContainer => brightness == Brightness.light
      ? const Color(0xFFE0F2E3) // Light green container
      : const Color(0xFF1A4D33); // Dark green container
  Color get onSuccessContainer => brightness == Brightness.light
      ? const Color(0xFF00472A) // Dark green text for light mode
      : const Color(0xFFB8E5C7); // Light green text for dark mode
  Color get warning => warningOrange; // Defined in app_color_scheme.dart
  Color get onWarning =>
      brightness == Brightness.light ? Colors.black : Colors.white;
  Color get warningContainer => brightness == Brightness.light
      ? const Color(0xFFFFF0D3) // Light orange container
      : const Color(0xFF4D3200); // Dark orange container
  Color get onWarningContainer => brightness == Brightness.light
      ? const Color(0xFF3D2900) // Dark orange text for light mode
      : const Color(0xFFFFD599); // Light orange text for dark mode
  Color get info => brightness == Brightness.light
      ? geminiLightColorScheme
            .primary // Light blue (from gemini)
      : geminiDarkColorScheme.primary; // Dark blue (from gemini)
  Color get onInfo =>
      brightness == Brightness.light ? Colors.white : Colors.black;
  Color get infoContainer => brightness == Brightness.light
      ? geminiLightColorScheme.primaryContainer
      : geminiDarkColorScheme.primaryContainer;
  Color get onInfoContainer => brightness == Brightness.light
      ? geminiLightColorScheme.onPrimaryContainer
      : geminiDarkColorScheme.onPrimaryContainer;
  Color get primarySurface => brightness == Brightness.light
      ? surfaceContainer.withValues(alpha: 0.95).saturate(0.05)
      : surfaceContainer.withValues(alpha: 0.95).lighten(0.05);
  Color get accentSurface => brightness == Brightness.light
      ? secondaryContainer.withValues(alpha: 0.9)
      : secondaryContainer.withValues(alpha: 0.8).lighten(0.05);
  Color get highlightColor => brightness == Brightness.light
      ? tertiaryContainer.withValues(alpha: 0.9).saturate(0.1)
      : tertiaryContainer.withValues(alpha: 0.8).saturate(0.1);
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/due_progress_list_item.dart
class DueProgressListItem extends StatelessWidget {
  final ProgressDetail progress;
  final bool isItemDue;
  const DueProgressListItem({
    super.key,
    required this.progress,
    required this.isItemDue,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final dateFormat = DateFormat('MMM dd, yyyy');
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: colorScheme.outlineVariant.withValues(alpha: 0.5),
          width: 1,
        ),
      ),
      child: InkWell(
        onTap: () {
          final String progressId = progress.id;
          debugPrint('Navigating to progress with ID: $progressId');
          if (progressId.isEmpty) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Invalid progress ID')),
            );
            return;
          }
          NavigationHelper.pushWithResult(
            context,
            '/progress/$progressId',
          ).then((_) => {}); // Auto-refresh when returning
        },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(
                    width: 48,
                    height: 48,
                    child: Stack(
                      alignment: Alignment.center,
                      children: [
                        CircularProgressIndicator(
                          value: progress.percentComplete / 100,
                          backgroundColor: colorScheme.surfaceContainerHighest,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            theme.getProgressColor(progress.percentComplete),
                          ),
                          strokeWidth: 4,
                        ),
                        Text(
                          '${progress.percentComplete.toInt()}%',
                          style: theme.textTheme.labelSmall?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          progress.moduleTitle ?? 'Module ${progress.moduleId}',
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 4),
                        Text(
                          'Cycle: ${CycleFormatter.getDisplayName(progress.cyclesStudied)}',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.getCycleColor(progress.cyclesStudied),
                          ),
                        ),
                        const SizedBox(height: 4),
                        Row(
                          children: [
                            Icon(
                              isItemDue ? Icons.event_available : Icons.event,
                              size: 16,
                              color: isItemDue
                                  ? colorScheme.error
                                  : colorScheme.onSurfaceVariant,
                            ),
                            const SizedBox(width: 4),
                            Text(
                              progress.nextStudyDate != null
                                  ? dateFormat.format(progress.nextStudyDate!)
                                  : 'Not scheduled',
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: isItemDue
                                    ? colorScheme.error
                                    : colorScheme.onSurfaceVariant,
                                fontWeight: isItemDue ? FontWeight.bold : null,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  if (isItemDue)
                    Icon(
                      Icons.notifications_active,
                      color: colorScheme.error,
                      size: 20,
                    ),
                ],
              ),
              if (progress.repetitions.isNotEmpty) ...[
                const SizedBox(height: 8),
                Chip(
                  label: Text('${progress.repetitions.length} repetitions'),
                  backgroundColor: colorScheme.surfaceContainerHigh,
                  side: BorderSide.none,
                  labelStyle: theme.textTheme.bodySmall?.copyWith(
                    color: colorScheme.onSurfaceVariant,
                  ),
                  padding: EdgeInsets.zero,
                  visualDensity: VisualDensity.compact,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/di/providers.dart
@riverpod
ApiClient apiClient(Ref ref) => ApiClient();
@riverpod
StorageService storageService(Ref ref) => StorageService();
@Riverpod(keepAlive: true)
EventBus eventBus(Ref ref) => EventBus();
@riverpod
DeviceSettingsService deviceSettingsService(Ref ref) => DeviceSettingsService();
@Riverpod(keepAlive: true)
FutureOr<DeviceSpecificService> deviceSpecificService(Ref ref) async {
  final deviceService = DeviceSpecificService(
    deviceSettingsService: ref.read(deviceSettingsServiceProvider),
  );
  await deviceService.initialize();
  return deviceService;
}
@Riverpod(keepAlive: true)
FutureOr<NotificationService> notificationService(Ref ref) async {
  final deviceService = await ref.watch(deviceSpecificServiceProvider.future);
  final notificationService = NotificationService(
    deviceSpecificService: deviceService,
  );
  await notificationService.initialize();
  return notificationService;
}
@riverpod
AlarmManagerService alarmManagerService(Ref ref) => AlarmManagerService(
  deviceSpecificService: ref.watch(
    deviceSpecificServiceProvider.future
        as ProviderListenable<DeviceSpecificService>,
  ),
);
@riverpod
CloudReminderService cloudReminderService(Ref ref) => CloudReminderService(
  storageService: ref.read(storageServiceProvider),
  notificationService: ref.watch(
    notificationServiceProvider.future
        as ProviderListenable<NotificationService>,
  ),
);
@Riverpod(keepAlive: true)
FutureOr<ReminderService> reminderService(Ref ref) async {
  final notificationService = await ref.watch(
    notificationServiceProvider.future,
  );
  return ReminderService(
    notificationService: notificationService,
    storageService: ref.read(storageServiceProvider),
    deviceSpecificService: await ref.watch(
      deviceSpecificServiceProvider.future,
    ),
    progressRepository: ref.read(progressRepositoryProvider),
    eventBus: ref.read(eventBusProvider),
  );
}
@riverpod
AuthRepository authRepository(Ref ref) =>
    AuthRepositoryImpl(ref.read(apiClientProvider));
@riverpod
BookRepository bookRepository(Ref ref) =>
    BookRepositoryImpl(ref.read(apiClientProvider));
@riverpod
ModuleRepository moduleRepository(Ref ref) =>
    ModuleRepositoryImpl(ref.read(apiClientProvider));
@riverpod
ProgressRepository progressRepository(Ref ref) =>
    ProgressRepositoryImpl(ref.read(apiClientProvider));
@riverpod
RepetitionRepository repetitionRepository(Ref ref) =>
    RepetitionRepositoryImpl(ref.read(apiClientProvider));
@riverpod
UserRepository userRepository(Ref ref) =>
    UserRepositoryImpl(ref.read(apiClientProvider));
@riverpod
LearningStatsRepository learningStatsRepository(Ref ref) =>
    LearningStatsRepositoryImpl(ref.read(apiClientProvider));
@riverpod
LearningProgressRepository learningProgressRepository(Ref ref) =>
    LearningProgressRepositoryImpl(ref.read(apiClientProvider));
@riverpod
LearningDataService learningDataService(Ref ref) =>
    LearningDataServiceImpl(ref.read(learningProgressRepositoryProvider));
@Riverpod(keepAlive: true)
FutureOr<DailyTaskChecker> dailyTaskChecker(Ref ref) async {
  final reminderService = await ref.watch(reminderServiceProvider.future);
  final dailyTaskChecker = DailyTaskChecker(
    progressRepository: ref.read(progressRepositoryProvider),
    storageService: ref.read(storageServiceProvider),
    eventBus: ref.read(eventBusProvider),
    reminderService: reminderService,
    notificationsPlugin: FlutterLocalNotificationsPlugin(),
  );
  return dailyTaskChecker;
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/reminder_settings_viewmodel.dart
@riverpod
class ReminderSettingsState extends _$ReminderSettingsState {
  @override
  Future<Map<String, bool>> build() async {
    return _loadSettings();
  }
  Future<Map<String, bool>> _loadSettings() async {
    try {
      final reminderService = await ref.read(reminderServiceProvider.future);
      return {
        'remindersEnabled': await reminderService.getRemindersEnabled(),
        'noonReminderEnabled': await reminderService.getNoonReminderEnabled(),
        'eveningFirstReminderEnabled': await reminderService
            .getEveningFirstReminderEnabled(),
        'eveningSecondReminderEnabled': await reminderService
            .getEveningSecondReminderEnabled(),
        'endOfDayReminderEnabled': await reminderService
            .getEndOfDayReminderEnabled(),
      };
    } catch (e) {
      throw Exception('Failed to load reminder settings: $e');
    }
  }
  Future<bool> setRemindersEnabled(bool value) async {
    try {
      final reminderService = await ref.read(reminderServiceProvider.future);
      final success = await reminderService.setRemindersEnabled(value);
      if (success) {
        state = AsyncValue.data({
          ...state.valueOrNull ?? {},
          'remindersEnabled': value,
        });
        ref
            .read(eventBusProvider)
            .fire(ReminderSettingsChangedEvent(enabled: value));
      }
      return success;
    } catch (e) {
      return false;
    }
  }
  Future<bool> setNoonReminderEnabled(bool value) async {
    try {
      final reminderService = await ref.read(reminderServiceProvider.future);
      final success = await reminderService.setNoonReminderEnabled(value);
      if (success) {
        state = AsyncValue.data({
          ...state.valueOrNull ?? {},
          'noonReminderEnabled': value,
        });
      }
      return success;
    } catch (e) {
      return false;
    }
  }
  Future<bool> setEveningFirstReminderEnabled(bool value) async {
    try {
      final reminderService = await ref.read(reminderServiceProvider.future);
      final success = await reminderService.setEveningFirstReminderEnabled(
        value,
      );
      if (success) {
        state = AsyncValue.data({
          ...state.valueOrNull ?? {},
          'eveningFirstReminderEnabled': value,
        });
      }
      return success;
    } catch (e) {
      return false;
    }
  }
  Future<bool> setEveningSecondReminderEnabled(bool value) async {
    try {
      final reminderService = await ref.read(reminderServiceProvider.future);
      final success = await reminderService.setEveningSecondReminderEnabled(
        value,
      );
      if (success) {
        state = AsyncValue.data({
          ...state.valueOrNull ?? {},
          'eveningSecondReminderEnabled': value,
        });
      }
      return success;
    } catch (e) {
      return false;
    }
  }
  Future<bool> setEndOfDayReminderEnabled(bool value) async {
    try {
      final reminderService = await ref.read(reminderServiceProvider.future);
      final success = await reminderService.setEndOfDayReminderEnabled(value);
      if (success) {
        state = AsyncValue.data({
          ...state.valueOrNull ?? {},
          'endOfDayReminderEnabled': value,
        });
      }
      return success;
    } catch (e) {
      return false;
    }
  }
  Future<void> refreshSettings() async {
    state = const AsyncValue.loading();
    try {
      final settings = await _loadSettings();
      state = AsyncValue.data(settings);
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
    }
  }
}
@riverpod
class DevicePermissions extends _$DevicePermissions {
  @override
  Future<Map<String, dynamic>> build() async {
    return _loadDevicePermissions();
  }
  Future<Map<String, dynamic>> _loadDevicePermissions() async {
    try {
      final deviceSettingsService = ref.read(deviceSettingsServiceProvider);
      final hasExactAlarmPermission = await deviceSettingsService
          .hasExactAlarmPermission();
      final isIgnoringBatteryOptimizations = await deviceSettingsService
          .isIgnoringBatteryOptimizations();
      final deviceInfo = await deviceSettingsService.getDeviceInfo();
      return {
        'hasExactAlarmPermission': hasExactAlarmPermission,
        'isIgnoringBatteryOptimizations': isIgnoringBatteryOptimizations,
        'deviceInfo': deviceInfo,
      };
    } catch (e) {
      return {
        'hasExactAlarmPermission': false,
        'isIgnoringBatteryOptimizations': false,
        'deviceInfo': {
          'sdkVersion': 0,
          'manufacturer': 'Unknown',
          'model': 'Unknown',
        },
      };
    }
  }
  Future<bool> requestExactAlarmPermission() async {
    try {
      final deviceSettingsService = ref.read(deviceSettingsServiceProvider);
      final result = await deviceSettingsService.requestExactAlarmPermission();
      if (result) {
        state = AsyncValue.data({
          ...state.valueOrNull ?? {},
          'hasExactAlarmPermission': true,
        });
      }
      return result;
    } catch (e) {
      return false;
    }
  }
  Future<bool> requestBatteryOptimization() async {
    try {
      final deviceSettingsService = ref.read(deviceSettingsServiceProvider);
      final result = await deviceSettingsService.requestBatteryOptimization();
      if (result) {
        state = AsyncValue.data({
          ...state.valueOrNull ?? {},
          'isIgnoringBatteryOptimizations': true,
        });
      }
      return result;
    } catch (e) {
      return false;
    }
  }
  Future<bool> disableSleepingApps() async {
    try {
      final deviceSettingsService = ref.read(deviceSettingsServiceProvider);
      return await deviceSettingsService.disableSleepingApps();
    } catch (e) {
      return false;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/due_progress_list.dart
class DueProgressList extends ConsumerWidget {
  final DateTime? selectedDate;
  final bool isLoading;
  final AnimationController animationController;
  final Animation<double> fadeAnimation;
  final VoidCallback onRefresh;
  const DueProgressList({
    super.key,
    required this.selectedDate,
    required this.isLoading,
    required this.animationController,
    required this.fadeAnimation,
    required this.onRefresh,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final progressAsync = ref.watch(progressStateProvider);
    final theme = Theme.of(context);
    return progressAsync.when(
      data: (progressRecords) {
        if (progressRecords.isEmpty && progressAsync.isLoading) {
          return const Center(child: SLLoadingIndicator());
        }
        if (progressAsync.hasError) {
          return Center(
            child: SLErrorView(
              message: progressAsync.error.toString(),
              onRetry: onRefresh,
            ),
          );
        }
        if (isLoading) {
          return const Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                SLLoadingIndicator(),
                SizedBox(height: 16),
                Text('Loading progress information...'),
              ],
            ),
          );
        }
        if (progressRecords.isEmpty) {
          return DueProgressEmptyState(
            selectedDate: selectedDate,
            onRefresh: onRefresh,
          );
        }
        final today = DateTime.now();
        final todayProgressRecords = <ProgressDetail>[];
        final overdueProgressRecords = <ProgressDetail>[];
        final upcomingProgressRecords = <ProgressDetail>[];
        for (final progress in progressRecords) {
          if (progress.nextStudyDate == null) continue;
          final progressDate = DateTime(
            progress.nextStudyDate!.year,
            progress.nextStudyDate!.month,
            progress.nextStudyDate!.day,
          );
          final nowDate = DateTime(today.year, today.month, today.day);
          if (progressDate.isAtSameMomentAs(nowDate)) {
            todayProgressRecords.add(progress);
            continue;
          }
          if (progressDate.isBefore(nowDate)) {
            overdueProgressRecords.add(progress);
            continue;
          }
          upcomingProgressRecords.add(progress);
        }
        return FadeTransition(
          opacity: fadeAnimation,
          child: RefreshIndicator(
            onRefresh: () async => onRefresh(),
            child: ListView(
              padding: const EdgeInsets.only(bottom: 80),
              children: [
                if (overdueProgressRecords.isNotEmpty) ...[
                  _buildSectionHeader(
                    theme,
                    'Overdue',
                    Icons.warning_amber,
                    theme.colorScheme.error,
                  ),
                  ...overdueProgressRecords.map(
                    (progress) => DueProgressListItem(
                      progress: progress,
                      isItemDue: true,
                    ),
                  ),
                  const SizedBox(height: 24),
                ],
                if (todayProgressRecords.isNotEmpty) ...[
                  _buildSectionHeader(
                    theme,
                    'Due Today',
                    Icons.today,
                    theme.colorScheme.tertiary,
                  ),
                  ...todayProgressRecords.map(
                    (progress) => DueProgressListItem(
                      progress: progress,
                      isItemDue: true,
                    ),
                  ),
                  const SizedBox(height: 24),
                ],
                if (upcomingProgressRecords.isNotEmpty &&
                    selectedDate != null) ...[
                  _buildSectionHeader(
                    theme,
                    'Upcoming',
                    Icons.event,
                    theme.colorScheme.primary,
                  ),
                  ...upcomingProgressRecords.map(
                    (progress) => DueProgressListItem(
                      progress: progress,
                      isItemDue: false,
                    ),
                  ),
                ],
                if (todayProgressRecords.isEmpty &&
                    overdueProgressRecords.isEmpty &&
                    upcomingProgressRecords.isEmpty)
                  DueProgressEmptyState(
                    selectedDate: selectedDate,
                    onRefresh: onRefresh,
                  ),
              ],
            ),
          ),
        );
      },
      loading: () => const Center(child: SLLoadingIndicator()),
      error: (error, _) => Center(
        child: SLErrorView(message: error.toString(), onRetry: onRefresh),
      ),
    );
  }
  Widget _buildSectionHeader(
    ThemeData theme,
    String title,
    IconData icon,
    Color color,
  ) => Padding(
    padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
    child: Row(
      children: [
        Icon(icon, size: 20, color: color),
        const SizedBox(width: 8),
        Text(
          title,
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
      ],
    ),
  );
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/error_display.dart
class SLErrorView extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final IconData? icon;
  final bool compact;
  final ThemeData? theme;
  const SLErrorView({
    super.key,
    required this.message,
    this.onRetry,
    this.icon,
    this.compact = false,
    this.theme,
  });
  @override
  Widget build(BuildContext context) {
    final currentTheme = theme ?? Theme.of(context);
    return compact
        ? _buildCompactView(currentTheme)
        : _buildFullView(currentTheme);
  }
  Widget _buildCompactView(ThemeData theme) {
    final colorScheme = theme.colorScheme;
    return Card(
      color: colorScheme.errorContainer,
      margin: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingL,
        vertical: AppDimens.paddingS,
      ),
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingM),
        child: Row(
          children: [
            _buildErrorIcon(theme, size: AppDimens.iconM),
            const SizedBox(width: AppDimens.spaceM),
            Expanded(
              child: Text(
                message,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: colorScheme.onErrorContainer,
                ),
              ),
            ),
            if (onRetry != null)
              Padding(
                padding: const EdgeInsets.only(left: AppDimens.paddingM),
                child: SLButton(
                  text: 'Retry',
                  type: SLButtonType.text,
                  onPressed: onRetry,
                ),
              ),
          ],
        ),
      ),
    );
  }
  Widget _buildFullView(ThemeData theme) {
    final colorScheme = theme.colorScheme;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingXL),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildErrorIcon(theme, size: AppDimens.iconXXL),
            const SizedBox(height: AppDimens.spaceL),
            Text(
              message,
              textAlign: TextAlign.center,
              style: theme.textTheme.titleMedium?.copyWith(
                color: colorScheme.onSurface.withValues(
                  alpha: AppDimens.opacityVeryHigh,
                ),
              ),
            ),
            if (onRetry != null)
              Padding(
                padding: const EdgeInsets.only(top: AppDimens.paddingXL),
                child: SLButton(
                  text: 'Try Again',
                  type: SLButtonType.outline,
                  prefixIcon: Icons.refresh,
                  onPressed: onRetry,
                ),
              ),
          ],
        ),
      ),
    );
  }
  Widget _buildErrorIcon(ThemeData theme, {required double size}) {
    final colorScheme = theme.colorScheme;
    return Icon(
      icon ?? Icons.error_outline,
      color: colorScheme.error,
      size: size,
    );
  }
}
abstract class _SnackbarHelper {
  static void _showSnackBar({
    required BuildContext context,
    required String message,
    required IconData icon,
    required Color Function(ThemeData) backgroundColorBuilder,
    required Color Function(ThemeData) contentColorBuilder,
    Duration? duration,
    SnackBarAction? action,
    Color? actionColor,
  }) {
    final theme = Theme.of(context);
    final snackBarTheme = theme.snackBarTheme;
    final effectiveBackgroundColor = backgroundColorBuilder(theme);
    final effectiveContentColor = contentColorBuilder(theme);
    final effectiveTextStyle =
        snackBarTheme.contentTextStyle ??
        theme.textTheme.bodyMedium?.copyWith(color: effectiveContentColor);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            Icon(icon, color: effectiveContentColor, size: AppDimens.iconM),
            const SizedBox(width: AppDimens.spaceM),
            Expanded(child: Text(message, style: effectiveTextStyle)),
          ],
        ),
        backgroundColor: effectiveBackgroundColor,
        duration: duration ?? const Duration(seconds: 4),
        behavior: snackBarTheme.behavior ?? SnackBarBehavior.floating,
        shape: snackBarTheme.shape,
        action: action != null
            ? SnackBarAction(
                label: action.label,
                onPressed: action.onPressed,
                textColor:
                    actionColor ??
                    snackBarTheme.actionTextColor ??
                    theme.colorScheme.primary,
              )
            : null,
      ),
    );
  }
}
class ErrorSnackbar {
  static void show(BuildContext context, String message, {Duration? duration}) {
    _SnackbarHelper._showSnackBar(
      context: context,
      message: message,
      icon: Icons.error_outline,
      backgroundColorBuilder: (theme) => theme.colorScheme.errorContainer,
      contentColorBuilder: (theme) => theme.colorScheme.onErrorContainer,
      duration: duration,
      action: SnackBarAction(
        label: 'Dismiss',
        onPressed: () => ScaffoldMessenger.of(context).hideCurrentSnackBar(),
      ),
    );
  }
}
class SuccessSnackbar {
  static Color _getSuccessBackgroundColor(ThemeData theme) {
    return theme.brightness == Brightness.light
        ? const Color(0xFFE8F5E9)
        : const Color(0xFF2E7D32);
  }
  static Color _getSuccessContentColor(ThemeData theme) {
    return theme.brightness == Brightness.light
        ? const Color(0xFF1B5E20)
        : const Color(0xFFC8E6C9);
  }
  static void show(BuildContext context, String message, {Duration? duration}) {
    _SnackbarHelper._showSnackBar(
      context: context,
      message: message,
      icon: Icons.check_circle,
      backgroundColorBuilder: _getSuccessBackgroundColor,
      contentColorBuilder: _getSuccessContentColor,
      duration: duration,
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/app_progress_indicator.dart
enum ProgressType { linear, circular }
class SLProgressIndicator extends StatefulWidget {
  final ProgressType type;
  final double? value;
  final double size;
  final double strokeWidth;
  final Color? color;
  final Color? backgroundColor;
  final Color? foregroundColor;
  final Animation<Color?>? valueColor;
  final Widget? child;
  final String? label;
  final TextStyle? labelStyle;
  final bool animate;
  final Duration animationDuration;
  const SLProgressIndicator({
    super.key,
    this.type = ProgressType.circular,
    this.value,
    this.size = AppDimens.circularProgressSizeL,
    this.strokeWidth = AppDimens.lineProgressHeight,
    this.color,
    this.backgroundColor,
    this.foregroundColor,
    this.valueColor,
    this.child,
    this.label,
    this.labelStyle,
    this.animate = false,
    this.animationDuration = const Duration(milliseconds: 1500),
  });
  @override
  State<SLProgressIndicator> createState() => _SLProgressIndicatorState();
}
class _SLProgressIndicatorState extends State<SLProgressIndicator>
    with SingleTickerProviderStateMixin {
  AnimationController? _animationController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _pulseAnimation;
  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }
  @override
  void didUpdateWidget(SLProgressIndicator oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.animate != widget.animate) {
      _teardownAnimation();
      _setupAnimation();
    }
  }
  @override
  void dispose() {
    _teardownAnimation();
    super.dispose();
  }
  void _setupAnimation() {
    if (!widget.animate) return;
    _animationController = AnimationController(
      vsync: this,
      duration: widget.animationDuration,
    );
    _fadeAnimation = Tween<double>(begin: 0.7, end: 1.0).animate(
      CurvedAnimation(parent: _animationController!, curve: Curves.easeInOut),
    );
    _pulseAnimation = Tween<double>(begin: 0.97, end: 1.03).animate(
      CurvedAnimation(parent: _animationController!, curve: Curves.easeInOut),
    );
    _animationController!.repeat(reverse: true);
  }
  void _teardownAnimation() {
    _animationController?.dispose();
    _animationController = null;
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final effectiveForegroundColor =
        widget.foregroundColor ?? widget.color ?? colorScheme.primary;
    final effectiveBackgroundColor =
        widget.backgroundColor ?? colorScheme.surfaceContainerHighest;
    final effectiveValueColor =
        widget.valueColor ?? AlwaysStoppedAnimation(effectiveForegroundColor);
    return _buildContent(
      effectiveForegroundColor,
      effectiveBackgroundColor,
      effectiveValueColor,
      theme,
      colorScheme,
    );
  }
  Widget _buildContent(
    Color foregroundColor,
    Color backgroundColor,
    Animation<Color?> valueColor,
    ThemeData theme,
    ColorScheme colorScheme,
  ) {
    final progressIndicator = widget.type == ProgressType.linear
        ? _buildLinearProgress(foregroundColor, backgroundColor, valueColor)
        : _buildCircularProgress(foregroundColor, backgroundColor, valueColor);
    if (widget.label != null) {
      return Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          progressIndicator,
          const SizedBox(height: AppDimens.spaceS),
          Text(
            widget.label!,
            style:
                widget.labelStyle ??
                theme.textTheme.bodyMedium!.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
            textAlign: TextAlign.center,
          ),
        ],
      );
    }
    return progressIndicator;
  }
  Widget _buildLinearProgress(
    Color foregroundColor,
    Color backgroundColor,
    Animation<Color?> valueColor,
  ) {
    return widget.animate && _animationController != null
        ? AnimatedBuilder(
            animation: _animationController!,
            builder: (context, child) => Opacity(
              opacity: _fadeAnimation.value,
              child: LinearProgressIndicator(
                value: widget.value,
                backgroundColor: backgroundColor,
                valueColor: valueColor,
                minHeight: widget.strokeWidth,
                borderRadius: BorderRadius.circular(widget.strokeWidth / 2),
              ),
            ),
          )
        : LinearProgressIndicator(
            value: widget.value,
            backgroundColor: backgroundColor,
            valueColor: valueColor,
            minHeight: widget.strokeWidth,
            borderRadius: BorderRadius.circular(widget.strokeWidth / 2),
          );
  }
  Widget _buildCircularProgress(
    Color foregroundColor,
    Color backgroundColor,
    Animation<Color?> valueColor,
  ) {
    Widget circularProgress = SizedBox(
      width: widget.size,
      height: widget.size,
      child: CircularProgressIndicator(
        value: widget.value,
        backgroundColor: backgroundColor,
        valueColor: valueColor,
        strokeWidth: widget.strokeWidth,
        strokeCap: StrokeCap.round,
      ),
    );
    if (widget.child != null) {
      circularProgress = Stack(
        alignment: Alignment.center,
        children: [circularProgress, widget.child!],
      );
    }
    return widget.animate && _animationController != null
        ? AnimatedBuilder(
            animation: _animationController!,
            builder: (context, child) => Transform.scale(
              scale: _pulseAnimation.value,
              child: Opacity(opacity: _fadeAnimation.value, child: child),
            ),
            child: circularProgress,
          )
        : circularProgress;
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/reminder_notification_service.dart
class ReminderNotificationService extends BaseNotificationService {
  final NotificationChannelManager _channelManager;
  static const int noonReminderId = 1001;
  static const int eveningFirstReminderId = 1002;
  static const int eveningSecondReminderId = 1003;
  static const int endOfDayReminderId = 1004;
  ReminderNotificationService({
    required super.deviceSpecificService,
    required super.notificationsPlugin,
  }) : _channelManager = NotificationChannelManager(deviceSpecificService);
  @override
  Future<bool> initialize() async {
    final initialized = await super.initialize();
    if (!initialized) return false;
    if (deviceSpecificService.isAndroid) {
      final androidPlugin = notificationsPlugin
          .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin
          >();
      if (!await _channelManager.createNotificationChannels(androidPlugin)) {
        debugPrint('Warning: Failed to create notification channels');
      }
    }
    if (!await _requestPermissions()) {
      debugPrint('Warning: Notification permissions not granted');
    }
    return true;
  }
  Future<bool> _requestPermissions() async {
    try {
      if (!deviceSpecificService.isAndroid) {
        final ios = notificationsPlugin
            .resolvePlatformSpecificImplementation<
              IOSFlutterLocalNotificationsPlugin
            >();
        if (ios == null) {
          return false;
        }
        final bool? result = await ios.requestPermissions(
          alert: true,
          badge: true,
          sound: true,
        );
        return result ?? false;
      }
      return true;
    } catch (e) {
      debugPrint('Error requesting notification permissions: $e');
      return false;
    }
  }
  Future<bool> scheduleNotification({
    required int id,
    required String title,
    required String body,
    required DateTime scheduledTime,
    String? payload,
    bool isImportant = false,
    bool isAlarmStyle = false,
  }) async {
    if (kIsWeb) {
      debugPrint('Scheduled notifications not supported on web platform');
      return false;
    }
    if (!isInitialized) {
      final bool initialized = await initialize();
      if (!initialized) return false;
    }
    if (!timezonesInitialized) {
      debugPrint('Timezones not initialized, cannot schedule notification');
      return false;
    }
    try {
      final notificationDetails = _channelManager.getNotificationDetails(
        isImportant: isImportant,
        isAlarmStyle: isAlarmStyle,
      );
      final tzScheduledTime = convertToTZDateTime(scheduledTime);
      await notificationsPlugin.zonedSchedule(
        id,
        title,
        body,
        tzScheduledTime,
        notificationDetails,
        androidScheduleMode: _getAndroidScheduleMode(isAlarmStyle),
        matchDateTimeComponents: DateTimeComponents.time,
        payload: payload,
      );
      debugPrint(
        'Notification scheduled with id: $id for time: $scheduledTime',
      );
      return true;
    } catch (e) {
      debugPrint('Error scheduling notification: $e');
      return false;
    }
  }
  AndroidScheduleMode _getAndroidScheduleMode(bool isAlarmStyle) {
    return isAlarmStyle
        ? AndroidScheduleMode.exactAllowWhileIdle
        : AndroidScheduleMode.exactAllowWhileIdle;
  }
  Future<bool> scheduleNoonReminder() async {
    final now = DateTime.now();
    final scheduledTime = _getScheduledTime(
      now,
      AppConstants.noonReminderHour,
      AppConstants.noonReminderMinute,
    );
    return scheduleNotification(
      id: noonReminderId,
      title: 'Check Your Learning Schedule',
      body: 'It\'s time to review today\'s learning schedule',
      scheduledTime: scheduledTime,
      isImportant: false,
    );
  }
  DateTime _getScheduledTime(DateTime now, int hour, int minute) {
    final scheduledTime = DateTime(now.year, now.month, now.day, hour, minute);
    return scheduledTime.isBefore(now)
        ? scheduledTime.add(const Duration(days: 1))
        : scheduledTime;
  }
  Future<bool> scheduleEveningFirstReminder() async {
    final now = DateTime.now();
    final scheduledTime = _getScheduledTime(
      now,
      AppConstants.eveningFirstReminderHour,
      AppConstants.eveningFirstReminderMinute,
    );
    return scheduleNotification(
      id: eveningFirstReminderId,
      title: 'Unfinished Learning Tasks',
      body: 'You still have some lessons to complete today',
      scheduledTime: scheduledTime,
      isImportant: true,
    );
  }
  Future<bool> scheduleEveningSecondReminder() async {
    final now = DateTime.now();
    final scheduledTime = _getScheduledTime(
      now,
      AppConstants.eveningSecondReminderHour,
      AppConstants.eveningSecondReminderMinute,
    );
    return scheduleNotification(
      id: eveningSecondReminderId,
      title: 'Tasks Still Pending!',
      body: 'Complete your learning before bedtime',
      scheduledTime: scheduledTime,
      isImportant: true,
    );
  }
  Future<bool> scheduleEndOfDayReminder({bool useAlarmStyle = false}) async {
    final now = DateTime.now();
    final scheduledTime = _getScheduledTime(
      now,
      AppConstants.endOfDayReminderHour,
      AppConstants.endOfDayReminderMinute,
    );
    return scheduleNotification(
      id: endOfDayReminderId,
      title: 'Don\'t Miss Today\'s Learning!',
      body: 'This is the final reminder for unfinished tasks',
      scheduledTime: scheduledTime,
      isImportant: true,
      isAlarmStyle: useAlarmStyle,
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/book_list_card.dart
class BookListCard extends StatelessWidget {
  final BookSummary book;
  final VoidCallback onTap;
  const BookListCard({super.key, required this.book, required this.onTap});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Card(
      elevation: AppDimens.elevationS,
      margin: const EdgeInsets.only(bottom: AppDimens.paddingM),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimens.radiusL),
      ),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingM),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              BookCover(book: book, theme: theme),
              const SizedBox(width: AppDimens.spaceL),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      book.name,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: colorScheme.onSurface,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: AppDimens.spaceS),
                    Row(
                      children: [
                        Icon(
                          Icons.library_books_outlined,
                          size: AppDimens.iconS,
                          color: colorScheme.primary,
                        ),
                        const SizedBox(width: AppDimens.spaceXS),
                        Text(
                          '${book.moduleCount} ${book.moduleCount == 1 ? 'module' : 'modules'}',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: AppDimens.spaceS),
                    Row(
                      children: [
                        _buildStatusBadge(book.status, theme, colorScheme),
                        if (book.difficultyLevel != null) ...[
                          const SizedBox(width: AppDimens.spaceXS),
                          _buildDifficultyBadge(
                            book.difficultyLevel!,
                            theme,
                            colorScheme,
                          ),
                        ],
                      ],
                    ),
                    if (book.createdAt != null) ...[
                      const SizedBox(height: AppDimens.spaceS),
                      Row(
                        children: [
                          Icon(
                            Icons.calendar_today_outlined,
                            size: AppDimens.iconXS,
                            color: colorScheme.onSurfaceVariant,
                          ),
                          const SizedBox(width: AppDimens.spaceXXS),
                          Text(
                            'Created: ${AppDateUtils.formatDate(book.createdAt!)}',
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),
              Icon(
                Icons.chevron_right,
                color: colorScheme.onSurfaceVariant,
                size: AppDimens.iconL,
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildStatusBadge(
    BookStatus status,
    ThemeData theme,
    ColorScheme colorScheme,
  ) {
    final backgroundColor = BookFormatter.getStatusColor(
      status,
      colorScheme,
    ).withValues(alpha: AppDimens.opacityLight);
    final textColor = BookFormatter.getStatusColor(status, colorScheme);
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingXS,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(AppDimens.radiusS),
      ),
      child: Text(
        BookFormatter.formatStatus(status),
        style: theme.textTheme.labelSmall?.copyWith(
          color: textColor,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  Widget _buildDifficultyBadge(
    DifficultyLevel level,
    ThemeData theme,
    ColorScheme colorScheme,
  ) {
    final backgroundColor = BookFormatter.getDifficultyColor(
      level,
      colorScheme,
    ).withValues(alpha: AppDimens.opacityLight);
    final textColor = BookFormatter.getDifficultyColor(level, colorScheme);
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingXS,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(AppDimens.radiusS),
      ),
      child: Text(
        BookFormatter.formatDifficulty(level),
        style: theme.textTheme.labelSmall?.copyWith(
          color: textColor,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/progress/due_progress_screen.dart
class DueProgressScreen extends ConsumerStatefulWidget {
  const DueProgressScreen({super.key});
  @override
  ConsumerState<DueProgressScreen> createState() => _DueProgressScreenState();
}
class _DueProgressScreenState extends ConsumerState<DueProgressScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  DateTime? _selectedDate;
  bool _isLoading = false;
  final ScrollController _scrollController = ScrollController();
  bool _isScrolled = false;
  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _fadeAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
    _animationController.forward();
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) => _loadData());
  }
  void _onScroll() {
    final isScrolled = _scrollController.offset > 10;
    if (isScrolled != _isScrolled) {
      setState(() => _isScrolled = isScrolled);
    }
  }
  @override
  void dispose() {
    _animationController.dispose();
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }
  Future<void> _loadData() async {
    if (!mounted) return;
    final authState = ref.read(authStateProvider);
    final isAuthorized = authState.valueOrNull ?? false;
    final currentUser = ref.read(currentUserProvider);
    if (!isAuthorized || currentUser == null) {
      return;
    }
    setState(() => _isLoading = true);
    await ref
        .read(progressStateProvider.notifier)
        .loadDueProgress(currentUser.id, studyDate: _selectedDate);
    if (mounted) {
      setState(() => _isLoading = false);
    }
  }
  Future<void> _selectDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(),
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
      builder: (context, child) => Theme(
        data: Theme.of(context).copyWith(
          colorScheme: Theme.of(context).colorScheme,
          dialogTheme: DialogThemeData(
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(AppDimens.radiusL),
            ),
          ),
        ),
        child: child!,
      ),
    );
    if (picked == null || picked == _selectedDate) return;
    setState(() => _selectedDate = picked);
    _animationController.reset();
    _animationController.forward();
    await _loadData();
  }
  void _clearDateFilter() {
    setState(() => _selectedDate = null);
    _animationController.reset();
    _animationController.forward();
    _loadData();
  }
  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authStateProvider);
    final isAuthorized = authState.valueOrNull ?? false;
    final currentUser = ref.watch(currentUserProvider);
    if (!isAuthorized || currentUser == null) {
      return const DueProgressLoginPrompt();
    }
    return Scaffold(
      body: NestedScrollView(
        controller: _scrollController,
        headerSliverBuilder: (context, innerBoxIsScrolled) => [
          SliverAppBar(
            leading: IconButton(
              icon: const Icon(Icons.arrow_back),
              onPressed: () {
                final router = GoRouter.of(context);
                if (router.canPop()) {
                  router.pop();
                  return;
                }
                router.go('/');
              },
              tooltip: 'Back',
            ),
            title: const Text('Due Today'),
            pinned: true,
            floating: true,
            elevation: _isScrolled ? 2.0 : 0.0,
            forceElevated: _isScrolled || innerBoxIsScrolled,
            actions: [
              IconButton(
                icon: const Icon(Icons.refresh),
                onPressed: _loadData,
                tooltip: 'Refresh data',
              ),
            ],
            bottom: PreferredSize(
              preferredSize: const Size.fromHeight(80),
              child: DueProgressFilterCard(
                selectedDate: _selectedDate,
                onSelectDate: _selectDate,
                onClearDate: _clearDateFilter,
              ),
            ),
          ),
        ],
        body: _buildBody(),
      ),
    );
  }
  Widget _buildBody() => Padding(
    padding: const EdgeInsets.symmetric(horizontal: 16.0),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 8),
        DueProgressSummary(onRefresh: _loadData),
        Expanded(
          child: DueProgressList(
            selectedDate: _selectedDate,
            isLoading: _isLoading,
            animationController: _animationController,
            fadeAnimation: _fadeAnimation,
            onRefresh: _loadData,
          ),
        ),
      ],
    ),
  );
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/learning_insights_card.dart
class LearningInsightsCard extends StatelessWidget {
  final List<LearningInsightRespone> insights;
  final String? title;
  final VoidCallback? onViewMorePressed;
  final ThemeData? theme;
  const LearningInsightsCard({
    super.key,
    required this.insights,
    this.title,
    this.onViewMorePressed,
    this.theme,
  });
  @override
  Widget build(BuildContext context) {
    final currentTheme = theme ?? Theme.of(context);
    final colorScheme = currentTheme.colorScheme;
    final textTheme = currentTheme.textTheme;
    final sortedInsights = List<LearningInsightRespone>.from(insights)
      ..sort((a, b) => a.priority.compareTo(b.priority));
    final displayInsights = sortedInsights.length > 4
        ? sortedInsights.sublist(0, 4)
        : sortedInsights;
    return Card(
      elevation: AppDimens.elevationS,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimens.radiusL),
      ),
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildHeader(currentTheme),
            const SizedBox(height: AppDimens.spaceS),
            const Divider(),
            const SizedBox(height: AppDimens.spaceS),
            if (displayInsights.isEmpty)
              Center(
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppDimens.paddingL,
                  ),
                  child: Text(
                    'No insights available',
                    style: textTheme.bodyMedium?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
              )
            else
              ...displayInsights.map(
                (insight) => _buildInsightItem(context, insight, currentTheme),
              ),
            if (onViewMorePressed != null && insights.length > 4) ...[
              const SizedBox(height: AppDimens.spaceS),
              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: onViewMorePressed,
                  child: Text(
                    'View More',
                    style: textTheme.labelLarge?.copyWith(
                      color: colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
  Widget _buildHeader(ThemeData theme) {
    final colorScheme = theme.colorScheme;
    return Row(
      children: [
        Icon(
          Icons.lightbulb_outline,
          color: colorScheme.tertiary,
          size: AppDimens.iconM,
        ),
        const SizedBox(width: AppDimens.spaceS),
        Text(
          title ?? 'Learning Insights',
          style: theme.textTheme.titleLarge?.copyWith(
            color: colorScheme.onSurface,
            fontWeight: FontWeight.w600,
          ),
        ),
      ],
    );
  }
  Widget _buildInsightItem(
    BuildContext context,
    LearningInsightRespone insight,
    ThemeData theme,
  ) {
    final color = _getColorFromString(insight.color, theme);
    final icon = _getIconFromString(insight.icon);
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: AppDimens.paddingS),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(icon, color: color, size: AppDimens.iconM),
          const SizedBox(width: AppDimens.spaceM),
          Expanded(
            child: Text(
              insight.message,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
  Color _getColorFromString(String colorName, ThemeData theme) {
    final colorScheme = theme.colorScheme;
    switch (colorName.toLowerCase()) {
      case 'primary':
      case 'blue':
        return colorScheme.primary;
      case 'secondary':
      case 'purple':
        return colorScheme.secondary;
      case 'tertiary':
        return colorScheme.tertiary;
      case 'error':
      case 'red':
        return colorScheme.error;
      case 'surface':
        return colorScheme.surface;
      case 'onSurface':
        return colorScheme.onSurface;
      case 'neutral':
        return colorScheme.onSurfaceVariant;
      case 'success':
      case 'green':
      case 'teal':
        return colorScheme.tertiary;
      case 'warning':
      case 'orange':
      case 'amber':
        return colorScheme.secondary;
      case 'info':
      case 'indigo':
        return colorScheme.primaryContainer;
      default:
        return colorScheme.onSurfaceVariant;
    }
  }
  IconData _getIconFromString(String iconName) {
    switch (iconName.toLowerCase()) {
      case 'trending_up':
        return Icons.trending_up;
      case 'local_fire_department':
        return Icons.local_fire_department;
      case 'menu_book':
        return Icons.menu_book;
      case 'today':
        return Icons.today;
      case 'check_circle':
        return Icons.check_circle;
      case 'star':
        return Icons.star;
      case 'emoji_events':
        return Icons.emoji_events;
      case 'lightbulb':
        return Icons.lightbulb;
      case 'info':
        return Icons.info;
      case 'warning':
        return Icons.warning;
      case 'error':
        return Icons.error;
      default:
        return Icons.info_outline;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/reschedule_dialog.dart
class RescheduleDialog {
  static Future<Map<String, dynamic>?> show(
    BuildContext context, {
    required DateTime initialDate,
    required String title,
  }) async {
    return showDialog<Map<String, dynamic>>(
      context: context,
      barrierDismissible: false,
      builder: (dialogContext) => ProviderScope(
        child: Dialog(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusL),
          ),
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 320, maxWidth: 440),
            child: Padding(
              padding: const EdgeInsets.all(AppDimens.paddingM),
              child: _RescheduleDialogContent(
                initialDate: initialDate,
                title: title,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
class _RescheduleDialogContent extends ConsumerStatefulWidget {
  final DateTime initialDate;
  final String title;
  const _RescheduleDialogContent({
    required this.initialDate,
    required this.title,
  });
  @override
  ConsumerState<_RescheduleDialogContent> createState() =>
      _RescheduleDialogContentState();
}
class _RescheduleDialogContentState
    extends ConsumerState<_RescheduleDialogContent> {
  late DateTime _selectedDate;
  bool _rescheduleFollowing = true;
  @override
  void initState() {
    super.initState();
    _selectedDate = widget.initialDate;
  }
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        _buildHeader(context, widget.title),
        const SizedBox(height: AppDimens.spaceM),
        _buildDatePicker(context),
        const SizedBox(height: AppDimens.spaceM),
        _buildRescheduleSwitchOption(context),
        const SizedBox(height: AppDimens.spaceL),
        _buildActionButtons(context),
      ],
    );
  }
  Widget _buildHeader(BuildContext context, String title) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Row(
      children: [
        Icon(Icons.event, color: colorScheme.primary, size: AppDimens.iconM),
        const SizedBox(width: AppDimens.spaceM),
        Expanded(child: Text(title, style: theme.textTheme.titleLarge)),
      ],
    );
  }
  Widget _buildDatePicker(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Container(
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
      ),
      height: 340,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(AppDimens.paddingM),
            child: Text('Select new date:', style: theme.textTheme.titleMedium),
          ),
          Expanded(
            child: Theme(
              data: theme.copyWith(
                colorScheme: colorScheme.copyWith(
                  primary: colorScheme.primary,
                  onPrimary: colorScheme.onPrimary,
                  surface: colorScheme.surface,
                ),
              ),
              child: CalendarDatePicker(
                initialDate: _selectedDate,
                firstDate: DateTime.now().subtract(const Duration(days: 7)),
                lastDate: DateTime.now().add(const Duration(days: 365)),
                onDateChanged: (date) => setState(() => _selectedDate = date),
              ),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildRescheduleSwitchOption(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Container(
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
        border: Border.all(
          color: colorScheme.outlineVariant.withValues(
            alpha: AppDimens.opacityMediumHigh,
          ),
        ),
      ),
      child: SLToggleSwitch(
        title: 'Reschedule following repetitions',
        subtitle: 'Adjust all future repetitions based on this new date',
        value: _rescheduleFollowing,
        onChanged: (value) => setState(() => _rescheduleFollowing = value),
        type: SLToggleSwitchType.standard,
        size: SLToggleSwitchSize.medium,
        icon: Icons.repeat,
        contentPadding: const EdgeInsets.symmetric(
          horizontal: AppDimens.paddingM,
          vertical: AppDimens.paddingXS,
        ),
      ),
    );
  }
  Widget _buildActionButtons(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        SLButton(
          text: 'Cancel',
          type: SLButtonType.text,
          size: SLButtonSize.small,
          onPressed: () => Navigator.pop(context),
        ),
        const SizedBox(width: AppDimens.spaceM),
        SLButton(
          text: 'Reschedule',
          type: SLButtonType.primary,
          prefixIcon: Icons.calendar_today,
          size: SLButtonSize.small,
          onPressed: () => Navigator.pop(context, {
            'date': _selectedDate,
            'rescheduleFollowing': _rescheduleFollowing,
          }),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/learning_filter_bar/filter_stats_row.dart
class FilterStatsRow extends ConsumerWidget {
  final int totalCount;
  final int dueCount;
  final int completeCount;
  final int activeFilterCount;
  final bool showFilter;
  final VoidCallback onToggleFilter;
  const FilterStatsRow({
    super.key,
    required this.totalCount,
    required this.dueCount,
    required this.completeCount,
    required this.activeFilterCount,
    required this.showFilter,
    required this.onToggleFilter,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Padding(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingXS,
        vertical: AppDimens.paddingM,
      ),
      child: Row(
        children: [
          Expanded(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                _buildStatCard(
                  count: totalCount,
                  label: 'Total',
                  icon: Icons.menu_book,
                  color: colorScheme.primary,
                  theme: theme,
                ),
                _buildStatCard(
                  count: dueCount,
                  label: 'Due',
                  icon: Icons.access_time,
                  color: colorScheme.error,
                  theme: theme,
                  highlight: dueCount > 0,
                ),
                _buildStatCard(
                  count: completeCount,
                  label: 'Learned',
                  icon: Icons.check_circle_outline,
                  color: colorScheme.tertiary,
                  theme: theme,
                ),
              ],
            ),
          ),
          SizedBox(
            width: 32,
            child: IconButton(
              icon: Stack(
                children: [
                  Icon(
                    showFilter ? Icons.filter_list_off : Icons.filter_list,
                    color: activeFilterCount > 0
                        ? colorScheme.primary
                        : colorScheme.onSurfaceVariant,
                    size: AppDimens.iconL,
                  ),
                  if (activeFilterCount > 0)
                    Positioned(
                      right: 0,
                      top: 0,
                      child: Container(
                        padding: const EdgeInsets.all(AppDimens.paddingXXS),
                        decoration: BoxDecoration(
                          color: colorScheme.primary,
                          shape: BoxShape.circle,
                        ),
                        constraints: const BoxConstraints(
                          minWidth: AppDimens.badgeIconPadding * 2 + 6,
                          minHeight: AppDimens.badgeIconPadding * 2 + 6,
                        ),
                        child: Text(
                          '$activeFilterCount',
                          style: theme.textTheme.labelSmall?.copyWith(
                            color: colorScheme.onPrimary,
                            fontSize: AppDimens.fontXXS,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    ),
                ],
              ),
              tooltip: showFilter ? 'Hide filters' : 'Show filters',
              padding: const EdgeInsets.all(AppDimens.paddingXS),
              constraints: const BoxConstraints(),
              visualDensity: VisualDensity.compact,
              onPressed: onToggleFilter,
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildStatCard({
    required int count,
    required String label,
    required IconData icon,
    required Color color,
    required ThemeData theme,
    bool highlight = false,
  }) {
    final colorScheme = theme.colorScheme;
    final brightness = highlight ? 1.0 : 0.8;
    return Expanded(
      child: Card(
        elevation: 0,
        margin: const EdgeInsets.symmetric(horizontal: AppDimens.paddingXS),
        color: color.withValues(alpha: AppDimens.opacityLight),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimens.radiusM),
        ),
        child: Padding(
          padding: const EdgeInsets.symmetric(
            horizontal: AppDimens.paddingM,
            vertical: AppDimens.paddingS,
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    icon,
                    size: AppDimens.iconS,
                    color: color.withValues(alpha: brightness),
                  ),
                  const SizedBox(width: AppDimens.spaceXS),
                  Text(
                    label,
                    style: theme.textTheme.labelMedium?.copyWith(
                      color: colorScheme.onSurface.withValues(
                        alpha: AppDimens.opacityHigh,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: AppDimens.spaceXS),
              Text(
                count.toString(),
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: color.withValues(alpha: brightness),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/home_viewmodel.dart
enum HomeLoadingStatus { initial, loading, loaded, error }
class HomeState {
  final HomeLoadingStatus status;
  final String? errorMessage;
  const HomeState({required this.status, this.errorMessage});
  const HomeState.initial() : this(status: HomeLoadingStatus.initial);
  HomeState copyWith({HomeLoadingStatus? status, String? errorMessage}) {
    return HomeState(
      status: status ?? this.status,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}
@riverpod
class HomeViewModel extends _$HomeViewModel {
  @override
  HomeState build() {
    return const HomeState.initial();
  }
  Future<void> loadInitialData() async {
    debugPrint('[HomeViewModel] loadInitialData - Starting...');
    if (state.status == HomeLoadingStatus.loading) {
      debugPrint('[HomeViewModel] loadInitialData - Already loading, skipping');
      return;
    }
    debugPrint('[HomeViewModel] loadInitialData - Setting state to loading');
    state = state.copyWith(status: HomeLoadingStatus.loading);
    try {
      final user = ref.read(currentUserProvider);
      debugPrint(
        '[HomeViewModel] loadInitialData - Current user: ${user?.id ?? 'null'}',
      );
      debugPrint('[HomeViewModel] loadInitialData - Loading stats data');
      await ref.read(loadAllStatsProvider(refreshCache: false).future);
      debugPrint(
        '[HomeViewModel] loadInitialData - Stats data loaded successfully',
      );
      if (user != null) {
        debugPrint(
          '[HomeViewModel] loadInitialData - Loading progress data for user: ${user.id}',
        );
        final progressNotifier = ref.read(progressStateProvider.notifier);
        debugPrint(
          '[HomeViewModel] loadInitialData - Current progress state: ${ref.read(progressStateProvider).valueOrNull?.length ?? 0} items',
        );
        await progressNotifier.loadDueProgress(user.id);
        final progressAfter = ref.read(progressStateProvider).valueOrNull;
        debugPrint(
          '[HomeViewModel] loadInitialData - Progress data loaded. Items count: ${progressAfter?.length ?? 0}',
        );
        if (progressAfter != null && progressAfter.isNotEmpty) {
          debugPrint(
            '[HomeViewModel] loadInitialData - First progress item: id=${progressAfter.first.id}, moduleTitle=${progressAfter.first.moduleTitle ?? "N/A"}',
          );
          final now = DateTime.now();
          final today = DateTime(now.year, now.month, now.day);
          final dueTasks = progressAfter.where((task) {
            if (task.nextStudyDate == null) return false;
            final dueDate = DateTime(
              task.nextStudyDate!.year,
              task.nextStudyDate!.month,
              task.nextStudyDate!.day,
            );
            return !dueDate.isAfter(today);
          }).toList();
          debugPrint(
            '[HomeViewModel] loadInitialData - Due tasks count: ${dueTasks.length}',
          );
          for (int i = 0; i < dueTasks.length && i < 3; i++) {
            final task = dueTasks[i];
            final dueDate = task.nextStudyDate != null
                ? '${task.nextStudyDate!.year}-${task.nextStudyDate!.month}-${task.nextStudyDate!.day}'
                : 'null';
            debugPrint(
              '[HomeViewModel] loadInitialData - Due task $i: id=${task.id}, moduleTitle=${task.moduleTitle ?? "N/A"}, dueDate=$dueDate',
            );
          }
        }
      } else {
        debugPrint(
          '[HomeViewModel] loadInitialData - No user logged in, skipping progress loading',
        );
      }
      debugPrint('[HomeViewModel] loadInitialData - Setting state to loaded');
      state = state.copyWith(status: HomeLoadingStatus.loaded);
      debugPrint('[HomeViewModel] loadInitialData - Completed successfully');
    } catch (e, stackTrace) {
      debugPrint('[HomeViewModel] loadInitialData - Error: $e');
      debugPrint('[HomeViewModel] loadInitialData - Stack trace: $stackTrace');
      state = state.copyWith(
        status: HomeLoadingStatus.error,
        errorMessage: e.toString(),
      );
      debugPrint('[HomeViewModel] loadInitialData - Set error state');
    }
  }
  Future<void> refreshData() async {
    try {
      final user = ref.read(currentUserProvider);
      await ref.read(loadAllStatsProvider(refreshCache: true).future);
      if (user != null) {
        await ref.read(progressStateProvider.notifier).loadDueProgress(user.id);
      }
      state = state.copyWith(status: HomeLoadingStatus.loaded);
    } catch (e) {
      debugPrint('Error refreshing data: $e');
      state = state.copyWith(
        status: HomeLoadingStatus.error,
        errorMessage: e.toString(),
      );
    }
  }
  bool get isFirstLoading =>
      state.status == HomeLoadingStatus.initial ||
      (state.status == HomeLoadingStatus.loading && state.errorMessage == null);
  bool get hasError => state.status == HomeLoadingStatus.error;
  bool get isLoaded => state.status == HomeLoadingStatus.loaded;
}

// D:/workspace/spaced_learning_app/lib/domain/models/learning_module.dart
CycleStudied? _parseCycleStudied(String? value) {
  if (value == null) return null;
  const map = {
    'FIRST_TIME': CycleStudied.firstTime,
    'FIRST_REVIEW': CycleStudied.firstReview,
    'SECOND_REVIEW': CycleStudied.secondReview,
    'THIRD_REVIEW': CycleStudied.thirdReview,
    'MORE_THAN_THREE_REVIEWS': CycleStudied.moreThanThreeReviews,
  };
  return map[value.toUpperCase()]; // Case-insensitive matching
}
String? _serializeCycleStudied(CycleStudied? cycle) {
  if (cycle == null) return null;
  const map = {
    CycleStudied.firstTime: 'FIRST_TIME',
    CycleStudied.firstReview: 'FIRST_REVIEW',
    CycleStudied.secondReview: 'SECOND_REVIEW',
    CycleStudied.thirdReview: 'THIRD_REVIEW',
    CycleStudied.moreThanThreeReviews: 'MORE_THAN_THREE_REVIEWS',
  };
  return map[cycle];
}
class LearningModule {
  final String bookName;
  final int bookNo;
  final String moduleTitle;
  final int moduleNo;
  final int moduleWordCount;
  final CycleStudied? progressCyclesStudied; // Changed from String?
  final DateTime? progressNextStudyDate;
  final DateTime? progressFirstLearningDate;
  final int? progressLatestPercentComplete;
  final int progressDueTaskCount;
  final String moduleId;
  final List<String>
  studyHistory; // Keep as List<String> if dates are stored as strings
  const LearningModule({
    required this.bookName,
    required this.bookNo,
    required this.moduleTitle,
    required this.moduleNo,
    required this.moduleWordCount,
    this.progressCyclesStudied, // Updated type
    this.progressNextStudyDate,
    this.progressFirstLearningDate,
    this.progressLatestPercentComplete,
    required this.progressDueTaskCount,
    required this.moduleId,
    required this.studyHistory,
  });
  factory LearningModule.fromJson(Map<String, dynamic> json) {
    return LearningModule(
      bookName: json['bookName'] ?? '',
      bookNo: json['bookNo'] ?? 0,
      moduleTitle: json['moduleTitle'] ?? '',
      moduleNo: json['moduleNo'] ?? 0,
      moduleWordCount: json['moduleWordCount'] ?? 0,
      progressCyclesStudied: _parseCycleStudied(
        json['progressCyclesStudied'] as String?,
      ),
      progressNextStudyDate:
          json['progressNextStudyDate'] != null
              ? DateTime.tryParse(json['progressNextStudyDate']) // Use tryParse
              : null,
      progressFirstLearningDate:
          json['progressFirstLearningDate'] != null
              ? DateTime.tryParse(
                json['progressFirstLearningDate'],
              ) // Use tryParse
              : null,
      progressLatestPercentComplete:
          json['progressLatestPercentComplete'] as int?,
      progressDueTaskCount: json['progressDueTaskCount'] ?? 0,
      moduleId: json['moduleId'] ?? '',
      studyHistory:
          (json['studyHistory'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          [],
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'bookName': bookName,
      'bookNo': bookNo,
      'moduleTitle': moduleTitle,
      'moduleNo': moduleNo,
      'moduleWordCount': moduleWordCount,
      'progressCyclesStudied': _serializeCycleStudied(progressCyclesStudied),
      'progressNextStudyDate': progressNextStudyDate?.toIso8601String(),
      'progressFirstLearningDate': progressFirstLearningDate?.toIso8601String(),
      'progressLatestPercentComplete': progressLatestPercentComplete,
      'progressDueTaskCount': progressDueTaskCount,
      'moduleId': moduleId,
      'studyHistory': studyHistory,
    };
  }
  bool isDueToday() {
    if (progressNextStudyDate == null) return false;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final studyDate = DateTime(
      progressNextStudyDate!.year,
      progressNextStudyDate!.month,
      progressNextStudyDate!.day,
    );
    return today.isAtSameMomentAs(studyDate);
  }
  bool isOverdue() {
    if (progressNextStudyDate == null) return false;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final studyDate = DateTime(
      progressNextStudyDate!.year,
      progressNextStudyDate!.month,
      progressNextStudyDate!.day,
    );
    return studyDate.isBefore(today);
  }
  bool isDueThisWeek() {
    if (progressNextStudyDate == null) return false;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final weekStart = today.subtract(
      Duration(days: today.weekday - 1),
    ); // Assuming Monday is 1
    final weekEnd = weekStart.add(const Duration(days: 6));
    final studyDate = DateTime(
      progressNextStudyDate!.year,
      progressNextStudyDate!.month,
      progressNextStudyDate!.day,
    );
    return !studyDate.isBefore(weekStart) && !studyDate.isAfter(weekEnd);
  }
  bool isDueThisMonth() {
    if (progressNextStudyDate == null) return false;
    final now = DateTime.now();
    return progressNextStudyDate!.year == now.year &&
        progressNextStudyDate!.month == now.month;
  }
  bool isNewModule() {
    return progressFirstLearningDate == null &&
        (progressLatestPercentComplete ?? 0) == 0;
  }
  bool isCompleted() {
    return (progressLatestPercentComplete ?? 0) >= 100;
  }
  int? getDaysSinceFirstLearning() {
    if (progressFirstLearningDate == null) return null;
    return DateTime.now().difference(progressFirstLearningDate!).inDays;
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/base_notification_service.dart
abstract class BaseNotificationService {
  final FlutterLocalNotificationsPlugin notificationsPlugin;
  final DeviceSpecificService deviceSpecificService;
  bool _isInitialized = false;
  bool _timezonesInitialized = false;
  BaseNotificationService({
    required this.notificationsPlugin,
    required this.deviceSpecificService,
  });
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    try {
      if (!await _initializeTimezones()) {
        debugPrint('Warning: Failed to initialize timezones');
      }
      if (kIsWeb) {
        debugPrint(
          'Running on web platform, skipping native notification setup',
        );
        _isInitialized = true;
        return true;
      }
      if (!await _initializeNotifications()) {
        debugPrint('Failed to initialize notifications plugin');
        return false;
      }
      _isInitialized = true;
      return true;
    } catch (e) {
      debugPrint('Error initializing NotificationService: $e');
      return false;
    }
  }
  Future<bool> _initializeTimezones() async {
    if (_timezonesInitialized) return true;
    try {
      tz.initializeTimeZones();
      final String timeZoneName = tz.local.name;
      debugPrint('Local timezone: $timeZoneName');
      _timezonesInitialized = true;
      return true;
    } catch (e) {
      debugPrint('Error initializing timezone data: $e');
      return false;
    }
  }
  Future<bool> _initializeNotifications() async {
    try {
      final AndroidInitializationSettings androidSettings =
          _getAndroidSettings();
      const iosSettings = DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );
      final initSettings = InitializationSettings(
        android: androidSettings,
        iOS: iosSettings,
      );
      final bool? initialized = await notificationsPlugin.initialize(
        initSettings,
        onDidReceiveNotificationResponse: _onNotificationTapped,
      );
      return initialized ?? false;
    } catch (e) {
      debugPrint('Error initializing notifications: $e');
      return false;
    }
  }
  AndroidInitializationSettings _getAndroidSettings() {
    return const AndroidInitializationSettings('ic_launcher');
  }
  void _onNotificationTapped(NotificationResponse response) {
    debugPrint('Notification tapped: ${response.payload}');
  }
  Future<bool> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
    bool isImportant = false,
  }) async {
    if (kIsWeb) {
      debugPrint('Notifications not supported on web platform');
      return false;
    }
    if (!_isInitialized) {
      final bool initialized = await initialize();
      if (!initialized) return false;
    }
    try {
      final notificationDetails = _getNotificationDetails(isImportant);
      await notificationsPlugin.show(
        id,
        title,
        body,
        notificationDetails,
        payload: payload,
      );
      debugPrint('Notification shown with id: $id');
      return true;
    } catch (e) {
      debugPrint('Error showing notification: $e');
      return false;
    }
  }
  NotificationDetails _getNotificationDetails(bool isImportant) {
    throw UnimplementedError(
      '_getNotificationDetails must be implemented by subclasses',
    );
  }
  tz.TZDateTime convertToTZDateTime(DateTime scheduledTime) {
    try {
      return tz.TZDateTime.from(scheduledTime, tz.local);
    } catch (e) {
      debugPrint('Error converting to TZ datetime: $e');
      return tz.TZDateTime.from(scheduledTime, tz.UTC);
    }
  }
  Future<bool> cancelNotification(int id) async {
    if (kIsWeb) {
      debugPrint('Notifications not supported on web platform');
      return false;
    }
    if (!_isInitialized) {
      debugPrint(
        'Notification service not initialized, skipping cancel notification',
      );
      return false;
    }
    try {
      await notificationsPlugin.cancel(id);
      debugPrint('Notification cancelled with id: $id');
      return true;
    } catch (e) {
      debugPrint('Error cancelling notification $id: $e');
      return false;
    }
  }
  Future<bool> cancelAllNotifications() async {
    if (kIsWeb) {
      debugPrint('Notifications not supported on web platform');
      return false;
    }
    if (!_isInitialized) {
      debugPrint(
        'Notification service not initialized, skipping cancel all notifications',
      );
      return false;
    }
    try {
      await notificationsPlugin.cancelAll();
      debugPrint('All notifications cancelled');
      return true;
    } catch (e) {
      debugPrint('Error cancelling all notifications: $e');
      return false;
    }
  }
  bool get isInitialized => _isInitialized;
  bool get timezonesInitialized => _timezonesInitialized;
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/progress_card.dart
class ProgressCard extends ConsumerWidget {
  final ProgressDetail progress;
  final bool isDue;
  final String? subtitle;
  final VoidCallback? onTap;
  const ProgressCard({
    super.key,
    required this.progress,
    this.isDue = false,
    this.subtitle,
    this.onTap,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;
    return Card(
      margin: const EdgeInsets.symmetric(
        vertical: AppDimens.spaceXS,
        horizontal: AppDimens.spaceXXS,
      ),
      color: colorScheme.surface,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(AppDimens.radiusL),
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingL),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeaderRow(colorScheme, textTheme),
              if (progress.repetitions.isNotEmpty) ...[
                const SizedBox(height: AppDimens.spaceS),
                _buildRepetitionCountBadge(colorScheme, textTheme),
              ],
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildHeaderRow(ColorScheme colorScheme, TextTheme textTheme) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildProgressIndicator(colorScheme),
        const SizedBox(width: AppDimens.spaceL),
        _buildProgressDetails(colorScheme, textTheme),
        if (isDue) _buildDueIndicator(colorScheme),
      ],
    );
  }
  Widget _buildProgressIndicator(ColorScheme colorScheme) {
    return SizedBox(
      width: AppDimens.circularProgressSizeL,
      height: AppDimens.circularProgressSizeL,
      child: CircularProgressIndicator(
        value: progress.percentComplete / 100,
        backgroundColor: colorScheme.surfaceContainerHighest,
        strokeWidth: AppDimens.lineProgressHeight,
        valueColor: AlwaysStoppedAnimation<Color>(
          _getProgressColor(progress.percentComplete, colorScheme),
        ),
      ),
    );
  }
  Color _getProgressColor(double percent, ColorScheme colorScheme) {
    if (percent >= 90) return colorScheme.tertiary;
    if (percent >= 60) return colorScheme.primary;
    if (percent >= 30) return colorScheme.secondary;
    return colorScheme.error;
  }
  Widget _buildProgressDetails(ColorScheme colorScheme, TextTheme textTheme) {
    final dateFormat = DateFormat('MMM dd, yyyy');
    final nextStudyText = progress.nextStudyDate != null
        ? dateFormat.format(progress.nextStudyDate!)
        : 'Not scheduled';
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            progress.moduleTitle ?? 'Module ${progress.moduleId}',
            style: textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: colorScheme.onSurface,
            ),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
          if (subtitle != null) ...[
            const SizedBox(height: AppDimens.spaceXS),
            Text(
              subtitle!,
              style: textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
          const SizedBox(height: AppDimens.spaceXS),
          Text(
            'Next study: $nextStudyText',
            style: textTheme.bodySmall?.copyWith(
              color: isDue ? colorScheme.primary : colorScheme.onSurfaceVariant,
              fontWeight: isDue ? FontWeight.bold : null,
            ),
          ),
          const SizedBox(height: AppDimens.spaceXS),
          Text(
            'Progress: ${progress.percentComplete.toInt()}%',
            style: textTheme.bodySmall?.copyWith(
              color: colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildDueIndicator(ColorScheme colorScheme) {
    return Padding(
      padding: const EdgeInsets.only(left: AppDimens.spaceS),
      child: Icon(Icons.notifications_active, color: colorScheme.error),
    );
  }
  Widget _buildRepetitionCountBadge(
    ColorScheme colorScheme,
    TextTheme textTheme,
  ) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingS,
        vertical: AppDimens.paddingXS,
      ),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerHigh,
        borderRadius: BorderRadius.circular(AppDimens.radiusXS),
      ),
      child: Text(
        'Repetitions: ${progress.repetitions.length}',
        style: textTheme.bodySmall?.copyWith(
          color: colorScheme.onSurfaceVariant,
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/data/repositories/repetition_repository_impl.dart
class RepetitionRepositoryImpl implements RepetitionRepository {
  final ApiClient _apiClient;
  RepetitionRepositoryImpl(this._apiClient);
  @override
  Future<List<Repetition>> getRepetitionsByProgressId(String progressId) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.repetitionsByProgress(progressId),
      );
      if (response['success'] != true || response['data'] == null) {
        return [];
      }
      final List<dynamic> repetitionList = response['data'];
      return repetitionList.map((item) => Repetition.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get repetitions by progress: $e');
    }
  }
  @override
  Future<List<Repetition>> createDefaultSchedule(
    String moduleProgressId,
  ) async {
    try {
      final response = await _apiClient.post(
        ApiEndpoints.repetitionSchedule(moduleProgressId),
      );
      if (response['success'] != true || response['data'] == null) {
        throw BadRequestException(
          'Failed to create repetition schedule: ${response['message']}',
        );
      }
      final List<dynamic> repetitionList = response['data'];
      return repetitionList.map((item) => Repetition.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to create repetition schedule: $e');
    }
  }
  @override
  Future<Repetition> updateRepetition(
    String id, {
    RepetitionStatus? status,
    DateTime? reviewDate,
    bool rescheduleFollowing = false,
    double? percentComplete,
  }) async {
    try {
      if (status == null && reviewDate == null) {
        throw BadRequestException(
          'Either status or reviewDate must be provided',
        );
      }
      if (status != null) {
        return await _updateCompletionStatus(id, status, percentComplete);
      }
      return await _rescheduleRepetition(id, reviewDate!, rescheduleFollowing);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to update repetition: $e');
    }
  }
  Future<Repetition> _updateCompletionStatus(
    String id,
    RepetitionStatus status,
    double? percentComplete,
  ) async {
    final data = <String, dynamic>{
      'status': status.toString().split('.').last.toUpperCase(),
    };
    if (percentComplete != null) {
      data['score'] = percentComplete;
    }
    final response = await _apiClient.put(
      '${ApiEndpoints.repetitions}/$id/complete',
      data: data,
    );
    final bool isSuccessful =
        response['success'] == true && response['data'] != null;
    if (!isSuccessful) {
      throw BadRequestException(
        'Failed to update repetition status: ${response['message']}',
      );
    }
    return Repetition.fromJson(response['data']);
  }
  Future<Repetition> _rescheduleRepetition(
    String id,
    DateTime reviewDate,
    bool rescheduleFollowing,
  ) async {
    final data = <String, dynamic>{
      'reviewDate': _formatDate(reviewDate),
      'rescheduleFollowing': rescheduleFollowing,
    };
    final response = await _apiClient.put(
      '${ApiEndpoints.repetitions}/$id/reschedule',
      data: data,
    );
    final bool isSuccessful =
        response['success'] == true && response['data'] != null;
    if (!isSuccessful) {
      throw BadRequestException(
        'Failed to reschedule repetition: ${response['message']}',
      );
    }
    return Repetition.fromJson(response['data']);
  }
  @override
  Future<int> countByModuleProgressId(String moduleProgressId) async {
    try {
      final response = await _apiClient.get(
        '${ApiEndpoints.repetitions}/count',
        queryParameters: {'moduleProgressId': moduleProgressId},
      );
      if (response['success'] == true && response['data'] != null) {
        return response['data'] as int;
      }
      final repetitions = await getRepetitionsByProgressId(moduleProgressId);
      return repetitions.length;
    } catch (e) {
      final repetitions = await getRepetitionsByProgressId(moduleProgressId);
      return repetitions.length;
    }
  }
  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/quick_actions_section.dart
class QuickActionsSection extends StatelessWidget {
  final VoidCallback onBrowseBooksPressed;
  final VoidCallback onTodaysLearningPressed;
  final VoidCallback onProgressReportPressed;
  final VoidCallback onVocabularyStatsPressed;
  const QuickActionsSection({
    super.key,
    required this.onBrowseBooksPressed,
    required this.onTodaysLearningPressed,
    required this.onProgressReportPressed,
    required this.onVocabularyStatsPressed,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(
            horizontal: AppDimens.paddingS,
            vertical: AppDimens.paddingM,
          ),
          child: Text(
            'Quick Actions',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: colorScheme.onSurface,
            ),
          ),
        ),
        GridView.count(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          crossAxisCount: 2,
          crossAxisSpacing: AppDimens.gridSpacingL,
          mainAxisSpacing: AppDimens.gridSpacingL,
          childAspectRatio: 1.1,
          padding: const EdgeInsets.all(AppDimens.paddingS),
          children: [
            _buildActionCard(
              context: context,
              title: 'Browse Books',
              icon: Icons.menu_book_outlined,
              onTap: onBrowseBooksPressed,
              index: 0,
            ),
            _buildActionCard(
              context: context,
              title: 'Today\'s Learning',
              icon: Icons.assignment_turned_in_outlined,
              onTap: onTodaysLearningPressed,
              index: 1,
            ),
            _buildActionCard(
              context: context,
              title: 'Progress Report',
              icon: Icons.bar_chart_outlined,
              onTap: onProgressReportPressed,
              index: 2,
            ),
            _buildActionCard(
              context: context,
              title: 'Vocabulary Stats',
              icon: Icons.translate_outlined,
              onTap: onVocabularyStatsPressed,
              index: 3,
            ),
          ],
        ),
      ],
    );
  }
  Widget _buildActionCard({
    required BuildContext context,
    required String title,
    required IconData icon,
    required VoidCallback onTap,
    required int index,
  }) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final List<Color> cardColors = [
      colorScheme.primary,
      colorScheme.secondary,
      colorScheme.tertiary,
      colorScheme.primary,
    ];
    final cardColor = cardColors[index % cardColors.length];
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: 1),
      duration: Duration(milliseconds: 400 + (index * 100)),
      builder: (context, value, child) {
        return Opacity(
          opacity: value,
          child: Transform.translate(
            offset: Offset(0, 20 * (1 - value)),
            child: child,
          ),
        );
      },
      child: Card(
        elevation: 0,
        color: colorScheme.surface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimens.radiusL),
          side: BorderSide(
            color: cardColor.withValues(alpha: AppDimens.opacitySemi),
            width: 1,
          ),
        ),
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(AppDimens.radiusL),
          child: Padding(
            padding: const EdgeInsets.all(AppDimens.paddingL),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Container(
                  padding: const EdgeInsets.all(AppDimens.paddingM),
                  decoration: BoxDecoration(
                    color: cardColor.withValues(alpha: AppDimens.opacityLight),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(icon, color: cardColor, size: AppDimens.iconL),
                ),
                const SizedBox(height: AppDimens.spaceM),
                Text(
                  title,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: colorScheme.onSurface,
                  ),
                  textAlign: TextAlign.center,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/theme/app_color_scheme.dart
const ColorScheme geminiLightColorScheme = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xff65558f),
  surfaceTint: Color(0xff65558f),
  onPrimary: Color(0xffffffff),
  primaryContainer: Color(0xffe9ddff),
  onPrimaryContainer: Color(0xff4d3d75),
  secondary: Color(0xff625b70),
  onSecondary: Color(0xffffffff),
  secondaryContainer: Color(0xffe8def8),
  onSecondaryContainer: Color(0xff4a4458),
  tertiary: Color(0xff7e5260),
  onTertiary: Color(0xffffffff),
  tertiaryContainer: Color(0xffffd9e3),
  onTertiaryContainer: Color(0xff633b48),
  error: Color(0xffba1a1a),
  onError: Color(0xffffffff),
  errorContainer: Color(0xffffdad6),
  onErrorContainer: Color(0xff93000a),
  surface: Color(0xfffdf7ff),
  onSurface: Color(0xff1d1b20),
  onSurfaceVariant: Color(0xff49454e),
  outline: Color(0xff7a757f),
  outlineVariant: Color(0xffcac4cf),
  shadow: Color(0xff000000),
  scrim: Color(0xff000000),
  inverseSurface: Color(0xff322f35),
  inversePrimary: Color(0xffcfbdfe),
  primaryFixed: Color(0xffe9ddff),
  onPrimaryFixed: Color(0xff211047),
  primaryFixedDim: Color(0xffcfbdfe),
  onPrimaryFixedVariant: Color(0xff4d3d75),
  secondaryFixed: Color(0xffe8def8),
  onSecondaryFixed: Color(0xff1e192b),
  secondaryFixedDim: Color(0xffccc2db),
  onSecondaryFixedVariant: Color(0xff4a4458),
  tertiaryFixed: Color(0xffffd9e3),
  onTertiaryFixed: Color(0xff31101d),
  tertiaryFixedDim: Color(0xffefb8c8),
  onTertiaryFixedVariant: Color(0xff633b48),
  surfaceDim: Color(0xffded8e0),
  surfaceBright: Color(0xfffdf7ff),
  surfaceContainerLowest: Color(0xffffffff),
  surfaceContainerLow: Color(0xfff8f2fa),
  surfaceContainer: Color(0xfff2ecf4),
  surfaceContainerHigh: Color(0xffece6ee),
  surfaceContainerHighest: Color(0xffe6e0e9),
);
const ColorScheme geminiDarkColorScheme = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xffcfbdfe),
  surfaceTint: Color(0xffcfbdfe),
  onPrimary: Color(0xff36265d),
  primaryContainer: Color(0xff4d3d75),
  onPrimaryContainer: Color(0xffe9ddff),
  secondary: Color(0xffccc2db),
  onSecondary: Color(0xff332d41),
  secondaryContainer: Color(0xff4a4458),
  onSecondaryContainer: Color(0xffe8def8),
  tertiary: Color(0xffefb8c8),
  onTertiary: Color(0xff4a2532),
  tertiaryContainer: Color(0xff633b48),
  onTertiaryContainer: Color(0xffffd9e3),
  error: Color(0xffffb4ab),
  onError: Color(0xff690005),
  errorContainer: Color(0xff93000a),
  onErrorContainer: Color(0xffffdad6),
  surface: Color(0xff141218),
  onSurface: Color(0xffe6e0e9),
  onSurfaceVariant: Color(0xffcac4cf),
  outline: Color(0xff948f99),
  outlineVariant: Color(0xff49454e),
  shadow: Color(0xff000000),
  scrim: Color(0xff000000),
  inverseSurface: Color(0xffe6e0e9),
  inversePrimary: Color(0xff65558f),
  primaryFixed: Color(0xffe9ddff),
  onPrimaryFixed: Color(0xff211047),
  primaryFixedDim: Color(0xffcfbdfe),
  onPrimaryFixedVariant: Color(0xff4d3d75),
  secondaryFixed: Color(0xffe8def8),
  onSecondaryFixed: Color(0xff1e192b),
  secondaryFixedDim: Color(0xffccc2db),
  onSecondaryFixedVariant: Color(0xff4a4458),
  tertiaryFixed: Color(0xffffd9e3),
  onTertiaryFixed: Color(0xff31101d),
  tertiaryFixedDim: Color(0xffefb8c8),
  onTertiaryFixedVariant: Color(0xff633b48),
  surfaceDim: Color(0xff141218),
  surfaceBright: Color(0xff3b383e),
  surfaceContainerLowest: Color(0xff0f0d13),
  surfaceContainerLow: Color(0xff1d1b20),
  surfaceContainer: Color(0xff211f24),
  surfaceContainerHigh: Color(0xff2b292f),
  surfaceContainerHighest: Color(0xff36343a),
);
const List<Color> primaryGradient = [
  Color(0xff65558f), // Light primary
  Color(0xffcfbdfe), // Dark primary
];
const List<Color> greyGradient = [
  Color(0xfff8f2fa), // Light surfaceContainerLow
  Color(0xffe6e0e9), // Light surfaceContainerHighest
];
const Color primaryAlpha10 = Color(0x1A65558f); // 10% alpha of light primary
const Color primaryAlpha20 = Color(0x3365558f); // 20% alpha of light primary
const Color greyAlpha10 = Color(
  0x1A49454e,
); // 10% alpha of light onSurfaceVariant
const Color successGreen = Color(0xff2e7d32); // Material Design green
const Color warningOrange = Color(0xfff57c00); // Material Design orange
const Color textPlaceholder = Color(0xff7a757f); // Light outline as placeholder
const Color borderLight = Color(0xffcac4cf); // Light outlineVariant
const Color borderMedium = Color(0xff7a757f); // Light outline
const Color divider = Color(0xffcac4cf); // Light outlineVariant
const Color hoverGrey = Color(0xfff2ecf4); // Light surfaceContainer
const Color activeGrey = Color(0xffece6ee); // Light surfaceContainerHigh
const Color disabledBackground = Color(
  0xffe6e0e9,
); // Light surfaceContainerHighest
const Color disabledContent = Color(0xff7a757f); // Light outline
const Color darkTextSecondary = Color(0xffcac4cf); // Dark onSurfaceVariant
const Color darkBorder = Color(0xff948f99); // Dark outline

// D:/workspace/spaced_learning_app/lib/core/services/learning_data_service_impl.dart
class LearningDataServiceImpl implements LearningDataService {
  final LearningProgressRepository _repository;
  List<LearningModule>? _cachedModules;
  LearningDataServiceImpl(this._repository);
  @override
  Future<List<LearningModule>> getModules() async {
    if (_cachedModules != null) {
      return _cachedModules!;
    }
    try {
      final modules = await _repository.getAllModules();
      _cachedModules = modules;
      return modules;
    } catch (e) {
      return [];
    }
  }
  @override
  List<LearningModule> filterByBook(List<LearningModule> modules, String book) {
    if (book == 'All') {
      return modules;
    }
    return modules.where((module) => module.bookName == book).toList();
  }
  @override
  List<LearningModule> filterByDate(
    List<LearningModule> modules,
    DateTime date,
  ) {
    return modules
        .where(
          (module) =>
              module.progressNextStudyDate != null &&
              isSameDay(module.progressNextStudyDate!, date),
        )
        .toList();
  }
  @override
  bool isSameDay(DateTime date1, DateTime date2) {
    return date1.year == date2.year &&
        date1.month == date2.month &&
        date1.day == date2.day;
  }
  @override
  int countDueModules(List<LearningModule> modules, {int daysThreshold = 7}) {
    final today = DateTime.now();
    final dueDate = today.add(Duration(days: daysThreshold));
    return modules
        .where(
          (module) =>
              module.progressNextStudyDate != null &&
              module.progressNextStudyDate!.isAfter(
                today.subtract(const Duration(days: 1)),
              ) &&
              module.progressNextStudyDate!.isBefore(dueDate),
        )
        .length;
  }
  @override
  int countCompletedModules(List<LearningModule> modules) {
    return modules
        .where((module) => (module.progressLatestPercentComplete ?? 0) == 100)
        .length;
  }
  @override
  List<String> getUniqueBooks(List<LearningModule> modules) {
    if (modules.isEmpty) return ['All'];
    final books = modules.map((module) => module.bookName).toSet().toList()
      ..sort();
    return ['All', ...books];
  }
  @override
  Future<bool> exportData() async {
    try {
      final result = await _repository.exportData();
      return result.isNotEmpty && (result['success'] == true);
    } catch (e) {
      return false;
    }
  }
  @override
  int getActiveModulesCount(List<LearningModule> modules) {
    return modules
        .where((module) => (module.progressLatestPercentComplete ?? 0) < 100)
        .length;
  }
  @override
  List<LearningModule> getDueToday(List<LearningModule> modules) {
    final today = DateTime.now();
    return modules
        .where(
          (module) =>
              module.progressNextStudyDate != null &&
              isSameDay(module.progressNextStudyDate!, today),
        )
        .toList();
  }
  @override
  List<LearningModule> getDueThisWeek(List<LearningModule> modules) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final weekStart = today.subtract(Duration(days: today.weekday - 1));
    final weekEnd = weekStart.add(const Duration(days: 6));
    return modules
        .where(
          (module) =>
              module.progressNextStudyDate != null &&
              module.progressNextStudyDate!.isAfter(
                weekStart.subtract(const Duration(days: 1)),
              ) &&
              module.progressNextStudyDate!.isBefore(
                weekEnd.add(const Duration(days: 1)),
              ),
        )
        .toList();
  }
  @override
  List<LearningModule> getDueThisMonth(List<LearningModule> modules) {
    final now = DateTime.now();
    final monthStart = DateTime(now.year, now.month, 1);
    final monthEnd = (now.month < 12)
        ? DateTime(now.year, now.month + 1, 0)
        : DateTime(now.year + 1, 1, 0);
    return modules
        .where(
          (module) =>
              module.progressNextStudyDate != null &&
              module.progressNextStudyDate!.isAfter(
                monthStart.subtract(const Duration(days: 1)),
              ) &&
              module.progressNextStudyDate!.isBefore(
                monthEnd.add(const Duration(days: 1)),
              ),
        )
        .toList();
  }
  @override
  Future<Map<String, dynamic>> getDashboardStats({
    String? book,
    DateTime? date,
  }) async {
    try {
      return await _repository.getDashboardStats(book: book, date: date);
    } catch (e) {
      return {};
    }
  }
  @override
  void resetCache() {
    _cachedModules = null;
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/book_cover.dart
class BookCover extends StatelessWidget {
  final BookSummary book;
  final ThemeData theme;
  const BookCover({super.key, required this.book, required this.theme});
  @override
  Widget build(BuildContext context) {
    final colorScheme = theme.colorScheme;
    final bookIdHash = book.id.hashCode;
    final hue = (bookIdHash % 360).abs().toDouble();
    const saturation = 0.6;
    const lightness = 0.75;
    final coverColor = HSLColor.fromAHSL(
      1.0,
      hue,
      saturation,
      lightness,
    ).toColor();
    return Container(
      width: AppDimens.thumbnailSizeS,
      height: AppDimens.thumbnailSizeM * 0.85,
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            coverColor,
            coverColor.withValues(alpha: AppDimens.opacityVeryHigh),
          ],
        ),
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
        boxShadow: [
          BoxShadow(
            color: colorScheme.shadow.withValues(alpha: AppDimens.opacitySemi),
            blurRadius: AppDimens.shadowRadiusM,
            offset: const Offset(0, AppDimens.shadowOffsetS),
          ),
        ],
      ),
      child: Stack(
        children: [
          ClipRRect(
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
            child: CustomPaint(
              painter: _BookPatternPainter(
                patternColor: colorScheme.onPrimary.withValues(
                  alpha: AppDimens.opacitySemi,
                ),
                lineCount: 3,
              ),
              size: const Size(
                AppDimens.thumbnailSizeS,
                AppDimens.thumbnailSizeM * 0.85,
              ),
            ),
          ),
          Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.menu_book,
                  size: AppDimens.iconL,
                  color: colorScheme.onPrimary.withValues(
                    alpha: AppDimens.opacityFull,
                  ),
                ),
                const SizedBox(height: AppDimens.spaceXS),
                Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: AppDimens.paddingXS,
                  ),
                  child: Text(
                    book.name,
                    style: theme.textTheme.labelSmall?.copyWith(
                      color: colorScheme.onPrimary,
                      fontWeight: FontWeight.bold,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
          ),
          if (book.category != null)
            Positioned(
              bottom: 0,
              left: 0,
              right: 0,
              child: Container(
                padding: const EdgeInsets.symmetric(vertical: 2),
                decoration: BoxDecoration(
                  color: colorScheme.shadow.withValues(
                    alpha: AppDimens.opacityMediumHigh,
                  ),
                  borderRadius: const BorderRadius.only(
                    bottomLeft: Radius.circular(AppDimens.radiusM),
                    bottomRight: Radius.circular(AppDimens.radiusM),
                  ),
                ),
                child: Text(
                  book.category ?? '',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: colorScheme.onPrimary,
                    fontSize: 8,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  textAlign: TextAlign.center,
                ),
              ),
            ),
        ],
      ),
    );
  }
}
class _BookPatternPainter extends CustomPainter {
  final Color patternColor;
  final int lineCount;
  _BookPatternPainter({required this.patternColor, required this.lineCount});
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = patternColor
      ..strokeWidth = 0.8
      ..style = PaintingStyle.stroke;
    final spacingY = size.height / (lineCount + 1);
    for (int i = 1; i <= lineCount; i++) {
      final y = spacingY * i;
      canvas.drawLine(Offset(0, y), Offset(size.width, y), paint);
    }
    canvas.drawLine(const Offset(0, 0), Offset(size.width, size.height), paint);
    canvas.drawRect(Rect.fromLTWH(0, 0, size.width, size.height), paint);
  }
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/home/widgets/home_content.dart
class HomeContent extends ConsumerWidget {
  final Future<void> Function() onRefresh;
  final AnimationController animationController;
  final Animation<double> fadeAnimation;
  const HomeContent({
    super.key,
    required this.onRefresh,
    required this.animationController,
    required this.fadeAnimation,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(currentUserProvider);
    if (user == null) {
      return const Center(child: Text('Please log in to view your content'));
    }
    return RefreshIndicator(
      onRefresh: onRefresh,
      color: Theme.of(context).colorScheme.primary,
      backgroundColor: Theme.of(context).colorScheme.surface,
      child: SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: FadeTransition(
          opacity: fadeAnimation,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Center(child: HomeHeader(user: user)),
              const SizedBox(height: AppDimens.spaceXL),
              const DashboardSection(),
              const SizedBox(height: AppDimens.spaceXL),
              const LearningInsightsSection(),
              const SizedBox(height: AppDimens.spaceXL),
              Consumer(
                builder: (context, ref, _) => const DueTasksSectionWidget(),
              ),
              const SizedBox(height: AppDimens.spaceXL),
              const HomeQuickActionsSection(),
              SizedBox(height: MediaQuery.of(context).size.height * 0.1),
            ],
          ),
        ),
      ),
    );
  }
}
class HomeQuickActionsSection extends ConsumerWidget {
  const HomeQuickActionsSection({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return QuickActionsSection(
      onBrowseBooksPressed: () => _navigateTo(context, '/books'),
      onTodaysLearningPressed: () => _navigateTo(context, '/due-progress'),
      onProgressReportPressed: () => _navigateTo(context, '/learning'),
      onVocabularyStatsPressed: () => _showVocabularyStatsMessage(context),
    );
  }
  void _navigateTo(BuildContext context, String route) {
    GoRouter.of(context).go(route);
  }
  void _showVocabularyStatsMessage(BuildContext context) {
    final theme = Theme.of(context);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(
          'Vocabulary stats coming soon',
          style: TextStyle(color: theme.colorScheme.onPrimary),
        ),
        backgroundColor: theme.colorScheme.primary,
      ),
    );
  }
}
class DueTasksSectionWidget extends ConsumerWidget {
  const DueTasksSectionWidget({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final progressAsync = ref.watch(progressStateProvider);
    return progressAsync.when(
      data: (records) {
        final now = DateTime.now();
        final today = DateTime(now.year, now.month, now.day);
        final due = records.where((e) {
          final d = e.nextStudyDate?.toLocal();
          if (d == null) return false;
          final n = DateTime(d.year, d.month, d.day);
          return !n.isAfter(today);
        }).toList();
        debugPrint('[DueTasksSectionWidget] Filtered ${due.length} due tasks');
        return DueTasksSection(
          tasks: due,
          onViewAllTasks: () => _navigateTo(context, '/due-progress'),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, _) {
        debugPrint('[DueTasksSectionWidget] Error: $err');
        return const SizedBox.shrink();
      },
    );
  }
  void _navigateTo(BuildContext context, String route) {
    GoRouter.of(context).go(route);
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/notification_service.dart
class NotificationService {
  late final ReminderNotificationService _reminderService;
  NotificationService({required DeviceSpecificService deviceSpecificService}) {
    final notificationsPlugin = FlutterLocalNotificationsPlugin();
    _reminderService = ReminderNotificationService(
      deviceSpecificService: deviceSpecificService,
      notificationsPlugin: notificationsPlugin,
    );
  }
  static const int noonReminderId = ReminderNotificationService.noonReminderId;
  static const int eveningFirstReminderId =
      ReminderNotificationService.eveningFirstReminderId;
  static const int eveningSecondReminderId =
      ReminderNotificationService.eveningSecondReminderId;
  static const int endOfDayReminderId =
      ReminderNotificationService.endOfDayReminderId;
  Future<bool> initialize() async {
    return _reminderService.initialize();
  }
  Future<bool> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
    bool isImportant = false,
  }) async {
    return _reminderService.showNotification(
      id: id,
      title: title,
      body: body,
      payload: payload,
      isImportant: isImportant,
    );
  }
  Future<bool> scheduleNotification({
    required int id,
    required String title,
    required String body,
    required DateTime scheduledTime,
    String? payload,
    bool isImportant = false,
    bool isAlarmStyle = false,
  }) async {
    return _reminderService.scheduleNotification(
      id: id,
      title: title,
      body: body,
      scheduledTime: scheduledTime,
      payload: payload,
      isImportant: isImportant,
      isAlarmStyle: isAlarmStyle,
    );
  }
  Future<bool> cancelNotification(int id) async {
    return _reminderService.cancelNotification(id);
  }
  Future<bool> cancelAllNotifications() async {
    return _reminderService.cancelAllNotifications();
  }
  Future<bool> scheduleNoonReminder() async {
    return _reminderService.scheduleNoonReminder();
  }
  Future<bool> scheduleEveningFirstReminder() async {
    return _reminderService.scheduleEveningFirstReminder();
  }
  Future<bool> scheduleEveningSecondReminder() async {
    return _reminderService.scheduleEveningSecondReminder();
  }
  Future<bool> scheduleEndOfDayReminder({bool useAlarmStyle = false}) async {
    return _reminderService.scheduleEndOfDayReminder(
      useAlarmStyle: useAlarmStyle,
    );
  }
  bool get isInitialized => _reminderService.isInitialized;
  bool get timezonesInitialized => _reminderService.timezonesInitialized;
}
@riverpod
class NotificationStatus extends _$NotificationStatus {
  @override
  Future<bool> build() async {
    final notificationService = await ref.watch(
      notificationServiceProvider.future,
    );
    return notificationService.isInitialized;
  }
  Future<void> initialize() async {
    state = const AsyncValue.loading();
    final notificationService = await ref.read(
      notificationServiceProvider.future,
    );
    state = await AsyncValue.guard(() async {
      return notificationService.initialize();
    });
  }
  Future<bool> scheduleReminder(ReminderType type) async {
    final notificationService = await ref.read(
      notificationServiceProvider.future,
    );
    switch (type) {
      case ReminderType.noon:
        return notificationService.scheduleNoonReminder();
      case ReminderType.eveningFirst:
        return notificationService.scheduleEveningFirstReminder();
      case ReminderType.eveningSecond:
        return notificationService.scheduleEveningSecondReminder();
      case ReminderType.endOfDay:
        return notificationService.scheduleEndOfDayReminder();
    }
  }
  Future<bool> cancelReminder(int id) async {
    final notificationService = await ref.read(
      notificationServiceProvider.future,
    );
    return notificationService.cancelNotification(id);
  }
  Future<bool> cancelAllReminders() async {
    final notificationService = await ref.read(
      notificationServiceProvider.future,
    );
    return notificationService.cancelAllNotifications();
  }
}
enum ReminderType { noon, eveningFirst, eveningSecond, endOfDay }

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/home_skeleton_screen.dart
class HomeSkeletonScreen extends StatelessWidget {
  const HomeSkeletonScreen({super.key});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return SingleChildScrollView(
      padding: const EdgeInsets.all(AppDimens.paddingL),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSkeletonWelcome(theme, colorScheme),
          const SizedBox(height: AppDimens.spaceXL),
          _buildSkeletonCard(theme, colorScheme, 200),
          const SizedBox(height: AppDimens.spaceXL),
          _buildSkeletonCard(theme, colorScheme, 180),
          const SizedBox(height: AppDimens.spaceXL),
          _buildSkeletonCard(theme, colorScheme, 150),
          const SizedBox(height: AppDimens.spaceXL),
          _buildSkeletonActions(theme, colorScheme),
          SizedBox(height: MediaQuery.of(context).size.height * 0.1),
        ],
      ),
    );
  }
  Widget _buildSkeletonWelcome(ThemeData theme, ColorScheme colorScheme) {
    return Center(
      child: Column(
        children: [
          Shimmer.fromColors(
            baseColor: colorScheme.surfaceContainerHighest,
            highlightColor: colorScheme.surfaceContainerLow,
            child: Container(
              width: 200,
              height: 20,
              decoration: BoxDecoration(
                color: colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(AppDimens.radiusM),
              ),
            ),
          ),
          const SizedBox(height: AppDimens.spaceS),
          Shimmer.fromColors(
            baseColor: colorScheme.surfaceContainerHighest,
            highlightColor: colorScheme.surfaceContainerLow,
            child: Container(
              width: 150,
              height: 16,
              decoration: BoxDecoration(
                color: colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(AppDimens.radiusM),
              ),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildSkeletonCard(
    ThemeData theme,
    ColorScheme colorScheme,
    double height,
  ) {
    return Shimmer.fromColors(
      baseColor: colorScheme.surfaceContainerHighest,
      highlightColor: colorScheme.surfaceContainerLow,
      child: Container(
        width: double.infinity,
        height: height,
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainerHighest,
          borderRadius: BorderRadius.circular(AppDimens.radiusL),
        ),
      ),
    );
  }
  Widget _buildSkeletonActions(ThemeData theme, ColorScheme colorScheme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Shimmer.fromColors(
          baseColor: colorScheme.surfaceContainerHighest,
          highlightColor: colorScheme.surfaceContainerLow,
          child: Container(
            width: 120,
            height: 20,
            decoration: BoxDecoration(
              color: colorScheme.surfaceContainerHighest,
              borderRadius: BorderRadius.circular(AppDimens.radiusM),
            ),
          ),
        ),
        const SizedBox(height: AppDimens.spaceL),
        GridView.count(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          crossAxisCount: 2,
          crossAxisSpacing: AppDimens.gridSpacingL,
          mainAxisSpacing: AppDimens.gridSpacingL,
          childAspectRatio: 1.1,
          padding: const EdgeInsets.all(AppDimens.paddingS),
          children: List.generate(
            4,
            (index) => Shimmer.fromColors(
              baseColor: colorScheme.surfaceContainerHighest,
              highlightColor: colorScheme.surfaceContainerLow,
              child: Container(
                decoration: BoxDecoration(
                  color: colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(AppDimens.radiusL),
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/notification_channel_manager.dart
class NotificationChannelManager {
  final DeviceSpecificService _deviceSpecificService;
  static const String regularChannelId = 'spaced_learning_reminders';
  static const String importantChannelId =
      'spaced_learning_important_reminders';
  static const String alarmChannelId = 'spaced_learning_alarms';
  NotificationChannelManager(this._deviceSpecificService);
  Future<bool> createNotificationChannels(
    AndroidFlutterLocalNotificationsPlugin? androidPlugin,
  ) async {
    if (!_deviceSpecificService.isAndroid || androidPlugin == null) return true;
    try {
      await androidPlugin.createNotificationChannel(
        const AndroidNotificationChannel(
          regularChannelId,
          'Learning Reminders',
          description: 'Reminders for your daily learning schedule',
          importance: Importance.high,
        ),
      );
      await androidPlugin.createNotificationChannel(
        const AndroidNotificationChannel(
          importantChannelId,
          'Important Reminders',
          description: 'Urgent reminders for unfinished learning tasks',
          importance: Importance.high,
          sound: RawResourceAndroidNotificationSound('notification_sound'),
        ),
      );
      await androidPlugin.createNotificationChannel(
        const AndroidNotificationChannel(
          alarmChannelId,
          'Learning Alarms',
          description: 'Alarm-style reminders for critical learning tasks',
          importance: Importance.max,
          sound: RawResourceAndroidNotificationSound('alarm_sound'),
          playSound: true,
          enableVibration: true,
        ),
      );
      if (_deviceSpecificService.isSamsungDevice) {
        await _createSamsungSpecificChannels(androidPlugin);
      }
      return true;
    } catch (e) {
      debugPrint('Error creating notification channels: $e');
      return false;
    }
  }
  Future<bool> _createSamsungSpecificChannels(
    AndroidFlutterLocalNotificationsPlugin androidPlugin,
  ) async {
    try {
      await androidPlugin.createNotificationChannel(
        const AndroidNotificationChannel(
          'samsung_specific_channel',
          'Samsung Special Notifications',
          description: 'Optimized notifications for Samsung devices',
          importance: Importance.high,
        ),
      );
      return true;
    } catch (e) {
      debugPrint('Error creating Samsung notification channels: $e');
      return false;
    }
  }
  NotificationDetails getNotificationDetails({
    required bool isImportant,
    bool isAlarmStyle = false,
  }) {
    final androidDetails = AndroidNotificationDetails(
      isAlarmStyle
          ? alarmChannelId
          : (isImportant ? importantChannelId : regularChannelId),
      isAlarmStyle
          ? 'Learning Alarms'
          : (isImportant ? 'Important Reminders' : 'Learning Reminders'),
      channelDescription: isAlarmStyle
          ? 'Alarm-style reminders for critical learning tasks'
          : (isImportant
                ? 'Urgent reminders for unfinished learning tasks'
                : 'Reminders for your daily learning schedule'),
      importance: isAlarmStyle
          ? Importance.max
          : (isImportant ? Importance.max : Importance.high),
      priority: isAlarmStyle
          ? Priority.max
          : (isImportant ? Priority.max : Priority.high),
      category: isAlarmStyle
          ? AndroidNotificationCategory.alarm
          : (isImportant
                ? AndroidNotificationCategory.reminder
                : AndroidNotificationCategory.message),
      fullScreenIntent: isAlarmStyle,
      sound: isAlarmStyle
          ? const RawResourceAndroidNotificationSound('alarm_sound')
          : (isImportant
                ? const RawResourceAndroidNotificationSound(
                    'notification_sound',
                  )
                : null),
    );
    const iosDetails = DarwinNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
    );
    return NotificationDetails(android: androidDetails, iOS: iosDetails);
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/auth_viewmodel.dart
@Riverpod(keepAlive: true)
class AuthState extends _$AuthState {
  @override
  Future<bool> build() async {
    return _checkAuthentication();
  }
  Future<bool> _checkAuthentication() async {
    try {
      final token = await ref.read(storageServiceProvider).getToken();
      if (token == null || token.isEmpty) {
        return false;
      }
      try {
        final isValid = await ref
            .read(authRepositoryProvider)
            .validateToken(token);
        if (isValid) {
          final userData = await ref.read(storageServiceProvider).getUserData();
          if (userData != null) {
            ref
                .read(currentUserProvider.notifier)
                .updateUser(User.fromJson(userData));
          }
          return true;
        }
        await ref.read(storageServiceProvider).clearTokens();
        return false;
      } catch (e) {
        debugPrint('Token validation error: $e');
        await ref.read(storageServiceProvider).clearTokens();
        return false;
      }
    } catch (e) {
      debugPrint('Critical authentication check error: $e');
      await ref.read(storageServiceProvider).resetSecureStorage();
      return false;
    }
  }
  Future<bool> login(String usernameOrEmail, String password) async {
    state = const AsyncValue.loading();
    try {
      final response = await ref
          .read(authRepositoryProvider)
          .login(usernameOrEmail, password);
      await _handleAuthResponse(response);
      state = const AsyncValue.data(true);
      return true;
    } catch (e) {
      debugPrint('Login error: $e');
      state = AsyncValue.error(e, StackTrace.current);
      return false;
    }
  }
  Future<bool> register(
    String username,
    String email,
    String password,
    String firstName,
    String lastName,
  ) async {
    state = const AsyncValue.loading();
    try {
      final response = await ref
          .read(authRepositoryProvider)
          .register(username, email, password, firstName, lastName);
      await _handleAuthResponse(response);
      state = const AsyncValue.data(true);
      return true;
    } catch (e) {
      debugPrint('Registration error: $e');
      state = AsyncValue.error(e, StackTrace.current);
      return false;
    }
  }
  Future<void> logout() async {
    state = const AsyncValue.loading();
    try {
      await ref.read(storageServiceProvider).clearTokens();
      await ref.read(storageServiceProvider).clearUserData();
      ref.read(currentUserProvider.notifier).updateUser(null);
      state = const AsyncValue.data(false);
    } catch (e) {
      debugPrint('Logout error: $e');
      ref.read(currentUserProvider.notifier).updateUser(null);
      state = AsyncValue.error(e, StackTrace.current);
    }
  }
  Future<void> _handleAuthResponse(AuthResponse response) async {
    try {
      await ref.read(storageServiceProvider).saveToken(response.token);
      if (response.refreshToken != null) {
        await ref
            .read(storageServiceProvider)
            .saveRefreshToken(response.refreshToken!);
      }
      await ref
          .read(storageServiceProvider)
          .saveUserData(response.user.toJson());
      ref.read(currentUserProvider.notifier).updateUser(response.user);
    } catch (e) {
      debugPrint('Error handling auth response: $e');
      ref.read(currentUserProvider.notifier).updateUser(response.user);
      rethrow;
    }
  }
}
@Riverpod(keepAlive: true)
class CurrentUser extends _$CurrentUser {
  @override
  User? build() {
    return null;
  }
  void updateUser(User? user) {
    state = user;
  }
}
@riverpod
class AuthError extends _$AuthError {
  @override
  String? build() {
    final authState = ref.watch(authStateProvider);
    return authState.hasError ? authState.error.toString() : null;
  }
  void clearError() {
    state = null;
  }
}

// D:/workspace/spaced_learning_app/lib/data/repositories/book_repository_impl.dart
class BookRepositoryImpl implements BookRepository {
  final ApiClient _apiClient;
  BookRepositoryImpl(this._apiClient);
  @override
  Future<List<BookSummary>> getAllBooks({int page = 0, int size = 20}) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.books,
        queryParameters: {'page': page, 'size': size},
      );
      final content = response['content'];
      if (content == null || content is! List) {
        return [];
      }
      return content.map((item) => BookSummary.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get books: $e');
    }
  }
  @override
  Future<BookDetail> getBookById(String id) async {
    try {
      final response = await _apiClient.get('${ApiEndpoints.books}/$id');
      if (response['success'] != true || response['data'] == null) {
        throw NotFoundException('Book not found: ${response['message']}');
      }
      return BookDetail.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get book: $e');
    }
  }
  @override
  Future<List<BookSummary>> searchBooks(
    String query, {
    int page = 0,
    int size = 20,
  }) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.bookSearch,
        queryParameters: {'query': query, 'page': page, 'size': size},
      );
      if (response['success'] != true || response['content'] == null) {
        return [];
      }
      final List<dynamic> bookList = response['content'];
      return bookList.map((item) => BookSummary.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to search books: $e');
    }
  }
  @override
  Future<List<String>> getAllCategories() async {
    try {
      final response = await _apiClient.get(ApiEndpoints.bookCategories);
      if (response['success'] != true || response['data'] == null) {
        return [];
      }
      final List<dynamic> categoryList = response['data'];
      return categoryList.map((item) => item.toString()).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get categories: $e');
    }
  }
  @override
  Future<List<BookSummary>> filterBooks({
    BookStatus? status,
    DifficultyLevel? difficultyLevel,
    String? category,
    int page = 0,
    int size = 20,
  }) async {
    try {
      final Map<String, dynamic> queryParams = {'page': page, 'size': size};
      if (status != null) {
        queryParams['status'] = status.toString().split('.').last.toUpperCase();
      }
      if (difficultyLevel != null) {
        queryParams['difficultyLevel'] = difficultyLevel
            .toString()
            .split('.')
            .last
            .toUpperCase();
      }
      if (category != null) {
        queryParams['category'] = category;
      }
      final response = await _apiClient.get(
        ApiEndpoints.bookFilter,
        queryParameters: queryParams,
      );
      if (response['success'] != true || response['content'] == null) {
        return [];
      }
      final List<dynamic> bookList = response['content'];
      return bookList.map((item) => BookSummary.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to filter books: $e');
    }
  }
  @override
  Future<void> deleteBook(String id) async {
    try {
      final response = await _apiClient.delete('${ApiEndpoints.books}/$id');
      if (response == null || response['success'] != true) {
        throw BadRequestException(
          'Failed to delete book: ${response?['message']}',
        );
      }
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to delete book: $e');
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/scaffold_with_bottom_bar.dart
class ScaffoldWithBottomBar extends ConsumerStatefulWidget {
  final Widget child;
  final int currentIndex;
  const ScaffoldWithBottomBar({
    super.key,
    required this.child,
    required this.currentIndex,
  });
  @override
  ConsumerState<ScaffoldWithBottomBar> createState() =>
      _ScaffoldWithBottomBarState();
}
class _ScaffoldWithBottomBarState extends ConsumerState<ScaffoldWithBottomBar> {
  DateTime? _lastTabChangeTime;
  @override
  void didUpdateWidget(ScaffoldWithBottomBar oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.currentIndex != oldWidget.currentIndex) {
      final now = DateTime.now();
      if (_lastTabChangeTime == null ||
          now.difference(_lastTabChangeTime!).inSeconds > 2) {
        _lastTabChangeTime = now;
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (!mounted) return;
          switch (widget.currentIndex) {
            case 0:
              ref.read(screenRefreshProvider.notifier).refreshScreen('/');
              break;
            case 1:
              ref.read(screenRefreshProvider.notifier).refreshScreen('/books');
              break;
            case 2:
              ref
                  .read(screenRefreshProvider.notifier)
                  .refreshScreen('/due-progress');
              break;
            case 3:
              ref
                  .read(screenRefreshProvider.notifier)
                  .refreshScreen('/learning');
              break;
            case 4:
              ref
                  .read(screenRefreshProvider.notifier)
                  .refreshScreen('/profile');
              break;
          }
        });
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      drawer: const SLDrawer(),
      body: widget.child,
      bottomNavigationBar: _buildBottomNavigationBar(context),
    );
  }
  Widget _buildBottomNavigationBar(BuildContext context) {
    final theme = Theme.of(context);
    return BottomNavigationBar(
      currentIndex: widget.currentIndex,
      onTap: (index) => _onTabTapped(context, index),
      type: BottomNavigationBarType.fixed,
      selectedItemColor: theme.colorScheme.primary,
      unselectedItemColor: theme.colorScheme.onSurface.withValues(alpha: 0.6),
      items: const [
        BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
        BottomNavigationBarItem(icon: Icon(Icons.book), label: 'Books'),
        BottomNavigationBarItem(icon: Icon(Icons.today), label: 'Due'),
        BottomNavigationBarItem(
          icon: Icon(Icons.analytics_outlined),
          label: 'Stats',
        ),
        BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
      ],
    );
  }
  void _onTabTapped(BuildContext context, int index) {
    if (index == widget.currentIndex) {
      switch (index) {
        case 0:
          ref.read(screenRefreshProvider.notifier).refreshScreen('/');
          break;
        case 1:
          ref.read(screenRefreshProvider.notifier).refreshScreen('/books');
          break;
        case 2:
          ref
              .read(screenRefreshProvider.notifier)
              .refreshScreen('/due-progress');
          break;
        case 3:
          ref.read(screenRefreshProvider.notifier).refreshScreen('/learning');
          break;
        case 4:
          ref.read(screenRefreshProvider.notifier).refreshScreen('/profile');
          break;
      }
    }
    String route = '/';
    switch (index) {
      case 0:
        route = '/';
        break;
      case 1:
        route = '/books';
        break;
      case 2:
        route = '/due-progress';
        break;
      case 3:
        route = '/learning';
        break;
      case 4:
        route = '/profile';
        break;
    }
    NavigationHelper.clearStackAndGo(context, route);
  }
}

// D:/workspace/spaced_learning_app/lib/core/theme/app_typography.dart
class AppTypography {
  static TextTheme getTextTheme(Brightness brightness) {
    final baseTextTheme = GoogleFonts.interTextTheme(); // Use this if available
    final isLight = brightness == Brightness.light;
    final textColor = isLight ? Colors.black87 : Colors.white;
    final subtleTextColor =
        isLight
            ? Colors.black.withValues(alpha: AppDimens.opacityTextSubtle)
            : Colors.white.withValues(alpha: AppDimens.opacityTextSubtle);
    return baseTextTheme.copyWith(
      displayLarge: baseTextTheme.displayLarge?.copyWith(
        fontSize: AppDimens.fontDisplayL, // 57.0
        fontWeight: FontWeight.w400,
        letterSpacing: -0.25,
        color: textColor,
        height: 1.12, // ~64/57
      ),
      displayMedium: baseTextTheme.displayMedium?.copyWith(
        fontSize: AppDimens.fontDisplayM, // 45.0
        fontWeight: FontWeight.w400,
        color: textColor,
        height: 1.15, // ~52/45
      ),
      displaySmall: baseTextTheme.displaySmall?.copyWith(
        fontSize: AppDimens.fontDisplayS, // 36.0
        fontWeight: FontWeight.w400,
        color: textColor,
        height: 1.22, // ~44/36
      ),
      headlineLarge: baseTextTheme.headlineLarge?.copyWith(
        fontSize: AppDimens.fontHeadlineL, // 32.0
        fontWeight: FontWeight.w600, // Make headlines bolder
        color: textColor,
        height: 1.25, // ~40/32
      ),
      headlineMedium: baseTextTheme.headlineMedium?.copyWith(
        fontSize: AppDimens.fontHeadlineM, // 28.0
        fontWeight: FontWeight.w600,
        color: textColor,
        height: 1.28, // ~36/28
      ),
      headlineSmall: baseTextTheme.headlineSmall?.copyWith(
        fontSize: AppDimens.fontHeadlineS, // 24.0
        fontWeight: FontWeight.w600,
        color: textColor,
        height: 1.33, // ~32/24
      ),
      titleLarge: baseTextTheme.titleLarge?.copyWith(
        fontSize: AppDimens.fontTitle, // 22.0
        fontWeight: FontWeight.w600, // Keep titles bold
        color: textColor,
        letterSpacing: 0.0,
        height: 1.27, // ~28/22
      ),
      titleMedium: baseTextTheme.titleMedium?.copyWith(
        fontSize: AppDimens.fontXL, // 16.0
        fontWeight: FontWeight.w600,
        letterSpacing: 0.15,
        color: textColor,
        height: 1.5, // ~24/16
      ),
      titleSmall: baseTextTheme.titleSmall?.copyWith(
        fontSize: AppDimens.fontL, // 14.0
        fontWeight: FontWeight.w600,
        letterSpacing: 0.1,
        color: textColor,
        height: 1.43, // ~20/14
      ),
      bodyLarge: baseTextTheme.bodyLarge?.copyWith(
        fontSize: AppDimens.fontXL, // 16.0
        fontWeight: FontWeight.w400,
        letterSpacing: 0.15, // M3 uses 0.15 for bodyLarge
        color: textColor,
        height: 1.5, // ~24/16
      ),
      bodyMedium: baseTextTheme.bodyMedium?.copyWith(
        fontSize: AppDimens.fontL, // 14.0
        fontWeight: FontWeight.w400,
        letterSpacing: 0.25,
        color: textColor,
        height: 1.43, // ~20/14
      ),
      bodySmall: baseTextTheme.bodySmall?.copyWith(
        fontSize: AppDimens.fontM, // 12.0
        fontWeight: FontWeight.w400,
        letterSpacing: 0.4,
        color: subtleTextColor, // Updated
        height: 1.33, // ~16/12
      ),
      labelLarge: baseTextTheme.labelLarge?.copyWith(
        fontSize: AppDimens.fontL, // 14.0
        fontWeight: FontWeight.w500, // Medium weight for labels
        letterSpacing: 0.1,
        color: textColor,
        height: 1.43, // ~20/14
      ),
      labelMedium: baseTextTheme.labelMedium?.copyWith(
        fontSize: AppDimens.fontM, // 12.0
        fontWeight: FontWeight.w500,
        letterSpacing: 0.5,
        color: textColor,
        height: 1.33, // ~16/12
      ),
      labelSmall: baseTextTheme.labelSmall?.copyWith(
        fontSize: AppDimens.fontS, // 11.0
        fontWeight: FontWeight.w500,
        letterSpacing: 0.5,
        color: textColor,
        height: 1.45, // ~16/11
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/due_progress_summary.dart
class DueProgressSummary extends ConsumerWidget {
  final VoidCallback onRefresh;
  const DueProgressSummary({super.key, required this.onRefresh});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final progressAsync = ref.watch(progressStateProvider);
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return progressAsync.when(
      data: (progressRecords) {
        if (progressRecords.isEmpty && progressAsync.isLoading) {
          return const SizedBox.shrink();
        }
        if (progressAsync.hasError) {
          return const SizedBox.shrink();
        }
        final totalCount = progressRecords.length;
        final dueCount = progressRecords.where(_isDue).length;
        final completedPercent = totalCount == 0
            ? 0
            : ((totalCount - dueCount) / totalCount * 100).toInt();
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(16),
              side: BorderSide(
                color: colorScheme.outlineVariant.withValues(alpha: 0.5),
                width: 1,
              ),
            ),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                children: [
                  _buildStatItem(
                    theme,
                    'Total',
                    totalCount.toString(),
                    Icons.book,
                    colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  _buildStatItem(
                    theme,
                    'Due',
                    dueCount.toString(),
                    Icons.event_available,
                    dueCount > 0
                        ? colorScheme.error
                        : colorScheme.onSurfaceVariant,
                  ),
                  const SizedBox(width: 8),
                  _buildStatItem(
                    theme,
                    'Completed',
                    '$completedPercent%',
                    Icons.task_alt,
                    colorScheme.tertiary,
                  ),
                ],
              ),
            ),
          ),
        );
      },
      loading: () => const Center(child: SLLoadingIndicator()),
      error: (_, __) => const SizedBox.shrink(),
    );
  }
  bool _isDue(ProgressDetail progress) {
    if (progress.nextStudyDate == null) return false;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final nextDate = DateTime(
      progress.nextStudyDate!.year,
      progress.nextStudyDate!.month,
      progress.nextStudyDate!.day,
    );
    return nextDate.compareTo(today) <= 0;
  }
  Widget _buildStatItem(
    ThemeData theme,
    String label,
    String value,
    IconData icon,
    Color color,
  ) => Expanded(
    child: Column(
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 16, color: color),
            const SizedBox(width: 4),
            Text(
              label,
              style: theme.textTheme.labelMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
        const SizedBox(height: 4),
        Text(
          value,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
      ],
    ),
  );
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/status_section.dart
class StatusSection extends StatelessWidget {
  final String title;
  final IconData icon;
  final Color containerColor;
  final Color textColor;
  final Map<String, List<Repetition>> cycleGroups;
  final bool isHistory;
  final CycleStudied currentCycleStudied;
  final Future<void> Function(String)? onMarkCompleted;
  final Future<void> Function(String, DateTime, bool)? onReschedule;
  const StatusSection({
    super.key,
    required this.title,
    required this.icon,
    required this.containerColor,
    required this.textColor,
    required this.cycleGroups,
    required this.isHistory,
    required this.currentCycleStudied,
    this.onMarkCompleted,
    this.onReschedule,
  });
  @override
  Widget build(BuildContext context) {
    if (cycleGroups.isEmpty) return const SizedBox.shrink();
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final sortedKeys = _getSortedCycleKeys();
    final titleIconColor = isHistory
        ? colorScheme.primary.withValues(alpha: AppDimens.opacityVeryHigh)
        : textColor;
    return Padding(
      padding: const EdgeInsets.only(bottom: AppDimens.spaceXL),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionHeader(theme, titleIconColor),
          const SizedBox(height: AppDimens.spaceM),
          ...sortedKeys.map(
            (key) => CycleGroupCard(
              cycleKey: key,
              repetitions: cycleGroups[key]!,
              isHistory: isHistory,
              currentCycleStudied: currentCycleStudied,
              onMarkCompleted: onMarkCompleted,
              onReschedule: onReschedule,
            ),
          ),
        ],
      ),
    );
  }
  List<String> _getSortedCycleKeys() {
    final keys = cycleGroups.keys.toList();
    if (isHistory) {
      keys.sort((a, b) {
        final aNum = int.tryParse(a.replaceAll(RegExp(r'\D'), '')) ?? 0;
        final bNum = int.tryParse(b.replaceAll(RegExp(r'\D'), '')) ?? 0;
        return bNum.compareTo(aNum);
      });
    }
    return keys;
  }
  Widget _buildSectionHeader(ThemeData theme, Color iconColor) {
    final totalTasks = _getTotalRepetitions();
    return Row(
      children: [
        Container(
          padding: const EdgeInsets.all(AppDimens.paddingM),
          decoration: BoxDecoration(
            color: containerColor.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
          ),
          child: Icon(icon, color: iconColor, size: AppDimens.iconM),
        ),
        const SizedBox(width: AppDimens.spaceM),
        Text(
          title,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
            color: isHistory
                ? theme.colorScheme.onSurface.withValues(
                    alpha: AppDimens.opacityVeryHigh,
                  )
                : textColor,
          ),
        ),
        const SizedBox(width: AppDimens.spaceS),
        if (!isHistory)
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppDimens.paddingS,
              vertical: AppDimens.paddingXXS,
            ),
            decoration: BoxDecoration(
              color: textColor.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(AppDimens.radiusS),
            ),
            child: Text(
              '$totalTasks tasks',
              style: theme.textTheme.labelMedium?.copyWith(
                color: textColor,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
      ],
    );
  }
  int _getTotalRepetitions() =>
      cycleGroups.values.fold(0, (sum, reps) => sum + reps.length);
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/home/home_screen.dart
class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});
  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}
class _HomeScreenState extends ConsumerState<HomeScreen>
    with SingleTickerProviderStateMixin {
  final ScreenRefreshManager _refreshManager = ScreenRefreshManager();
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  bool _isInitialLoading = true;
  @override
  void initState() {
    super.initState();
    _refreshManager.registerRefreshCallback('/', _refreshData);
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: AppDimens.durationM),
    );
    _fadeAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeIn,
    );
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInitialData();
    });
  }
  @override
  void dispose() {
    _refreshManager.unregisterRefreshCallback('/', _refreshData);
    _animationController.dispose();
    super.dispose();
  }
  Future<void> _loadInitialData() async {
    setState(() {
      _isInitialLoading = true;
    });
    await ref.read(homeViewModelProvider.notifier).loadInitialData();
    if (mounted) {
      setState(() {
        _isInitialLoading = false;
      });
      _animationController.forward();
    }
  }
  Future<void> _refreshData() async {
    if (!mounted) return;
    setState(() {
      _isInitialLoading = true;
    });
    _animationController.reset();
    await ref.read(homeViewModelProvider.notifier).refreshData();
    if (mounted) {
      setState(() {
        _isInitialLoading = false;
      });
      _animationController.forward();
    }
  }
  @override
  Widget build(BuildContext context) {
    final themeMode = ref.watch(themeModeStateProvider);
    final isDarkMode = themeMode == ThemeMode.dark;
    final homeState = ref.watch(homeViewModelProvider);
    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.surface,
      appBar: HomeAppBar(
        isDarkMode: isDarkMode,
        onThemeToggle: () =>
            ref.read(themeModeStateProvider.notifier).toggleTheme(),
        onMenuPressed: () => Scaffold.of(context).openDrawer(),
      ),
      body: Builder(
        builder: (context) {
          if (_isInitialLoading ||
              ref.read(homeViewModelProvider.notifier).isFirstLoading) {
            return const HomeSkeletonScreen();
          }
          if (ref.read(homeViewModelProvider.notifier).hasError) {
            return HomeError(
              errorMessage: homeState.errorMessage,
              onRetry: _refreshData,
            );
          }
          return HomeContent(
            onRefresh: _refreshData,
            animationController: _animationController,
            fadeAnimation: _fadeAnimation,
          );
        },
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/learning_filter_bar/filter_date_selector.dart
class FilterDateSelector extends ConsumerWidget {
  final DateTime? selectedDate;
  final VoidCallback onDateSelected;
  final VoidCallback onDateCleared;
  const FilterDateSelector({
    super.key,
    required this.selectedDate,
    required this.onDateSelected,
    required this.onDateCleared,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Filter by Date',
          style: theme.textTheme.labelMedium?.copyWith(
            color: colorScheme.onSurface.withValues(
              alpha: AppDimens.opacityHigh,
            ),
          ),
        ),
        const SizedBox(height: AppDimens.spaceXS),
        SizedBox(
          height: 48,
          child: selectedDate == null
              ? OutlinedButton.icon(
                  icon: Icon(
                    Icons.calendar_today,
                    size: AppDimens.iconS,
                    color: colorScheme.primary,
                  ),
                  label: Text(
                    'Select Date',
                    style: TextStyle(color: colorScheme.primary),
                  ),
                  onPressed: onDateSelected,
                  style: OutlinedButton.styleFrom(
                    minimumSize: const Size.fromHeight(48),
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppDimens.paddingL,
                      vertical: AppDimens.paddingM,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(AppDimens.radiusM),
                    ),
                    side: BorderSide(
                      color: colorScheme.outline.withValues(
                        alpha: AppDimens.opacitySemi,
                      ),
                    ),
                  ),
                )
              : Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: AppDimens.paddingL,
                    vertical: AppDimens.paddingM - 1,
                  ),
                  decoration: BoxDecoration(
                    border: Border.all(color: colorScheme.primary, width: 2),
                    borderRadius: BorderRadius.circular(AppDimens.radiusM),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.calendar_today,
                        size: AppDimens.iconS,
                        color: colorScheme.primary,
                      ),
                      const SizedBox(width: AppDimens.spaceS),
                      Expanded(
                        child: Text(
                          DateFormat('MMM dd, yyyy').format(selectedDate!),
                          style: TextStyle(
                            color: colorScheme.primary,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                      InkWell(
                        onTap: onDateCleared,
                        borderRadius: BorderRadius.circular(AppDimens.radiusS),
                        child: Padding(
                          padding: const EdgeInsets.all(AppDimens.paddingXS),
                          child: Icon(
                            Icons.close,
                            size: AppDimens.iconS,
                            color: colorScheme.primary,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/network/api_client.dart
class ApiClient {
  late final Dio _dio;
  ApiClient() {
    _dio = Dio();
    _dio.options.baseUrl = AppConstants.baseUrl;
    _dio.options.connectTimeout = const Duration(
      milliseconds: AppConstants.connectTimeout,
    );
    _dio.options.receiveTimeout = const Duration(
      milliseconds: AppConstants.receiveTimeout,
    );
    _dio.options.contentType = Headers.jsonContentType;
    _dio.options.responseType = ResponseType.json;
    _dio.interceptors.add(LoggingInterceptor());
    _dio.interceptors.add(AuthInterceptor());
  }
  Future<dynamic> get(
    String url, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.get(url, queryParameters: queryParameters);
      return _processResponse(response);
    } catch (e) {
      return _handleError(e, url);
    }
  }
  Future<dynamic> post(String url, {dynamic data}) async {
    try {
      final response = await _dio.post(url, data: data);
      return _processResponse(response);
    } catch (e) {
      return _handleError(e, url);
    }
  }
  Future<dynamic> put(String url, {dynamic data}) async {
    try {
      final response = await _dio.put(url, data: data);
      return _processResponse(response);
    } catch (e) {
      return _handleError(e, url);
    }
  }
  Future<dynamic> delete(String url) async {
    try {
      final response = await _dio.delete(url);
      return _processResponse(response);
    } catch (e) {
      return _handleError(e, url);
    }
  }
  dynamic _processResponse(Response response) {
    final statusCode = response.statusCode;
    if (statusCode == 200 || statusCode == 201) {
      return response.data;
    }
    if (statusCode == 204) {
      return null;
    }
    if (statusCode == 400) {
      throw BadRequestException(
        response.data?['message'] ?? 'Bad request',
        response.requestOptions.path,
        response.data?['errors'],
      );
    }
    if (statusCode == 401) {
      throw AuthenticationException(
        response.data?['message'] ?? 'Authentication failed',
        response.requestOptions.path,
      );
    }
    if (statusCode == 403) {
      throw ForbiddenException(
        response.data?['message'] ?? 'Access denied',
        response.requestOptions.path,
      );
    }
    if (statusCode == 404) {
      throw NotFoundException(
        response.data?['message'] ?? 'Resource not found',
        response.requestOptions.path,
      );
    }
    if (statusCode == 500 ||
        statusCode == 502 ||
        statusCode == 503 ||
        statusCode == 504) {
      throw ServerException(
        response.data?['message'] ?? 'Server error',
        response.requestOptions.path,
      );
    }
    throw HttpException(
      statusCode ?? 0,
      response.data?['message'] ?? 'Unknown error occurred',
      response.requestOptions.path,
    );
  }
  dynamic _handleError(dynamic e, String? url) {
    if (e is DioException) {
      if (e.error is SocketException) {
        throw NoInternetException();
      }
      if (e.type == DioExceptionType.connectionTimeout ||
          e.type == DioExceptionType.receiveTimeout) {
        throw TimeoutException('Request timeout', url);
      }
      if (e.response != null) {
        return _processResponse(e.response!);
      }
    }
    if (e is AppException) {
      throw e;
    }
    throw UnexpectedException('Unexpected error occurred', url);
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/progress_repetition_list.dart
class ProgressRepetitionList extends ConsumerStatefulWidget {
  final String progressId;
  final CycleStudied currentCycleStudied;
  final Future<void> Function(String) onMarkCompleted;
  final Future<void> Function(String, DateTime, bool) onReschedule;
  final Future<void> Function() onReload;
  const ProgressRepetitionList({
    super.key,
    required this.progressId,
    required this.currentCycleStudied,
    required this.onMarkCompleted,
    required this.onReschedule,
    required this.onReload,
  });
  @override
  ConsumerState<ProgressRepetitionList> createState() =>
      _ProgressRepetitionListState();
}
class _ProgressRepetitionListState extends ConsumerState<ProgressRepetitionList>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: AppDimens.durationM),
    );
    _fadeAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
    _animationController.forward();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref
          .read(repetitionStateProvider.notifier)
          .loadRepetitionsByProgressId(widget.progressId);
    });
  }
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  void _restartAnimation() {
    _animationController.reset();
    _animationController.forward();
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final _ = theme.colorScheme;
    final repetitionsState = ref.watch(repetitionStateProvider);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Review Schedule', style: theme.textTheme.titleLarge),
        const SizedBox(height: AppDimens.spaceL),
        repetitionsState.when(
          data: (repetitions) {
            if (repetitions.isNotEmpty) {
              _restartAnimation();
            }
            return FadeTransition(
              opacity: _fadeAnimation,
              child: CompactRepetitionList(
                progressId: widget.progressId,
                currentCycleStudied: widget.currentCycleStudied,
                onMarkCompleted: widget.onMarkCompleted,
                onReschedule: widget.onReschedule,
                onReload: widget.onReload,
              ),
            );
          },
          loading: () => const Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                SLLoadingIndicator(),
                SizedBox(height: AppDimens.spaceS),
                Text('Loading repetitions...'),
              ],
            ),
          ),
          error: (error, stackTrace) => SLErrorView(
            message: error.toString(),
            onRetry: () => ref
                .read(repetitionStateProvider.notifier)
                .loadRepetitionsByProgressId(widget.progressId),
            compact: true,
          ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/profile/profile_info_card.dart
class ProfileInfoCard extends StatelessWidget {
  final User user;
  final VoidCallback onEditPressed;
  const ProfileInfoCard({
    super.key,
    required this.user,
    required this.onEditPressed,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Card(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      elevation: 0,
      color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingS),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Personal Info',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  icon: Container(
                    padding: const EdgeInsets.all(AppDimens.paddingXS),
                    decoration: BoxDecoration(
                      color: colorScheme.primary.withValues(alpha: 0.1),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      Icons.edit,
                      color: colorScheme.primary,
                      size: 20,
                    ),
                  ),
                  onPressed: onEditPressed,
                  tooltip: 'Edit',
                ),
              ],
            ),
            const SizedBox(height: AppDimens.spaceM),
            _buildInfoItem(
              theme,
              Icons.person,
              'Display Name',
              user.displayName ?? 'Not set',
            ),
            _buildInfoItem(theme, Icons.email, 'Email', user.email),
            if (user.roles?.isNotEmpty ?? false)
              _buildInfoItem(
                theme,
                Icons.badge,
                'Roles',
                user.roles!.join(', '),
              ),
          ],
        ),
      ),
    );
  }
  Widget _buildInfoItem(
    ThemeData theme,
    IconData icon,
    String label,
    String value,
  ) {
    final colorScheme = theme.colorScheme;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: AppDimens.paddingM),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.all(AppDimens.paddingM),
            decoration: BoxDecoration(
              color: colorScheme.primary.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Icon(icon, color: colorScheme.primary, size: 24),
          ),
          const SizedBox(width: AppDimens.spaceL),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: colorScheme.onSurface.withValues(alpha: 0.6),
                  ),
                ),
                const SizedBox(height: AppDimens.spaceXS),
                Text(
                  value,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/learning_progress_viewmodel.dart
@riverpod
class LearningProgressState extends _$LearningProgressState {
  @override
  Future<List<LearningModule>> build() async {
    return _fetchModules();
  }
  Future<List<LearningModule>> _fetchModules() async {
    try {
      debugPrint('LearningProgressViewModel: Loading module data');
      final modules = await ref.read(learningDataServiceProvider).getModules();
      debugPrint('LearningProgressViewModel: Loaded ${modules.length} modules');
      return modules;
    } catch (e, st) {
      debugPrint('Failed to load learning modules: $e');
      throw AsyncError(e, st);
    }
  }
  Future<void> loadData() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() => _fetchModules());
  }
  Future<void> refreshData() async {
    debugPrint('LearningProgressViewModel: Refreshing data, resetting cache');
    ref.read(learningDataServiceProvider).resetCache();
    await loadData();
  }
  Future<bool> exportData() async {
    try {
      return await ref.read(learningDataServiceProvider).exportData();
    } catch (_) {
      return false;
    }
  }
  Future<Map<String, dynamic>> getDashboardStats({
    String? book,
    DateTime? date,
  }) async {
    try {
      return await ref
          .read(learningDataServiceProvider)
          .getDashboardStats(book: book, date: date);
    } catch (_) {
      return {};
    }
  }
  List<String> getUniqueBooks() {
    final modules = state.valueOrNull ?? [];
    if (modules.isEmpty) return ['All'];
    final books = modules.map((m) => m.bookName).toSet().toList()..sort();
    return ['All', ...books];
  }
}
@riverpod
class FilteredModules extends _$FilteredModules {
  @override
  List<LearningModule> build() {
    final modules = ref.watch(learningProgressStateProvider).valueOrNull ?? [];
    final selectedBook = ref.watch(selectedBookFilterProvider);
    final selectedDate = ref.watch(selectedDateFilterProvider);
    return _getFilteredModules(modules, selectedBook, selectedDate);
  }
  List<LearningModule> _getFilteredModules(
    List<LearningModule> modules,
    String selectedBook,
    DateTime? selectedDate,
  ) {
    return modules.where((module) {
      final bookMatch =
          selectedBook == 'All' || module.bookName == selectedBook;
      final dateMatch =
          selectedDate == null ||
          (module.progressNextStudyDate != null &&
              AppDateUtils.isSameDay(
                module.progressNextStudyDate!,
                selectedDate,
              ));
      return bookMatch && dateMatch;
    }).toList();
  }
}
@riverpod
class SelectedBookFilter extends _$SelectedBookFilter {
  @override
  String build() => 'All';
  void setSelectedBook(String book) {
    state = book;
  }
}
@riverpod
class SelectedDateFilter extends _$SelectedDateFilter {
  @override
  DateTime? build() => null;
  void setSelectedDate(DateTime? date) {
    state = date;
  }
  void clearDateFilter() {
    state = null;
  }
}
@riverpod
int dueModulesCount(Ref ref) {
  final filteredModules = ref.watch(filteredModulesProvider);
  return filteredModules
      .where(
        (m) =>
            m.progressNextStudyDate != null &&
            m.progressNextStudyDate!.isBefore(DateTime.now()),
      )
      .length;
}
@riverpod
int completedModulesCount(Ref ref) {
  final filteredModules = ref.watch(filteredModulesProvider);
  return filteredModules
      .where((m) => (m.progressLatestPercentComplete ?? 0) == 100)
      .length;
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/book_viewmodel.dart
@riverpod
class BooksState extends _$BooksState {
  @override
  Future<List<BookSummary>> build() => _loadBooks();
  Future<List<BookSummary>> _loadBooks({int page = 0, int size = 20}) async {
    try {
      final books = await ref
          .read(bookRepositoryProvider)
          .getAllBooks(page: page, size: size);
      return books;
    } catch (e, st) {
      throw AsyncError(e, st);
    }
  }
  Future<void> loadBooks({int page = 0, int size = 20}) async {
    state = const AsyncValue.loading();
    try {
      final books = await ref
          .read(bookRepositoryProvider)
          .getAllBooks(page: page, size: size);
      state = AsyncValue.data(books);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
  Future<void> searchBooks(String query, {int page = 0, int size = 20}) async {
    state = const AsyncValue.loading();
    try {
      final books = query.isEmpty
          ? await ref
                .read(bookRepositoryProvider)
                .getAllBooks(page: page, size: size)
          : await ref
                .read(bookRepositoryProvider)
                .searchBooks(query, page: page, size: size);
      state = AsyncValue.data(books);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
  Future<void> filterBooks({
    BookStatus? status,
    DifficultyLevel? difficultyLevel,
    String? category,
    int page = 0,
    int size = 20,
  }) async {
    state = const AsyncValue.loading();
    try {
      final books = await ref
          .read(bookRepositoryProvider)
          .filterBooks(
            status: status,
            difficultyLevel: difficultyLevel,
            category: category,
            page: page,
            size: size,
          );
      state = AsyncValue.data(books);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
  Future<bool> deleteBook(String id) async {
    try {
      await ref.read(bookRepositoryProvider).deleteBook(id);
      final books = state.valueOrNull ?? [];
      state = AsyncValue.data(books.where((book) => book.id != id).toList());
      final selectedBook = ref.read(selectedBookProvider).valueOrNull;
      if (selectedBook?.id == id) {
        ref.read(selectedBookProvider.notifier).clearSelectedBook();
      }
      return true;
    } catch (_) {
      return false;
    }
  }
}
@riverpod
class SelectedBook extends _$SelectedBook {
  @override
  Future<BookDetail?> build() async => null;
  Future<void> loadBookDetails(String id) async {
    if (id.isEmpty) {
      state = const AsyncValue.data(null);
      return;
    }
    state = const AsyncValue.loading();
    try {
      final book = await ref.read(bookRepositoryProvider).getBookById(id);
      state = AsyncValue.data(book);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
  void clearSelectedBook() {
    state = const AsyncValue.data(null);
  }
}
@Riverpod(keepAlive: true)
class Categories extends _$Categories {
  @override
  Future<List<String>> build() => _loadCategories();
  Future<List<String>> _loadCategories() async {
    try {
      final categories = await ref
          .read(bookRepositoryProvider)
          .getAllCategories();
      return categories;
    } catch (e, st) {
      throw AsyncError(e, st);
    }
  }
  Future<void> reloadCategories() async {
    state = const AsyncValue.loading();
    try {
      final categories = await ref
          .read(bookRepositoryProvider)
          .getAllCategories();
      state = AsyncValue.data(categories);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/reminder/cloud_reminder_service.dart
class CloudReminderService {
  late final FirebaseMessaging _firebaseMessaging;
  final StorageService _storageService;
  final NotificationService _notificationService;
  CloudReminderService({
    required StorageService storageService,
    required NotificationService notificationService,
  }) : _storageService = storageService,
       _notificationService = notificationService {
    _firebaseMessaging = FirebaseMessaging.instance;
  }
  Future<void> initialize() async {
    try {
      final settings = await _requestNotificationPermissions();
      debugPrint('FCM permission settings: ${settings.authorizationStatus}');
      await _setupTokenHandling();
      _setupMessageHandlers();
      debugPrint('FCM initialized successfully');
    } catch (e) {
      debugPrint('Error initializing FCM: $e');
    }
  }
  Future<NotificationSettings> _requestNotificationPermissions() async {
    return _firebaseMessaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
      provisional: false,
    );
  }
  Future<void> _setupTokenHandling() async {
    final token = await _firebaseMessaging.getToken();
    if (token != null) {
      await _saveDeviceToken(token);
    } else {
      debugPrint('Error: FCM token is null');
    }
    _firebaseMessaging.onTokenRefresh.listen(_saveDeviceToken);
  }
  void _setupMessageHandlers() {
    FirebaseMessaging.onMessage.listen(_handleMessage);
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
  }
  Future<void> _saveDeviceToken(String token) async {
    try {
      await _storageService.setString('fcm_token', token);
      debugPrint('FCM token saved locally: ${token.substring(0, 10)}...');
      final userData = await _storageService.getUserData();
      if (userData != null && userData['id'] != null) {
        debugPrint('FCM token saved for user: ${userData['id']}');
      }
    } catch (e) {
      debugPrint('Error in _saveDeviceToken: $e');
    }
  }
  void _handleMessage(RemoteMessage message) {
    debugPrint('Got FCM message: ${message.notification?.title}');
    try {
      _notificationService.showNotification(
        id: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        title: message.notification?.title ?? 'Learning Reminder',
        body: message.notification?.body ?? 'Time to check your learning tasks',
        isImportant: message.data['priority'] == 'high',
      );
    } catch (e) {
      debugPrint('Error showing notification from FCM: $e');
    }
  }
}
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  debugPrint('Handling a background message: ${message.messageId}');
}
@riverpod
class CloudNotification extends _$CloudNotification {
  @override
  Future<String?> build() async {
    final storageService = ref.watch(storageServiceProvider);
    return storageService.getString('fcm_token');
  }
  Future<void> initialize() async {
    state = const AsyncValue.loading();
    final cloudReminderService = ref.read(cloudReminderServiceProvider);
    await cloudReminderService.initialize();
    final storageService = ref.read(storageServiceProvider);
    final token = await storageService.getString('fcm_token');
    state = AsyncValue.data(token);
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/main/module_list.dart
class ModuleList extends ConsumerWidget {
  final List<dynamic> modules;
  final ScrollController? scrollController;
  final VoidCallback onRefresh;
  const ModuleList({
    super.key,
    required this.modules,
    this.scrollController,
    required this.onRefresh,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (modules.isEmpty) {
      return _buildEmptyState(context);
    }
    return RefreshIndicator(
      onRefresh: () async => onRefresh(),
      child: ListView.builder(
        padding: const EdgeInsets.only(bottom: AppDimens.paddingXXXL),
        physics: const AlwaysScrollableScrollPhysics(),
        controller: scrollController,
        itemCount: modules.length + 1,
        itemBuilder: (context, index) {
          if (index == 0) {
            return const ModuleListHeader();
          }
          final moduleIndex = index - 1;
          final module = modules[moduleIndex];
          return ModuleCard(module: module, index: moduleIndex);
        },
      ),
    );
  }
  Widget _buildEmptyState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingXXL),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              width: AppDimens.avatarSizeXXL,
              height: AppDimens.avatarSizeXXL,
              decoration: BoxDecoration(
                color: theme.colorScheme.surfaceContainerHighest,
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.search_off_rounded,
                size: AppDimens.iconXXL,
                color: theme.colorScheme.primary.withValues(
                  alpha: AppDimens.opacitySemi,
                ),
              ),
            ),
            const SizedBox(height: AppDimens.spaceXL),
            Text(
              'No modules found',
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: AppDimens.spaceS),
            Text(
              'Try adjusting your filters or check back later',
              style: theme.textTheme.bodyLarge?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: AppDimens.spaceXXL),
            FilledButton.icon(
              onPressed: () {
                if (scrollController != null) {
                  scrollController!.animateTo(
                    0,
                    duration: const Duration(milliseconds: AppDimens.durationM),
                    curve: Curves.easeOut,
                  );
                }
              },
              icon: const Icon(Icons.filter_alt),
              label: const Text('Change filters'),
              style: FilledButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimens.paddingXL,
                  vertical: AppDimens.paddingM,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/constants/api_endpoints.dart
class ApiEndpoints {
  static String basePath = AppConstants.baseUrl + AppConstants.apiPrefix;
  static final String login = '$basePath/auth/login';
  static final String register = '$basePath/auth/register';
  static final String refreshToken = '$basePath/auth/refresh-token';
  static final String validateToken = '$basePath/auth/validate';
  static final String currentUser = '$basePath/users/me';
  static final String users = '$basePath/users';
  static final String books = '$basePath/books';
  static final String bookCategories = '$basePath/books/categories';
  static final String bookSearch = '$basePath/books/search';
  static final String bookFilter = '$basePath/books/filter';
  static final String modules = '$basePath/modules';
  static String modulesByBook(String bookId) =>
      '$basePath/modules/book/$bookId';
  static final String progress = '$basePath/progress';
  static String dueProgress(String userId) => '$basePath/progress/due';
  static final String repetitions = '$basePath/repetitions';
  static String repetitionsByProgress(String progressId) =>
      '$basePath/repetitions/progress/$progressId';
  static String repetitionSchedule(String progressId) =>
      '$basePath/repetitions/progress/$progressId/schedule';
  static final String dashboardStats = '$basePath/stats/dashboard';
  static final String learningInsights = '$basePath/stats/insights';
  static final String learningModules = '$basePath/learning/modules';
  static final String dueModules = '$basePath/learning/modules/due';
  static final String uniqueBooks = '$basePath/learning/books';
  static final String exportData = '$basePath/learning/export';
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/dashboard/dashboard_section.dart
class DashboardSection extends ConsumerWidget {
  const DashboardSection({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final statsAsync = ref.watch(learningStatsStateProvider);
    return statsAsync.when(
      data: (stats) {
        if (stats == null) {
          return _buildEmptyStatsCard(context, ref);
        }
        return StatsCard(
          moduleStats: ModuleStats(
            totalModules: stats.totalModules,
            cycleStats: stats.cycleStats,
          ),
          dueStats: DueStats(
            dueToday: stats.dueToday,
            dueThisWeek: stats.dueThisWeek,
            dueThisMonth: stats.dueThisMonth,
            wordsDueToday: stats.wordsDueToday,
            wordsDueThisWeek: stats.wordsDueThisWeek,
            wordsDueThisMonth: stats.wordsDueThisMonth,
          ),
          completionStats: CompletionStats(
            completedToday: stats.completedToday,
            completedThisWeek: stats.completedThisWeek,
            completedThisMonth: stats.completedThisMonth,
            wordsCompletedToday: stats.wordsCompletedToday,
            wordsCompletedThisWeek: stats.wordsCompletedThisWeek,
            wordsCompletedThisMonth: stats.wordsCompletedThisMonth,
          ),
          streakStats: StreakStats(
            streakDays: stats.streakDays,
            streakWeeks: stats.streakWeeks,
          ),
          vocabularyStats: VocabularyStats(
            totalWords: stats.totalWords,
            learnedWords: stats.learnedWords,
            pendingWords: stats.pendingWords,
            vocabularyCompletionRate: stats.vocabularyCompletionRate,
            weeklyNewWordsRate: stats.weeklyNewWordsRate,
          ),
          onViewProgress: () => _navigateToProgress(context),
        );
      },
      loading: () => const SizedBox.shrink(),
      error: (_, __) => _buildEmptyStatsCard(context, ref),
    );
  }
  Widget _buildEmptyStatsCard(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Center(
      child: Column(
        children: [
          Text(
            'No statistics available',
            style: theme.textTheme.titleMedium?.copyWith(
              color: colorScheme.onSurface,
            ),
          ),
          const SizedBox(height: 16),
          SLButton(
            text: 'Load Statistics',
            type: SLButtonType.primary,
            onPressed: () => _refreshStats(context, ref),
          ),
        ],
      ),
    );
  }
  void _refreshStats(BuildContext context, WidgetRef ref) {
    ref.read(loadAllStatsProvider(refreshCache: true).future);
  }
  void _navigateToProgress(BuildContext context) {
    GoRouter.of(context).go('/learning');
  }
}

// D:/workspace/spaced_learning_app/lib/data/repositories/learning_progress_repository_impl.dart
class LearningProgressRepositoryImpl implements LearningProgressRepository {
  final ApiClient _apiClient;
  LearningProgressRepositoryImpl(this._apiClient);
  @override
  Future<List<LearningModule>> getAllModules() async {
    try {
      final response = await _apiClient.get(ApiEndpoints.learningModules);
      if (response['success'] != true || response['data'] == null) {
        return [];
      }
      final List<dynamic> modulesList = response['data'];
      return modulesList.map((item) => LearningModule.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get modules: $e');
    }
  }
  @override
  Future<List<LearningModule>> getDueModules(int daysThreshold) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.dueModules,
        queryParameters: {'daysThreshold': daysThreshold},
      );
      if (response['success'] != true || response['data'] == null) {
        return [];
      }
      final List<dynamic> modulesList = response['data'];
      return modulesList.map((item) => LearningModule.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get due modules: $e');
    }
  }
  @override
  Future<List<String>> getUniqueBooks() async {
    try {
      final response = await _apiClient.get(ApiEndpoints.uniqueBooks);
      if (response['success'] != true || response['data'] == null) {
        return [];
      }
      final List<dynamic> booksList = response['data'];
      return booksList.map((item) => item.toString()).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get unique books: $e');
    }
  }
  @override
  Future<Map<String, dynamic>> exportData() async {
    try {
      final response = await _apiClient.post(ApiEndpoints.exportData);
      if (response['success'] != true || response['data'] == null) {
        throw BadRequestException(
          'Failed to export data: ${response['message']}',
        );
      }
      return response['data'] as Map<String, dynamic>;
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to export data: $e');
    }
  }
  @override
  Future<Map<String, dynamic>> getDashboardStats({
    String? book,
    DateTime? date,
  }) async {
    try {
      final Map<String, dynamic> queryParams = {};
      if (book != null) {
        queryParams['book'] = book;
      }
      if (date != null) {
        queryParams['date'] = DateFormat('yyyy-MM-dd').format(date);
      }
      final response = await _apiClient.get(
        ApiEndpoints.dashboardStats,
        queryParameters: queryParams,
      );
      if (response['success'] != true || response['data'] == null) {
        throw BadRequestException(
          'Failed to get dashboard stats: ${response['message']}',
        );
      }
      return response['data'] as Map<String, dynamic>;
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get dashboard stats: $e');
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/learning_stats/stat_grid_item.dart
class StatGridItem extends StatelessWidget {
  final ThemeData theme;
  final String value;
  final String label;
  final IconData iconData;
  final Color color;
  final String? additionalInfo;
  final bool showStar;
  final Color? starColor;
  final Color? onStarColor;
  const StatGridItem({
    super.key,
    required this.theme,
    required this.value,
    required this.label,
    required this.iconData,
    required this.color,
    this.additionalInfo,
    this.showStar = false,
    this.starColor,
    this.onStarColor,
  });
  @override
  Widget build(BuildContext context) {
    final effectiveStarColor =
        starColor ??
        (theme.brightness == Brightness.light
            ? Colors.amber
            : Colors.amberAccent);
    final effectiveOnStarColor =
        onStarColor ??
        (theme.brightness == Brightness.light
            ? Colors.white
            : theme.colorScheme.surface);
    return LayoutBuilder(
      builder: (context, constraints) {
        return SingleChildScrollView(
          physics: const NeverScrollableScrollPhysics(),
          child: ConstrainedBox(
            constraints: BoxConstraints(minHeight: constraints.maxHeight),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Stack(
                  clipBehavior: Clip.none,
                  children: [
                    Icon(iconData, color: color, size: AppDimens.iconL),
                    if (showStar)
                      Positioned(
                        top: -AppDimens.paddingXS - 1,
                        right: -AppDimens.paddingXS - 1,
                        child: Container(
                          padding: const EdgeInsets.all(AppDimens.paddingXXS),
                          decoration: BoxDecoration(
                            color: effectiveStarColor,
                            shape: BoxShape.circle,
                          ),
                          child: Icon(
                            Icons.star,
                            color: effectiveOnStarColor,
                            size: AppDimens.iconXXS,
                          ),
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: AppDimens.spaceXS),
                Text(
                  value,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: color,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                if (additionalInfo != null)
                  Text(
                    additionalInfo!,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: color.withValues(alpha: AppDimens.opacityHigh),
                      fontSize: AppDimens.fontXS,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                Text(
                  label,
                  style: theme.textTheme.bodySmall,
                  textAlign: TextAlign.center,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/modules/module_header.dart
class ModuleHeader extends StatelessWidget {
  final ModuleDetail module;
  const ModuleHeader({super.key, required this.module});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(module.title, style: theme.textTheme.headlineSmall),
        const SizedBox(height: AppDimens.spaceM),
        Row(
          children: [
            _buildModuleTag(context),
            const SizedBox(width: AppDimens.spaceL),
            Expanded(
              child: Text(
                'Book: ${module.bookName ?? "Unknown"}',
                style: theme.textTheme.bodyMedium,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
        const SizedBox(height: AppDimens.spaceL),
        _buildStatsCard(context),
      ],
    );
  }
  Widget _buildModuleTag(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingL,
        vertical: AppDimens.paddingS,
      ),
      decoration: BoxDecoration(
        color: theme.colorScheme.primary,
        borderRadius: BorderRadius.circular(AppDimens.radiusXL),
      ),
      child: Text(
        'Module ${module.moduleNo}',
        style: theme.textTheme.bodyMedium?.copyWith(
          color: theme.colorScheme.onPrimary,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  Widget _buildStatsCard(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStatItem(
              context,
              module.progress.length.toString(),
              'Students',
            ),
            _buildDivider(context),
            _buildStatItem(
              context,
              module.wordCount?.toString() ?? 'N/A',
              'Words',
            ),
            _buildDivider(context),
            _buildStatItem(
              context,
              _estimateReadingTime(module.wordCount),
              'Reading Time',
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildStatItem(BuildContext context, String value, String label) {
    final theme = Theme.of(context);
    return Column(
      children: [
        Text(
          value,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
            color: theme.colorScheme.primary,
          ),
        ),
        Text(label, style: theme.textTheme.bodySmall),
      ],
    );
  }
  Widget _buildDivider(BuildContext context) {
    final theme = Theme.of(context);
    final dividerColor = theme.colorScheme.outline.withValues(alpha: 0.5);
    return Container(height: 40, width: 1, color: dividerColor);
  }
  String _estimateReadingTime(int? wordCount) {
    if (wordCount == null || wordCount <= 0) return 'N/A';
    final readingTimeMinutes = (wordCount / 200).ceil();
    if (readingTimeMinutes < 1) return '<1 min';
    return readingTimeMinutes == 1 ? '1 min' : '$readingTimeMinutes mins';
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/insights/learning_insights_widget.dart
class LearningInsightsWidget extends StatelessWidget {
  final double vocabularyRate;
  final int streakDays;
  final int pendingWords;
  final int dueToday;
  final ThemeData? theme; // Optional theme override
  const LearningInsightsWidget({
    super.key,
    required this.vocabularyRate,
    required this.streakDays,
    required this.pendingWords,
    required this.dueToday,
    this.theme,
  });
  @override
  Widget build(BuildContext context) {
    final currentTheme = theme ?? Theme.of(context);
    final colorScheme = currentTheme.colorScheme;
    final textTheme = currentTheme.textTheme;
    return Card(
      margin: EdgeInsets.zero,
      elevation: AppDimens.elevationS,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimens.radiusL),
      ),
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildHeader(colorScheme, textTheme),
            const SizedBox(height: AppDimens.spaceM),
            const Divider(height: AppDimens.dividerThickness),
            const SizedBox(height: AppDimens.spaceS),
            _buildInsightsList(context, colorScheme, textTheme),
          ],
        ),
      ),
    );
  }
  Widget _buildHeader(ColorScheme colorScheme, TextTheme textTheme) {
    return Row(
      children: [
        Icon(
          Icons.insights_outlined,
          color: colorScheme.getStatColor('tertiary'),
          size: AppDimens.iconM,
        ),
        const SizedBox(width: AppDimens.spaceS),
        Text(
          'Learning Insights',
          style: textTheme.titleLarge?.copyWith(
            color: colorScheme.onSurface,
            fontWeight: FontWeight.w600,
          ),
        ),
      ],
    );
  }
  Widget _buildInsightsList(
    BuildContext context,
    ColorScheme colorScheme,
    TextTheme textTheme,
  ) {
    final theme = Theme.of(context);
    return Column(
      children: [
        InsightItem(
          message:
              'You learn ${vocabularyRate.toStringAsFixed(1)}% new vocabulary each week',
          icon: Icons.trending_up,
          colorType: 'secondary',
          theme: theme,
          colorScheme: colorScheme,
        ),
        InsightItem(
          message: 'Your current streak is $streakDays days - keep going!',
          icon: Icons.local_fire_department_outlined,
          colorType: 'tertiary',
          theme: theme,
          colorScheme: colorScheme,
        ),
        InsightItem(
          message: 'You have $pendingWords words pending to learn',
          icon: Icons.hourglass_empty_outlined,
          colorType: 'primary',
          theme: theme,
          colorScheme: colorScheme,
        ),
        InsightItem(
          message:
              'Complete today\'s $dueToday sessions to maintain your streak',
          icon: Icons.today_outlined,
          colorType: 'warning',
          theme: theme,
          colorScheme: colorScheme,
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/learning_stats/learning_stats_card.dart
class LearningStatsCard extends StatelessWidget {
  final LearningStatsDTO stats;
  final VoidCallback? onViewDetailPressed;
  final ThemeData? theme; // Optional theme override
  const LearningStatsCard({
    super.key,
    required this.stats,
    this.onViewDetailPressed,
    this.theme,
  });
  @override
  Widget build(BuildContext context) {
    final currentTheme = theme ?? Theme.of(context);
    final size = MediaQuery.of(context).size;
    final isSmallScreen = size.width < AppDimens.breakpointXS;
    final _ = currentTheme.colorScheme;
    return Card(
      elevation: currentTheme.cardTheme.elevation ?? AppDimens.elevationS,
      shape:
          currentTheme.cardTheme.shape ??
          RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppDimens.radiusL),
          ),
      child: Padding(
        padding: EdgeInsets.all(
          isSmallScreen ? AppDimens.paddingM : AppDimens.paddingL,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildCardHeader(currentTheme),
            SizedBox(
              height: isSmallScreen ? AppDimens.spaceM : AppDimens.spaceL,
            ),
            ModuleStatsGrid(
              stats: stats,
              theme: currentTheme,
              isSmallScreen: isSmallScreen,
            ),
            const Divider(height: AppDimens.spaceXXL),
            DueStatsGrid(
              stats: stats,
              theme: currentTheme,
              isSmallScreen: isSmallScreen,
            ),
            const Divider(height: AppDimens.spaceXXL),
            VocabularyStatsGrid(
              stats: stats,
              theme: currentTheme,
              isSmallScreen: isSmallScreen,
            ),
            const Divider(height: AppDimens.spaceXXL),
            StreakStatsGrid(
              stats: stats,
              theme: currentTheme,
              isSmallScreen: isSmallScreen,
            ),
            if (onViewDetailPressed != null) ...[
              const SizedBox(height: AppDimens.spaceL),
              Align(
                alignment: Alignment.centerRight,
                child: TextButton.icon(
                  icon: const Icon(Icons.analytics_outlined),
                  label: const Text('View Details'),
                  onPressed: onViewDetailPressed,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
  Widget _buildCardHeader(ThemeData theme) {
    return Row(
      children: [
        Icon(Icons.book_online, color: theme.iconTheme.color),
        const SizedBox(width: AppDimens.spaceS),
        Text('Learning Statistics', style: theme.textTheme.titleLarge),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/report/log_card_widget.dart
class LogCardWidget extends StatelessWidget {
  final List<LogEntry> logEntries;
  final VoidCallback onClearLogs;
  const LogCardWidget({
    super.key,
    required this.logEntries,
    required this.onClearLogs,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final dateFormat = DateFormat('dd/MM/yyyy HH:mm:ss');
    return Card(
      elevation: AppDimens.elevationM,
      color: colorScheme.surfaceContainerLowest,
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Check Logs',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                TextButton.icon(
                  onPressed: onClearLogs,
                  icon: const Icon(Icons.delete_outline, size: 18),
                  label: const Text('Clear Logs'),
                  style: TextButton.styleFrom(
                    foregroundColor: colorScheme.error,
                  ),
                ),
              ],
            ),
            const SizedBox(height: AppDimens.spaceM),
            const Divider(height: 1),
            const SizedBox(height: AppDimens.spaceM),
            _buildLogList(
              logs: logEntries,
              theme: theme,
              colorScheme: colorScheme,
              dateFormat: dateFormat,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildLogList({
    required List<LogEntry> logs,
    required ThemeData theme,
    required ColorScheme colorScheme,
    required DateFormat dateFormat,
  }) {
    if (logs.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingXL),
          child: Column(
            children: [
              Icon(
                Icons.history,
                size: AppDimens.iconXXL,
                color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
              ),
              const SizedBox(height: AppDimens.spaceM),
              Text(
                'No logs available',
                style: theme.textTheme.bodyLarge?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ),
      );
    }
    return ListView.separated(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: logs.length,
      separatorBuilder: (context, index) =>
          const Divider(height: AppDimens.spaceL),
      itemBuilder: (context, index) {
        final log = logs[index];
        return LogEntryWidget(log: log, dateFormat: dateFormat);
      },
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/loading_indicator.dart
enum LoadingIndicatorType {
  circle,
  fadingCircle,
  pulse,
  doubleBounce,
  wave,
  threeBounce,
}
class SLLoadingIndicator extends StatelessWidget {
  final double size;
  final Color? color;
  final LoadingIndicatorType type;
  const SLLoadingIndicator({
    super.key,
    this.size = AppDimens.circularProgressSizeL,
    this.color,
    this.type = LoadingIndicatorType.threeBounce,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final indicatorColor = color ?? theme.colorScheme.primary;
    switch (type) {
      case LoadingIndicatorType.circle:
        return SpinKitCircle(color: indicatorColor, size: size);
      case LoadingIndicatorType.fadingCircle:
        return SpinKitFadingCircle(color: indicatorColor, size: size);
      case LoadingIndicatorType.pulse:
        return SpinKitPulse(color: indicatorColor, size: size);
      case LoadingIndicatorType.doubleBounce:
        return SpinKitDoubleBounce(color: indicatorColor, size: size);
      case LoadingIndicatorType.wave:
        return SpinKitWave(color: indicatorColor, size: size);
      case LoadingIndicatorType.threeBounce:
        return SpinKitThreeBounce(color: indicatorColor, size: size * 0.4);
    }
  }
}
class FullScreenLoading extends StatelessWidget {
  final String? message;
  final Color? backgroundColor;
  final Color? indicatorColor;
  final LoadingIndicatorType type;
  const FullScreenLoading({
    super.key,
    this.message,
    this.backgroundColor,
    this.indicatorColor,
    this.type = LoadingIndicatorType.circle,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Container(
      color:
          backgroundColor ??
          colorScheme.surface.withValues(alpha: AppDimens.opacityHigh),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            SLLoadingIndicator(
              color: indicatorColor,
              type: type,
              size: AppDimens.circularProgressSizeL,
            ),
            if (message != null) ...[
              const SizedBox(height: AppDimens.spaceL),
              Text(
                message!,
                style: theme.textTheme.bodyLarge,
                textAlign: TextAlign.center,
              ),
            ],
          ],
        ),
      ),
    );
  }
}
class LoadingOverlay extends StatelessWidget {
  final bool isLoading;
  final Widget child;
  final Color? color;
  final String? message;
  final LoadingIndicatorType type;
  const LoadingOverlay({
    super.key,
    required this.isLoading,
    required this.child,
    this.color,
    this.message,
    this.type = LoadingIndicatorType.circle,
  });
  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        child,
        if (isLoading)
          Positioned.fill(
            child: FullScreenLoading(
              message: message,
              backgroundColor: color,
              type: type,
            ),
          ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/data/repositories/auth_repository_impl.dart
class AuthRepositoryImpl implements AuthRepository {
  final ApiClient _apiClient;
  AuthRepositoryImpl(this._apiClient);
  @override
  Future<AuthResponse> login(String usernameOrEmail, String password) async {
    try {
      final data = {'usernameOrEmail': usernameOrEmail, 'password': password};
      debugPrint('Calling login API with usernameOrEmail: $usernameOrEmail');
      final response = await _apiClient.post(ApiEndpoints.login, data: data);
      if (response == null) {
        throw AuthenticationException('Login failed: No response received');
      }
      if (response['success'] != true) {
        throw AuthenticationException(
          'Login failed: ${response['message'] ?? "Unknown error"}',
        );
      }
      if (response['data'] == null || response['data']['token'] == null) {
        throw AuthenticationException(
          'Login failed: Authentication token not found in response',
        );
      }
      return AuthResponse.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw AuthenticationException('Failed to login: $e');
    }
  }
  @override
  Future<AuthResponse> register(
    String username,
    String email,
    String password,
    String firstName,
    String lastName,
  ) async {
    try {
      final data = {
        'username': username,
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
      };
      final response = await _apiClient.post(ApiEndpoints.register, data: data);
      if (response['success'] != true || response['data'] == null) {
        throw AuthenticationException(
          'Failed to register: ${response['message']}',
        );
      }
      return login(email, password);
    } on AppException {
      rethrow;
    } catch (e) {
      throw AuthenticationException('Failed to register: $e');
    }
  }
  @override
  Future<AuthResponse> refreshToken(String refreshToken) async {
    try {
      final data = {'refreshToken': refreshToken};
      final response = await _apiClient.post(
        ApiEndpoints.refreshToken,
        data: data,
      );
      if (response['success'] != true || response['data'] == null) {
        throw AuthenticationException(
          'Failed to refresh token: ${response['message']}',
        );
      }
      return AuthResponse.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw AuthenticationException('Failed to refresh token: $e');
    }
  }
  @override
  Future<bool> validateToken(String token) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.validateToken,
        queryParameters: {'token': token},
      );
      return response['success'] == true;
    } catch (e) {
      return false;
    }
  }
  @override
  String? getUsernameFromToken(String token) {
    return null;
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/profile/profile_edit_form.dart
class ProfileEditForm extends ConsumerWidget {
  final TextEditingController controller;
  final GlobalKey<FormState> formKey;
  final VoidCallback onCancel;
  final VoidCallback onSave;
  const ProfileEditForm({
    super.key,
    required this.controller,
    required this.formKey,
    required this.onCancel,
    required this.onSave,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Card(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      elevation: 0,
      color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Form(
          key: formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Edit Profile',
                style: theme.textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: AppDimens.spaceL),
              SLTextField(
                label: 'Display Name',
                hint: 'Enter your display name',
                controller: controller,
                prefixIcon: Icons.person,
                backgroundColor: colorScheme.surface,
                borderColor: colorScheme.outline.withValues(alpha: 0.3),
                focusedBorderColor: colorScheme.primary,
                validator: (v) {
                  if (v == null || v.trim().isEmpty) return 'Cannot be empty';
                  if (v.length > 50) return 'Maximum 50 characters';
                  return null;
                },
              ),
              const SizedBox(height: AppDimens.spaceXL),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  SLButton(
                    text: 'Cancel',
                    type: SLButtonType.text,
                    onPressed: onCancel,
                    textColor: colorScheme.error,
                  ),
                  const SizedBox(width: AppDimens.spaceL),
                  Consumer(
                    builder: (context, ref, _) {
                      final isLoading = ref.watch(userStateProvider).isLoading;
                      return SLButton(
                        text: 'Save Changes',
                        type: SLButtonType.primary,
                        onPressed: onSave,
                        isLoading: isLoading,
                      );
                    },
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/utils/cycle_formatter.dart
class CycleFormatter {
  static const Map<CycleStudied, String> _displayNames = {
    CycleStudied.firstTime: 'First Cycle',
    CycleStudied.firstReview: 'First Review Cycle',
    CycleStudied.secondReview: 'Second Review Cycle',
    CycleStudied.thirdReview: 'Third Review Cycle',
    CycleStudied.moreThanThreeReviews: 'Advanced Review Cycle',
  };
  static const Map<CycleStudied, String> _shortFormats = {
    CycleStudied.firstTime: 'First Time',
    CycleStudied.firstReview: 'First Review',
    CycleStudied.secondReview: 'Second Review',
    CycleStudied.thirdReview: 'Third Review',
    CycleStudied.moreThanThreeReviews: 'Advanced Review',
  };
  static const Map<CycleStudied, String> _descriptions = {
    CycleStudied.firstTime:
        'Initial learning phase. Complete all 5 repetitions to move to the next cycle.',
    CycleStudied.firstReview:
        'First review cycle. Reinforcing what you learned in the first cycle.',
    CycleStudied.secondReview:
        'Second review cycle. Consolidating knowledge with longer intervals.',
    CycleStudied.thirdReview:
        'Third review cycle. Material should be familiar at this stage.',
    CycleStudied.moreThanThreeReviews:
        'Advanced review cycle. Knowledge is well-established in long-term memory.',
  };
  static CycleStudied parseCycle(String? cycleString) {
    if (cycleString == null) return CycleStudied.firstTime;
    return CycleStudied.values.firstWhere(
      (e) => e.name.toUpperCase() == cycleString.toUpperCase(),
      orElse: () => CycleStudied.firstTime,
    );
  }
  static String format(CycleStudied cycle) => _shortFormats[cycle]!;
  static String getDescription(CycleStudied cycle) => _descriptions[cycle]!;
  static String getDisplayName(CycleStudied cycle) => _displayNames[cycle]!;
  static CycleStudied mapNumberToCycleStudied(int number) {
    switch (number) {
      case 1:
        return CycleStudied.firstTime;
      case 2:
        return CycleStudied.firstReview;
      case 3:
        return CycleStudied.secondReview;
      case 4:
        return CycleStudied.thirdReview;
      default:
        return CycleStudied.moreThanThreeReviews;
    }
  }
  static Color getColor(CycleStudied cycle, BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    switch (cycle) {
      case CycleStudied.firstTime:
        return colorScheme.primary;
      case CycleStudied.firstReview:
        return colorScheme.tertiary;
      case CycleStudied.secondReview:
        return colorScheme.secondary;
      case CycleStudied.thirdReview:
        return colorScheme.primary;
      case CycleStudied.moreThanThreeReviews:
        return colorScheme.tertiary;
    }
  }
  static IconData getIcon(CycleStudied cycle) {
    switch (cycle) {
      case CycleStudied.firstTime:
        return Icons.looks_one;
      case CycleStudied.firstReview:
        return Icons.looks_two;
      case CycleStudied.secondReview:
        return Icons.looks_3;
      case CycleStudied.thirdReview:
        return Icons.looks_4;
      case CycleStudied.moreThanThreeReviews:
        return Icons.looks_5;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/module_card.dart
class ModuleCardWidget extends StatelessWidget {
  final dynamic module;
  final int index;
  final VoidCallback onTap;
  const ModuleCardWidget({
    super.key,
    required this.module,
    required this.index,
    required this.onTap,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Card(
      elevation: AppDimens.elevationXS,
      color: colorScheme.surfaceContainerLowest,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
        side: BorderSide(
          color: colorScheme.outlineVariant.withValues(
            alpha: AppDimens.opacitySemi,
          ),
          width: 1.0,
        ),
      ),
      margin: const EdgeInsets.only(bottom: AppDimens.paddingM),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingM),
          child: Row(
            children: [
              Container(
                width: AppDimens.iconL + AppDimens.spaceXS,
                height: AppDimens.iconL + AppDimens.spaceXS,
                decoration: BoxDecoration(
                  color: colorScheme.primary.withValues(
                    alpha: AppDimens.opacityLight,
                  ),
                  shape: BoxShape.circle,
                ),
                child: Center(
                  child: Text(
                    '${index + 1}',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: colorScheme.primary,
                    ),
                  ),
                ),
              ),
              const SizedBox(width: AppDimens.spaceM),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      module.title,
                      style: theme.textTheme.bodyLarge?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: colorScheme.onSurface,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    if (module.wordCount != null)
                      Padding(
                        padding: const EdgeInsets.only(top: AppDimens.spaceXXS),
                        child: Text(
                          '${module.wordCount} words',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
              Icon(
                Icons.arrow_forward_ios,
                size: AppDimens.iconS,
                color: colorScheme.onSurfaceVariant,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/network/interceptors/auth_interceptor.dart
class AuthInterceptor extends Interceptor {
  final StorageService _storageService;
  final Dio _dio = Dio();
  bool _isRefreshing = false;
  AuthInterceptor()
    : _storageService = ProviderContainer().read(storageServiceProvider);
  @override
  void onRequest(
    RequestOptions options,
    RequestInterceptorHandler handler,
  ) async {
    if (_shouldSkipAuth(options.path)) {
      return handler.next(options);
    }
    final token = await _storageService.getToken();
    if (token != null && token.isNotEmpty) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    if (err.response?.statusCode != 401 || _isRefreshing) {
      return handler.next(err);
    }
    if (_shouldSkipAuth(err.requestOptions.path)) {
      return handler.next(err);
    }
    try {
      final refreshedToken = await _refreshToken();
      if (refreshedToken == null) {
        return handler.next(err);
      }
      final options = err.requestOptions;
      options.headers['Authorization'] = 'Bearer $refreshedToken';
      final response = await _dio.fetch(options);
      return handler.resolve(response);
    } catch (e) {
      return handler.next(err);
    }
  }
  bool _shouldSkipAuth(String path) {
    final authPaths = [
      ApiEndpoints.login,
      ApiEndpoints.register,
      ApiEndpoints.refreshToken,
      ApiEndpoints.validateToken,
    ];
    return authPaths.any((authPath) => path.contains(authPath));
  }
  Future<String?> _refreshToken() async {
    _isRefreshing = true;
    try {
      final refreshToken = await _storageService.getRefreshToken();
      if (refreshToken == null || refreshToken.isEmpty) {
        await _storageService.clearTokens();
        _isRefreshing = false;
        return null;
      }
      final response = await _dio.post(
        ApiEndpoints.refreshToken,
        data: {'refreshToken': refreshToken},
      );
      if (response.statusCode != 200 || response.data == null) {
        await _storageService.clearTokens();
        _isRefreshing = false;
        return null;
      }
      final newToken = response.data['data']['token'];
      final newRefreshToken = response.data['data']['refreshToken'];
      if (newToken == null || newRefreshToken == null) {
        await _storageService.clearTokens();
        _isRefreshing = false;
        return null;
      }
      await _storageService.saveToken(newToken);
      await _storageService.saveRefreshToken(newRefreshToken);
      _isRefreshing = false;
      return newToken;
    } catch (e) {
      await _storageService.clearTokens();
      _isRefreshing = false;
      return null;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/learning_filter_bar/filter_book_selector.dart
class FilterBookSelector extends ConsumerWidget {
  final String selectedBook;
  final List<String> books;
  final Function(String?) onBookChanged;
  const FilterBookSelector({
    super.key,
    required this.selectedBook,
    required this.books,
    required this.onBookChanged,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final hasBookFilter = selectedBook != 'All';
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Select Book',
          style: theme.textTheme.labelMedium?.copyWith(
            color: colorScheme.onSurface.withValues(
              alpha: AppDimens.opacityHigh,
            ),
          ),
        ),
        const SizedBox(height: AppDimens.spaceXS),
        SizedBox(
          height: 48,
          child: Container(
            decoration: BoxDecoration(
              border: Border.all(
                color: hasBookFilter
                    ? colorScheme.primary
                    : colorScheme.outline.withValues(
                        alpha: AppDimens.opacitySemi,
                      ),
                width: hasBookFilter ? 2 : 1,
              ),
              borderRadius: BorderRadius.circular(AppDimens.radiusM),
            ),
            child: DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                value: selectedBook,
                isExpanded: true,
                icon: Icon(
                  Icons.arrow_drop_down,
                  color: hasBookFilter ? colorScheme.primary : null,
                  size: AppDimens.iconL,
                ),
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimens.paddingL,
                  vertical: AppDimens.paddingS,
                ),
                borderRadius: BorderRadius.circular(AppDimens.radiusM),
                dropdownColor: colorScheme.surface,
                items: books.map((book) {
                  final isSelected = book == selectedBook;
                  final isAll = book == 'All';
                  return DropdownMenuItem(
                    value: book,
                    child: Text(
                      book,
                      style: TextStyle(
                        color: isSelected && !isAll
                            ? colorScheme.primary
                            : colorScheme.onSurface,
                        fontWeight: isSelected && !isAll
                            ? FontWeight.bold
                            : null,
                      ),
                    ),
                  );
                }).toList(),
                onChanged: onBookChanged,
              ),
            ),
          ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/theme/theme_extensions.dart
extension SemanticColorExtension on ThemeData {
  Color getScoreColor(double score) {
    final colorScheme = this.colorScheme;
    if (score >= 90) return Colors.green.shade700;
    if (score >= 75) return colorScheme.primary;
    if (score >= 60) return colorScheme.secondary;
    if (score >= 40) return Colors.orange.shade700;
    return colorScheme.error;
  }
  Color getRepetitionColor(int orderIndex, {bool isHistory = false}) {
    final List<Color> repetitionColors = [
      const Color(0xFF4CAF50).withValues(alpha: 0.9), // Lighter green
      const Color(0xFF2196F3).withValues(alpha: 0.9), // Lighter blue
      const Color(0xFFF57C00).withValues(alpha: 0.85), // Lighter orange
      const Color(0xFF9C27B0).withValues(alpha: 0.85), // Lighter purple
      const Color(0xFFE53935).withValues(alpha: 0.8), // Lighter red
    ];
    final baseColor =
        repetitionColors[(orderIndex - 1) % repetitionColors.length];
    return isHistory ? baseColor.withValues(alpha: 0.7) : baseColor;
  }
  Color getProgressColor(double percent) {
    final colorScheme = this.colorScheme;
    if (percent >= 90) return colorScheme.tertiary;
    if (percent >= 60) return colorScheme.primary;
    if (percent >= 30) return colorScheme.secondary;
    return colorScheme.error;
  }
  Color getCycleColor(CycleStudied cycle) {
    final colorScheme = this.colorScheme;
    switch (cycle) {
      case CycleStudied.firstTime:
        return colorScheme.primary;
      case CycleStudied.firstReview:
        return colorScheme.secondary;
      case CycleStudied.secondReview:
        return colorScheme.tertiary;
      case CycleStudied.thirdReview:
        return Colors.orange;
      case CycleStudied.moreThanThreeReviews:
        return Colors.purple;
    }
  }
}
extension SemanticColorSchemeExtension on ColorScheme {
  Color getStatColor(String statType) {
    switch (statType) {
      case 'success':
        return success;
      case 'warning':
        return warning;
      case 'error':
        return error;
      case 'info':
        return info;
      case 'primary':
        return primary;
      case 'secondary':
        return secondary;
      case 'tertiary':
        return tertiary;
      default:
        return onSurfaceVariant.withValues(alpha: 0.6);
    }
  }
  Color getStatBackgroundColor(String statType, {double opacity = 0.1}) {
    return getStatColor(statType).withValues(alpha: opacity);
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/modules/module_content_section.dart
class ModuleContentSection extends StatelessWidget {
  final ModuleDetail module;
  const ModuleContentSection({super.key, required this.module});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Content Overview', style: theme.textTheme.titleLarge),
        const SizedBox(height: AppDimens.spaceM),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(AppDimens.paddingL),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (module.wordCount != null && module.wordCount! > 0) ...[
                  Row(
                    children: [
                      const Icon(Icons.format_size),
                      const SizedBox(width: AppDimens.spaceM),
                      Text(
                        'Word Count: ${module.wordCount}',
                        style: theme.textTheme.bodyMedium,
                      ),
                    ],
                  ),
                  const SizedBox(height: AppDimens.spaceM),
                ],
                const Text(
                  'This is where the module content would be displayed. '
                  'In a complete application, this would include text, '
                  'images, videos, and other learning materials.',
                ),
                const SizedBox(height: AppDimens.spaceL),
                _buildStudyTips(context),
              ],
            ),
          ),
        ),
      ],
    );
  }
  Widget _buildStudyTips(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.all(AppDimens.paddingM),
      decoration: BoxDecoration(
        color: theme.colorScheme.primary.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.lightbulb, color: theme.colorScheme.primary),
              const SizedBox(width: AppDimens.spaceM),
              Text(
                'Study Tips',
                style: theme.textTheme.titleMedium?.copyWith(
                  color: theme.colorScheme.primary,
                ),
              ),
            ],
          ),
          const SizedBox(height: AppDimens.spaceM),
          const Text(
            '• Review this module regularly using the spaced repetition schedule\n'
            '• Take notes while studying\n'
            '• Try to recall the material before checking your answers\n'
            '• Connect new information to things you already know',
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/report/status_card_widget.dart
class StatusCardWidget extends StatelessWidget {
  final bool isActive;
  final ValueChanged<bool> onToggle;
  const StatusCardWidget({
    super.key,
    required this.isActive,
    required this.onToggle,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Card(
      elevation: AppDimens.elevationM,
      color: colorScheme.surfaceContainerLowest,
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  isActive ? Icons.check_circle : Icons.error_outline,
                  color: isActive ? colorScheme.primary : colorScheme.error,
                  size: AppDimens.iconL,
                ),
                const SizedBox(width: AppDimens.spaceM),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Automatic check status',
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: AppDimens.spaceXS),
                      Text(
                        isActive ? 'Active' : 'Inactive',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: isActive
                              ? colorScheme.primary
                              : colorScheme.error,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                ),
                SizedBox(
                  width: 70, // Fixed width for the switch
                  child: Switch(
                    value: isActive,
                    onChanged: onToggle,
                    activeColor: colorScheme.primary,
                  ),
                ),
              ],
            ),
            const SizedBox(height: AppDimens.spaceM),
            const Divider(height: 1),
            const SizedBox(height: AppDimens.spaceM),
            Text(
              'Check time: 00:05 AM daily',
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: AppDimens.spaceS),
            Text(
              'The system will automatically check due tasks and schedule reminder notifications.',
              style: theme.textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/theme/app_theme_data.dart
abstract final class AppTheme {
  static ThemeData light = FlexThemeData.light(
    colorScheme: geminiLightColorScheme,
    subThemesData: const FlexSubThemesData(
      interactionEffects: true,
      tintedDisabledControls: true,
      useM2StyleDividerInM3: true,
      inputDecoratorIsFilled: true,
      inputDecoratorBorderType: FlexInputBorderType.outline,
      alignedDropdown: true,
      navigationRailUseIndicator: true,
    ),
    keyColors: const FlexKeyColors(
      useSecondary: true,
      useTertiary: true,
      useError: true,
    ),
    visualDensity: FlexColorScheme.comfortablePlatformDensity,
    cupertinoOverrideTheme: const CupertinoThemeData(applyThemeToAll: true),
  );
  static ThemeData dark = FlexThemeData.dark(
    colorScheme: geminiDarkColorScheme,
    subThemesData: const FlexSubThemesData(
      interactionEffects: true,
      tintedDisabledControls: true,
      blendOnColors: true,
      useM2StyleDividerInM3: true,
      inputDecoratorIsFilled: true,
      inputDecoratorBorderType: FlexInputBorderType.outline,
      alignedDropdown: true,
      navigationRailUseIndicator: true,
    ),
    keyColors: const FlexKeyColors(
      useSecondary: true,
      useTertiary: true,
      useError: true,
    ),
    visualDensity: FlexColorScheme.comfortablePlatformDensity,
    cupertinoOverrideTheme: const CupertinoThemeData(applyThemeToAll: true),
  );
}
@riverpod
ThemeData lightTheme(Ref ref) => AppTheme.light;
@riverpod
ThemeData darkTheme(Ref ref) => AppTheme.dark;
@riverpod
class ThemeModeState extends _$ThemeModeState {
  @override
  ThemeMode build() {
    final isDarkMode = ref
        .watch(isDarkModeProvider)
        .valueOrNull ?? false;
    return isDarkMode ? ThemeMode.dark : ThemeMode.light;
  }
  Future<void> toggleTheme() async {
    final storageService = ref.read(storageServiceProvider);
    final current = state;
    if (current == ThemeMode.dark) {
      await storageService.saveDarkMode(false);
      state = ThemeMode.light;
      ref.invalidate(isDarkModeProvider);
    } else {
      await storageService.saveDarkMode(true);
      state = ThemeMode.dark;
      ref.invalidate(isDarkModeProvider);
    }
  }
}
@riverpod
class IsDarkMode extends _$IsDarkMode {
  @override
  Future<bool> build() {
    final storageService = ref.watch(storageServiceProvider);
    return storageService.isDarkMode();
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/report/last_check_card_widget.dart
class LastCheckCardWidget extends StatelessWidget {
  final DateTime? lastCheckTime;
  final bool lastCheckResult;
  final int lastCheckTaskCount;
  final String? lastCheckError;
  const LastCheckCardWidget({
    super.key,
    required this.lastCheckTime,
    required this.lastCheckResult,
    required this.lastCheckTaskCount,
    this.lastCheckError,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Card(
      elevation: AppDimens.elevationM,
      color: colorScheme.surfaceContainerLowest,
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Last Check Results',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: AppDimens.spaceM),
            const Divider(height: 1),
            const SizedBox(height: AppDimens.spaceM),
            InfoRowWidget(
              label: 'Time:',
              value: lastCheckTime != null
                  ? AppDateUtils.formatDate(
                      lastCheckTime!,
                      format: 'dd/MM/yyyy HH:mm:ss',
                    )
                  : 'No data',
              icon: Icons.access_time,
            ),
            const SizedBox(height: AppDimens.spaceM),
            InfoRowWidget(
              label: 'Status:',
              value: lastCheckResult ? 'Success' : 'Failed',
              icon: lastCheckResult ? Icons.check_circle : Icons.error,
              valueColor: lastCheckResult
                  ? colorScheme.primary
                  : colorScheme.error,
            ),
            const SizedBox(height: AppDimens.spaceM),
            InfoRowWidget(
              label: 'Tasks:',
              value: lastCheckTaskCount > 0
                  ? '$lastCheckTaskCount tasks due'
                  : 'No tasks due',
              icon: Icons.assignment,
            ),
            if (lastCheckError != null) ...[
              const SizedBox(height: AppDimens.spaceM),
              InfoRowWidget(
                label: 'Error:',
                value: lastCheckError!,
                icon: Icons.warning_amber,
                valueColor: colorScheme.error,
              ),
            ],
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/learning_stats/module_stats_grid.dart
class ModuleStatsGrid extends StatelessWidget {
  final LearningStatsDTO stats;
  final ThemeData theme;
  final bool isSmallScreen;
  const ModuleStatsGrid({
    super.key,
    required this.stats,
    required this.theme,
    this.isSmallScreen = false,
  });
  @override
  Widget build(BuildContext context) {
    final colorScheme = theme.colorScheme;
    final cycleStats = stats.cycleStats;
    return GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: isSmallScreen ? 3 : 4,
      childAspectRatio: isSmallScreen ? 0.8 : 0.8,
      mainAxisSpacing: AppDimens.spaceS,
      crossAxisSpacing: AppDimens.spaceS,
      children: [
        StatGridItem(
          theme: theme,
          value: stats.totalModules.toString(),
          label: 'Total\nModules',
          iconData: Icons.menu_book,
          color: colorScheme.getStatColor('warning'),
        ),
        StatGridItem(
          theme: theme,
          value: '${cycleStats['NOT_STUDIED'] ?? 0}',
          label: 'Not\nStudied',
          iconData: Icons.visibility_off,
          color: colorScheme.getStatColor('neutral'),
        ),
        StatGridItem(
          theme: theme,
          value: '${cycleStats['FIRST_TIME'] ?? 0}',
          label: '1st\nTime',
          iconData: Icons.play_circle_fill,
          color: colorScheme.getStatColor('success'),
        ),
        StatGridItem(
          theme: theme,
          value: '${cycleStats['FIRST_REVIEW'] ?? 0}',
          label: '1st\nReview',
          iconData: Icons.rotate_right,
          color: colorScheme.getStatColor('secondary'),
        ),
        StatGridItem(
          theme: theme,
          value: '${cycleStats['SECOND_REVIEW'] ?? 0}',
          label: '2nd\nReview',
          iconData: Icons.rotate_90_degrees_ccw,
          color: colorScheme.getStatColor('info'),
        ),
        StatGridItem(
          theme: theme,
          value: '${cycleStats['THIRD_REVIEW'] ?? 0}',
          label: '3rd\nReview',
          iconData: Icons.change_circle,
          color: colorScheme.getStatColor('secondary'),
        ),
        StatGridItem(
          theme: theme,
          value: '${cycleStats['MORE_THAN_THREE_REVIEWS'] ?? 0}',
          label: '4th+\nReviews',
          iconData: Icons.loop,
          color: colorScheme.getStatColor('tertiary'),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/app_info/about_screen.dart
class AboutScreen extends StatelessWidget {
  const AboutScreen({super.key});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Scaffold(
      appBar: AppBar(title: const Text('About')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'About Spaced Learning App',
              style: theme.textTheme.headlineSmall,
            ),
            const SizedBox(height: AppDimens.spaceL),
            const Text(
              'Spaced Learning App helps you learn more effectively using '
              'scientifically proven spaced repetition techniques.',
            ),
            const SizedBox(height: AppDimens.spaceXL),
            const Text('Version: 1.0.0'),
            const SizedBox(height: AppDimens.spaceM),
            const Text('© 2023 Your Company'),
            const SizedBox(height: AppDimens.spaceXXL),
            Text('Deep Link Demo', style: theme.textTheme.titleMedium),
            const SizedBox(height: AppDimens.spaceM),
            const Text('Here are some examples of deep links to try:'),
            const SizedBox(height: AppDimens.spaceM),
            _buildDeepLinkCard(
              context,
              'Open Books Screen',
              '/books',
              colorScheme.primaryContainer,
            ),
            _buildDeepLinkCard(
              context,
              'Open Learning Screen',
              '/learning',
              colorScheme.secondaryContainer,
            ),
            _buildDeepLinkCard(
              context,
              'Open Profile Screen',
              '/profile',
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildDeepLinkCard(
    BuildContext context,
    String title,
    String route,
    Color backgroundColor,
  ) {
    return Card(
      margin: const EdgeInsets.only(bottom: AppDimens.spaceM),
      color: backgroundColor,
      child: InkWell(
        onTap: () => GoRouter.of(context).go(route),
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingL),
          child: Row(
            children: [
              Expanded(child: Text(title)),
              const Icon(Icons.arrow_forward),
            ],
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/main/learning_error_view.dart
class LearningErrorView extends ConsumerWidget {
  final String errorMessage;
  final VoidCallback onRetry;
  const LearningErrorView({
    super.key,
    required this.errorMessage,
    required this.onRetry,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Center(
      child: Container(
        padding: const EdgeInsets.all(AppDimens.paddingXXL),
        decoration: BoxDecoration(
          color: colorScheme.errorContainer.withValues(
            alpha: AppDimens.opacityVeryHigh,
          ),
          borderRadius: BorderRadius.circular(AppDimens.radiusL),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: AppDimens.opacityMedium),
              blurRadius: AppDimens.shadowRadiusL,
              offset: const Offset(0, AppDimens.shadowOffsetM),
            ),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: AppDimens.iconXXL,
              color: colorScheme.onErrorContainer,
            ),
            const SizedBox(height: AppDimens.spaceL),
            Text(
              'Oops! Something went wrong',
              style: theme.textTheme.titleLarge?.copyWith(
                color: colorScheme.onErrorContainer,
              ),
            ),
            const SizedBox(height: AppDimens.spaceS),
            Text(
              errorMessage,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onErrorContainer,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: AppDimens.spaceXL),
            ElevatedButton.icon(
              onPressed: onRetry,
              icon: const Icon(Icons.refresh),
              label: const Text('Try Again'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimens.paddingXL,
                  vertical: AppDimens.paddingM,
                ),
                backgroundColor: colorScheme.onErrorContainer,
                foregroundColor: colorScheme.errorContainer,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/network/interceptors/logging_interceptor.dart
class LoggingInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    final headers = options.headers.toString();
    final queryParameters = options.queryParameters.toString();
    final data = options.data.toString();
    debugPrint('┌───────────────────────────────────────────────────────');
    debugPrint('│ REQUEST: ${options.method} ${options.uri}');
    debugPrint('│ Headers: $headers');
    if (options.queryParameters.isNotEmpty) {
      debugPrint('│ Query Parameters: $queryParameters');
    }
    if (options.data != null) {
      debugPrint('│ Body: $data');
    }
    debugPrint('└───────────────────────────────────────────────────────');
    super.onRequest(options, handler);
  }
  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    final statusCode = response.statusCode;
    final data = response.data.toString();
    debugPrint('┌───────────────────────────────────────────────────────');
    debugPrint('│ RESPONSE: $statusCode ${response.requestOptions.uri}');
    debugPrint('│ Body: $data');
    debugPrint('└───────────────────────────────────────────────────────');
    super.onResponse(response, handler);
  }
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    final statusCode = err.response?.statusCode;
    final errorMessage = err.message;
    final errorData = err.response?.data.toString();
    debugPrint('┌───────────────────────────────────────────────────────');
    debugPrint('│ ERROR: $statusCode ${err.requestOptions.uri}');
    debugPrint('│ Message: $errorMessage');
    if (errorData != null) {
      debugPrint('│ Data: $errorData');
    }
    debugPrint('└───────────────────────────────────────────────────────');
    super.onError(err, handler);
  }
}

// D:/workspace/spaced_learning_app/lib/core/services/screen_refresh_manager.dart
class ScreenRefreshManager {
  static final ScreenRefreshManager _instance =
      ScreenRefreshManager._internal();
  factory ScreenRefreshManager() => _instance;
  ScreenRefreshManager._internal();
  final Map<String, List<VoidCallback>> _refreshCallbacks = {};
  void registerRefreshCallback(String screenPath, VoidCallback callback) {
    if (!_refreshCallbacks.containsKey(screenPath)) {
      _refreshCallbacks[screenPath] = [];
    }
    if (!_refreshCallbacks[screenPath]!.contains(callback)) {
      _refreshCallbacks[screenPath]!.add(callback);
    }
  }
  void unregisterRefreshCallback(String screenPath, VoidCallback callback) {
    if (!_refreshCallbacks.containsKey(screenPath)) {
      return;
    }
    _refreshCallbacks[screenPath]!.remove(callback);
    if (_refreshCallbacks[screenPath]!.isEmpty) {
      _refreshCallbacks.remove(screenPath);
    }
  }
  void refreshScreen(String screenPath) {
    debugPrint('Refreshing screen: $screenPath');
    if (!_refreshCallbacks.containsKey(screenPath)) {
      return;
    }
    for (var callback in _refreshCallbacks[screenPath]!) {
      callback();
    }
  }
  void refreshScreensWithPrefix(String prefix) {
    _refreshCallbacks.forEach((path, callbacks) {
      if (!path.startsWith(prefix)) {
        return;
      }
      debugPrint('Refreshing screen with prefix $prefix: $path');
      for (var callback in callbacks) {
        callback();
      }
    });
  }
  void refreshAllScreens() {
    _refreshCallbacks.forEach((path, callbacks) {
      debugPrint('Refreshing all screens: $path');
      for (var callback in callbacks) {
        callback();
      }
    });
  }
}
@Riverpod(keepAlive: true)
ScreenRefreshManager screenRefreshManager(Ref ref) {
  return ScreenRefreshManager();
}
@riverpod
class ScreenRefresh extends _$ScreenRefresh {
  @override
  void build() {
  }
  void refreshScreen(String screenPath) {
    final manager = ref.read(screenRefreshManagerProvider);
    manager.refreshScreen(screenPath);
  }
  void refreshScreensWithPrefix(String prefix) {
    final manager = ref.read(screenRefreshManagerProvider);
    manager.refreshScreensWithPrefix(prefix);
  }
  void refreshAllScreens() {
    final manager = ref.read(screenRefreshManagerProvider);
    manager.refreshAllScreens();
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/profile/theme_toggle_card.dart
class ThemeToggleCard extends ConsumerWidget {
  const ThemeToggleCard({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final themeMode = ref.watch(themeModeStateProvider);
    final isDarkMode = themeMode == ThemeMode.dark;
    return Card(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      elevation: 0,
      color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingS),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(AppDimens.paddingM),
              decoration: BoxDecoration(
                color: isDarkMode
                    ? colorScheme.tertiary.withValues(alpha: 0.1)
                    : colorScheme.primary.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Icon(
                isDarkMode ? Icons.dark_mode : Icons.light_mode,
                color: isDarkMode ? colorScheme.tertiary : colorScheme.primary,
                size: 24,
              ),
            ),
            const SizedBox(width: AppDimens.spaceL),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Dark Mode',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  Text(
                    isDarkMode ? 'On' : 'Off',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: colorScheme.onSurface.withValues(alpha: 0.6),
                    ),
                  ),
                ],
              ),
            ),
            Switch(
              value: isDarkMode,
              onChanged: (value) =>
                  ref.read(themeModeStateProvider.notifier).toggleTheme(),
              activeColor: colorScheme.tertiary,
            ),
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/due_progress_filter_card.dart
class DueProgressFilterCard extends StatelessWidget {
  final DateTime? selectedDate;
  final VoidCallback onSelectDate;
  final VoidCallback onClearDate;
  const DueProgressFilterCard({
    super.key,
    required this.selectedDate,
    required this.onSelectDate,
    required this.onClearDate,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final dateFormat = DateFormat('MMM dd, yyyy');
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
      color: theme.scaffoldBackgroundColor,
      child: Card(
        elevation: 0,
        color: theme.colorScheme.surfaceContainerLow,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
          side: BorderSide(
            color: theme.colorScheme.outlineVariant.withValues(alpha: 0.5),
            width: 1,
          ),
        ),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          child: Row(
            children: [
              Icon(
                Icons.calendar_today,
                size: 20,
                color: theme.colorScheme.primary,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  selectedDate == null
                      ? 'Due Today'
                      : 'Due by ${dateFormat.format(selectedDate!)}',
                  style: theme.textTheme.titleMedium?.copyWith(
                    color: theme.colorScheme.onSurface,
                  ),
                ),
              ),
              if (selectedDate != null)
                IconButton(
                  icon: const Icon(Icons.clear),
                  onPressed: onClearDate,
                  tooltip: 'Clear date filter',
                  iconSize: 20,
                  visualDensity: VisualDensity.compact,
                ),
              IconButton(
                icon: const Icon(Icons.calendar_month),
                onPressed: onSelectDate,
                tooltip: 'Select date',
                iconSize: 20,
                visualDensity: VisualDensity.compact,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/navigation/route_observer.dart
class AppRouteObserver extends NavigatorObserver {
  static final AppRouteObserver _instance = AppRouteObserver._internal();
  factory AppRouteObserver() => _instance;
  AppRouteObserver._internal();
  final List<RouteAware> _routeAwareWidgets = [];
  final Map<String, List<Function>> _routeHandlers = {};
  void subscribe(RouteAware routeAware, Route route) {
    _routeAwareWidgets.add(routeAware);
    for (final widget in _routeAwareWidgets) {
      if (widget == routeAware) {
        widget.didPush();
        break;
      }
    }
  }
  void unsubscribe(RouteAware routeAware) {
    _routeAwareWidgets.remove(routeAware);
  }
  void addRouteHandler(String routePath, Function handler) {
    if (!_routeHandlers.containsKey(routePath)) {
      _routeHandlers[routePath] = [];
    }
    _routeHandlers[routePath]!.add(handler);
  }
  void removeRouteHandler(String routePath, Function handler) {
    if (_routeHandlers.containsKey(routePath)) {
      _routeHandlers[routePath]!.remove(handler);
      if (_routeHandlers[routePath]!.isEmpty) {
        _routeHandlers.remove(routePath);
      }
    }
  }
  @override
  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {
    super.didPush(route, previousRoute);
    _notifyRouteHandlers(route);
    if (previousRoute == null) {
      return;
    }
    for (final widget in _routeAwareWidgets) {
      widget.didPushNext();
    }
  }
  @override
  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
    if (newRoute == null) {
      return;
    }
    _notifyRouteHandlers(newRoute);
  }
  @override
  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {
    super.didPop(route, previousRoute);
    for (final widget in _routeAwareWidgets) {
      widget.didPop();
    }
    if (previousRoute == null) {
      return;
    }
    _notifyRouteHandlers(previousRoute);
    for (final widget in _routeAwareWidgets) {
      widget.didPopNext();
    }
  }
  void _notifyRouteHandlers(Route route) {
    final String routeName = route.settings.name ?? '';
    _routeHandlers.forEach((path, handlers) {
      if (!routeName.startsWith(path)) {
        return;
      }
      for (var handler in handlers) {
        handler();
      }
    });
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/app_empty_state.dart
class SLEmptyState extends StatelessWidget {
  final IconData? icon;
  final String title;
  final String? message;
  final String? buttonText;
  final VoidCallback? onButtonPressed;
  final double? iconSize;
  const SLEmptyState({
    super.key,
    this.icon = Icons.inbox_outlined,
    required this.title,
    this.message,
    this.buttonText,
    this.onButtonPressed,
    this.iconSize = AppDimens.iconXXL,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingXL),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            if (icon != null)
              Icon(
                icon,
                size: iconSize,
                color: colorScheme.primary.withValues(
                  alpha: AppDimens.opacityHigh,
                ),
              ),
            const SizedBox(height: AppDimens.spaceXL),
            Text(
              title,
              textAlign: TextAlign.center,
              style: theme.textTheme.titleLarge!.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
            if (message != null) ...[
              const SizedBox(height: AppDimens.spaceS),
              Text(
                message!,
                textAlign: TextAlign.center,
                style: theme.textTheme.bodyMedium!.copyWith(
                  color: colorScheme.onSurface.withValues(
                    alpha: AppDimens.opacityHigh,
                  ),
                ),
              ),
            ],
            if (buttonText != null && onButtonPressed != null) ...[
              const SizedBox(height: AppDimens.spaceXL),
              SLButton(
                text: buttonText!,
                onPressed: onButtonPressed,
                type: SLButtonType.primary,
                prefixIcon: Icons.refresh,
              ),
            ],
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/dashboard/stats_card.dart
class StatsCard extends StatelessWidget {
  final ModuleStats moduleStats;
  final DueStats dueStats;
  final CompletionStats completionStats;
  final StreakStats streakStats;
  final VocabularyStats vocabularyStats;
  final VoidCallback? onViewProgress;
  const StatsCard({
    super.key,
    required this.moduleStats,
    required this.dueStats,
    required this.completionStats,
    required this.streakStats,
    required this.vocabularyStats,
    this.onViewProgress,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final statsDTO = LearningStatsDTO(
      totalModules: moduleStats.totalModules,
      cycleStats: moduleStats.cycleStats,
      dueToday: dueStats.dueToday,
      dueThisWeek: dueStats.dueThisWeek,
      dueThisMonth: dueStats.dueThisMonth,
      wordsDueToday: dueStats.wordsDueToday,
      wordsDueThisWeek: dueStats.wordsDueThisWeek,
      wordsDueThisMonth: dueStats.wordsDueThisMonth,
      completedToday: completionStats.completedToday,
      wordsCompletedToday: completionStats.wordsCompletedToday,
      streakDays: streakStats.streakDays,
      streakWeeks: streakStats.streakWeeks,
      longestStreakDays: streakStats.streakDays,
      totalWords: vocabularyStats.totalWords,
      learnedWords: vocabularyStats.learnedWords,
      pendingWords: vocabularyStats.pendingWords,
      vocabularyCompletionRate: vocabularyStats.vocabularyCompletionRate,
      weeklyNewWordsRate: vocabularyStats.weeklyNewWordsRate,
    );
    return LearningStatsCard(
      stats: statsDTO,
      onViewDetailPressed: onViewProgress,
      theme: theme,
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/progress_repetition_widgets.dart
class ProgressSectionHeader extends StatelessWidget {
  final String title;
  final IconData icon;
  final Color color;
  const ProgressSectionHeader({
    super.key,
    required this.title,
    required this.icon,
    required this.color,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Row(
        children: [
          Icon(icon, size: 20, color: color),
          const SizedBox(width: 8),
          Text(
            title,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }
}
class ProgressInfoItem extends StatelessWidget {
  final IconData icon;
  final String text;
  final ColorScheme colorScheme;
  const ProgressInfoItem({
    super.key,
    required this.icon,
    required this.text,
    required this.colorScheme,
  });
  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, color: colorScheme.primary, size: AppDimens.iconM),
        const SizedBox(width: AppDimens.spaceM),
        Expanded(child: Text(text)),
      ],
    );
  }
}
class StatusBadge extends StatelessWidget {
  final String text;
  final Color backgroundColor;
  final Color textColor;
  const StatusBadge({
    super.key,
    required this.text,
    required this.backgroundColor,
    required this.textColor,
  });
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingS,
        vertical: AppDimens.paddingXXS,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(AppDimens.radiusXS),
      ),
      child: Text(
        text,
        style: TextStyle(
          color: textColor,
          fontWeight: FontWeight.bold,
          fontSize: 12,
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/home_app_bar.dart
class HomeAppBar extends StatelessWidget implements PreferredSizeWidget {
  final bool isDarkMode;
  final VoidCallback onThemeToggle;
  final VoidCallback? onMenuPressed;
  const HomeAppBar({
    super.key,
    required this.isDarkMode,
    required this.onThemeToggle,
    this.onMenuPressed,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return AppBar(
      leading: IconButton(
        icon: Icon(
          Icons.menu,
          size: AppDimens.iconL,
          color: colorScheme.onSurface,
        ),
        onPressed: onMenuPressed,
        tooltip: 'Menu',
      ),
      title: Text(
        'Spaced Learning',
        style: theme.textTheme.titleLarge?.copyWith(
          color: colorScheme.onSurface,
        ),
      ),
      backgroundColor: colorScheme.surface,
      actions: [
        _buildThemeToggleButton(theme, colorScheme),
        _buildNotificationsButton(context, theme, colorScheme),
      ],
    );
  }
  Widget _buildThemeToggleButton(ThemeData theme, ColorScheme colorScheme) {
    return IconButton(
      icon: Icon(
        isDarkMode ? Icons.light_mode : Icons.dark_mode,
        size: AppDimens.iconL,
        color: colorScheme.onSurface,
      ),
      onPressed: onThemeToggle,
      tooltip: 'Toggle theme',
    );
  }
  Widget _buildNotificationsButton(
    BuildContext context,
    ThemeData theme,
    ColorScheme colorScheme,
  ) {
    return IconButton(
      icon: Icon(
        Icons.notifications_outlined,
        size: AppDimens.iconL,
        color: colorScheme.onSurface,
      ),
      onPressed: () => _showNotificationsSnackBar(context, theme),
      tooltip: 'Notifications',
    );
  }
  void _showNotificationsSnackBar(BuildContext context, ThemeData theme) {
    SnackBarUtils.show(
      context,
      'Notifications coming soon',
      backgroundColor: theme.colorScheme.primary,
    );
  }
  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/learning_stats/streak_stats_grid.dart
class StreakStatsGrid extends StatelessWidget {
  final LearningStatsDTO stats;
  final ThemeData theme;
  final bool isSmallScreen;
  const StreakStatsGrid({
    super.key,
    required this.stats,
    required this.theme,
    this.isSmallScreen = false,
  });
  @override
  Widget build(BuildContext context) {
    final colorScheme = theme.colorScheme;
    final starColor = colorScheme.getStatColor('warning');
    final onStarColor = theme.brightness == Brightness.light
        ? Colors.white
        : theme.colorScheme.surface;
    return GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: isSmallScreen ? 2 : 4,
      childAspectRatio: isSmallScreen ? 0.8 : 0.75,
      mainAxisSpacing: AppDimens.spaceS,
      crossAxisSpacing: AppDimens.spaceS,
      children: [
        StatGridItem(
          theme: theme,
          value: '${stats.streakDays}',
          label: 'Day\nStreak',
          iconData: Icons.local_fire_department,
          color: colorScheme.getStatColor('error'),
          showStar: stats.streakDays >= 7,
          starColor: starColor,
          onStarColor: onStarColor,
        ),
        StatGridItem(
          theme: theme,
          value: '${stats.streakWeeks}',
          label: 'Week\nStreak',
          iconData: Icons.date_range,
          color: colorScheme.getStatColor('secondary'),
          showStar: stats.streakWeeks >= 4,
          starColor: starColor,
          onStarColor: onStarColor,
        ),
        StatGridItem(
          theme: theme,
          value: '${stats.longestStreakDays}',
          label: 'Longest\nStreak',
          iconData: Icons.emoji_events,
          color: colorScheme.getStatColor('warning'),
          additionalInfo: 'days',
        ),
        if (!isSmallScreen) const SizedBox.shrink(),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/learning_stats_viewmodel.dart
@riverpod
class LearningStatsState extends _$LearningStatsState {
  @override
  Future<LearningStatsDTO?> build() async {
    return _loadStats();
  }
  Future<LearningStatsDTO?> _loadStats({bool refreshCache = false}) async {
    try {
      final stats = await ref
          .read(learningStatsRepositoryProvider)
          .getDashboardStats(refreshCache: refreshCache);
      return stats;
    } catch (e, st) {
      throw AsyncError(e, st);
    }
  }
  Future<void> loadDashboardStats({bool refreshCache = false}) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(
      () => _loadStats(refreshCache: refreshCache),
    );
  }
}
@riverpod
class LearningInsights extends _$LearningInsights {
  @override
  Future<List<LearningInsightRespone>> build() async {
    return _loadInsights();
  }
  Future<List<LearningInsightRespone>> _loadInsights() async {
    try {
      final insights = await ref
          .read(learningStatsRepositoryProvider)
          .getLearningInsights();
      return insights;
    } catch (e, st) {
      throw AsyncError(e, st);
    }
  }
  Future<void> loadLearningInsights() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(_loadInsights);
  }
}
@riverpod
Future<void> loadAllStats(
  Ref ref, {
  @Default(false) required bool refreshCache,
}) async {
  try {
    final statsRepo = ref.read(learningStatsRepositoryProvider);
    await Future.wait([
      statsRepo.getDashboardStats(refreshCache: refreshCache),
      statsRepo.getLearningInsights(),
    ]);
    ref.invalidate(learningStatsStateProvider);
    ref.invalidate(learningInsightsProvider);
  } catch (e) {
    debugPrint('Error loading all stats: $e');
    rethrow;
  }
}

// D:/workspace/spaced_learning_app/lib/data/repositories/module_repository_impl.dart
class ModuleRepositoryImpl implements ModuleRepository {
  final ApiClient _apiClient;
  ModuleRepositoryImpl(this._apiClient);
  @override
  Future<List<ModuleSummary>> getAllModules({
    int page = 0,
    int size = 20,
  }) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.modules,
        queryParameters: {'page': page, 'size': size},
      );
      if (response['success'] != true || response['content'] == null) {
        return [];
      }
      final List<dynamic> moduleList = response['content'];
      return moduleList.map((item) => ModuleSummary.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get modules: $e');
    }
  }
  @override
  Future<ModuleDetail> getModuleById(String id) async {
    try {
      final response = await _apiClient.get('${ApiEndpoints.modules}/$id');
      if (response['success'] != true || response['data'] == null) {
        throw NotFoundException('Module not found: ${response['message']}');
      }
      return ModuleDetail.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get module: $e');
    }
  }
  @override
  Future<List<ModuleSummary>> getModulesByBookId(
    String bookId, {
    int page = 0,
    int size = 20,
  }) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.modulesByBook(bookId),
        queryParameters: {'page': page, 'size': size},
      );
      final content = response['content'];
      if (content == null || content is! List) {
        return [];
      }
      return content.map((item) => ModuleSummary.fromJson(item)).toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get modules by book: $e');
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/learning_stats/due_stats_grid.dart
class DueStatsGrid extends StatelessWidget {
  final LearningStatsDTO stats;
  final ThemeData theme;
  final bool isSmallScreen;
  const DueStatsGrid({
    super.key,
    required this.stats,
    required this.theme,
    this.isSmallScreen = false,
  });
  @override
  Widget build(BuildContext context) {
    final colorScheme = theme.colorScheme;
    return GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: isSmallScreen ? 2 : 4,
      childAspectRatio: isSmallScreen ? 0.8 : 0.6,
      mainAxisSpacing: AppDimens.spaceS,
      crossAxisSpacing: AppDimens.spaceS,
      children: [
        StatGridItem(
          theme: theme,
          value: '${stats.dueToday}',
          label: 'Due\nToday',
          iconData: Icons.today,
          color: colorScheme.getStatColor('warning'),
          additionalInfo: '${stats.wordsDueToday} words',
        ),
        StatGridItem(
          theme: theme,
          value: '${stats.dueThisWeek}',
          label: 'Due\nThis Week',
          iconData: Icons.view_week,
          color: colorScheme.getStatColor('warningDark'),
          additionalInfo: '${stats.wordsDueThisWeek} words',
        ),
        StatGridItem(
          theme: theme,
          value: '${stats.dueThisMonth}',
          label: 'Due\nThis Month',
          iconData: Icons.calendar_month,
          color: colorScheme.getStatColor('primary'),
          additionalInfo: '${stats.wordsDueThisMonth} words',
        ),
        StatGridItem(
          theme: theme,
          value: '${stats.completedToday}',
          label: 'Completed\nToday',
          iconData: Icons.check_circle,
          color: colorScheme.getStatColor('successDark'),
          additionalInfo: '${stats.wordsCompletedToday} words',
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/learning_stats/vocabulary_stats_grid.dart
class VocabularyStatsGrid extends StatelessWidget {
  final LearningStatsDTO stats;
  final ThemeData theme;
  final bool isSmallScreen;
  const VocabularyStatsGrid({
    super.key,
    required this.stats,
    required this.theme,
    this.isSmallScreen = false,
  });
  @override
  Widget build(BuildContext context) {
    final colorScheme = theme.colorScheme;
    final completionRate = stats.vocabularyCompletionRate.toStringAsFixed(1);
    final weeklyRate = stats.weeklyNewWordsRate.toStringAsFixed(1);
    return GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: isSmallScreen ? 2 : 4,
      childAspectRatio: isSmallScreen ? 1.3 : 0.6,
      mainAxisSpacing: AppDimens.spaceS,
      crossAxisSpacing: AppDimens.spaceS,
      children: [
        StatGridItem(
          theme: theme,
          value: '${stats.totalWords}',
          label: 'Total\nWords',
          iconData: Icons.library_books,
          color: colorScheme.getStatColor('success'),
        ),
        StatGridItem(
          theme: theme,
          value: '${stats.learnedWords}',
          label: 'Learned\nWords',
          iconData: Icons.spellcheck,
          color: colorScheme.getStatColor('success'),
          additionalInfo: '$completionRate%',
        ),
        StatGridItem(
          theme: theme,
          value: '${stats.pendingWords}',
          label: 'Pending\nWords',
          iconData: Icons.hourglass_bottom,
          color: colorScheme.getStatColor('warningDark'),
        ),
        StatGridItem(
          theme: theme,
          value: weeklyRate,
          label: 'Weekly\nRate',
          iconData: Icons.trending_up,
          color: colorScheme.getStatColor('info'),
          additionalInfo: '%',
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/due_progress_login_prompt.dart
class DueProgressLoginPrompt extends StatelessWidget {
  const DueProgressLoginPrompt({super.key});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(title: const Text('Due Progress')),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 120,
                height: 120,
                decoration: BoxDecoration(
                  color: theme.colorScheme.surfaceContainerHighest,
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  Icons.lock_outline,
                  size: 64,
                  color: theme.colorScheme.primary.withValues(alpha: 0.5),
                ),
              ),
              const SizedBox(height: 24),
              Text(
                'Please sign in',
                style: theme.textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
              Text(
                'You need to be signed in to view your due progress',
                style: theme.textTheme.bodyLarge?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              FilledButton.icon(
                icon: const Icon(Icons.login),
                label: const Text('Sign in'),
                onPressed: () =>
                    NavigationHelper.clearStackAndGo(context, '/login'),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/cycle_completion_dialog.dart
class CycleCompletionDialog extends StatelessWidget {
  const CycleCompletionDialog({super.key});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return AlertDialog(
      title: Row(
        children: [
          Icon(Icons.celebration, color: colorScheme.tertiary),
          const SizedBox(width: AppDimens.spaceM),
          const Text('Learning Cycle Completed!'),
        ],
      ),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildInfoSection(
            icon: Icons.check_circle,
            text: 'You have completed all repetitions in this cycle.',
            colorScheme: colorScheme,
          ),
          const SizedBox(height: AppDimens.spaceL),
          _buildInfoSection(
            icon: Icons.schedule,
            text:
                'The system has automatically scheduled a new review cycle with adjusted intervals based on your learning performance.',
            colorScheme: colorScheme,
          ),
          const SizedBox(height: AppDimens.spaceL),
          _buildInfoSection(
            icon: Icons.auto_graph,
            text:
                'Keep up with regular reviews to maximize your learning efficiency.',
            colorScheme: colorScheme,
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Got it'),
        ),
      ],
    );
  }
  Widget _buildInfoSection({
    required IconData icon,
    required String text,
    required ColorScheme colorScheme,
  }) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, color: colorScheme.primary, size: AppDimens.iconM),
        const SizedBox(width: AppDimens.spaceM),
        Expanded(child: Text(text)),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/exceptions/app_exceptions.dart
abstract class AppException implements Exception {
  final String message;
  final String? prefix;
  final String? url;
  AppException(this.message, this.prefix, this.url);
  @override
  String toString() {
    return '$prefix$message';
  }
}
class AuthenticationException extends AppException {
  AuthenticationException([String? message, String? url])
    : super(message ?? 'Authentication failed', 'Authentication Error: ', url);
}
class BadRequestException extends AppException {
  final Map<String, dynamic>? errors;
  BadRequestException([String? message, String? url, this.errors])
    : super(message ?? 'Invalid request', 'Bad Request: ', url);
}
class DataFormatException extends AppException {
  DataFormatException([String? message, String? url])
    : super(message ?? 'Invalid data format', 'Data Format Error: ', url);
}
class ForbiddenException extends AppException {
  ForbiddenException([String? message, String? url])
    : super(message ?? 'Access denied', 'Forbidden: ', url);
}
class HttpException extends AppException {
  final int statusCode;
  HttpException(this.statusCode, [String? message, String? url])
    : super(
        message ?? 'Error occurred with status code: $statusCode',
        'HTTP Error: ',
        url,
      );
}
class NoInternetException extends AppException {
  NoInternetException([String? message])
    : super(message ?? 'No internet connection', 'Connection Error: ', null);
}
class NotFoundException extends AppException {
  NotFoundException([String? message, String? url])
    : super(message ?? 'Resource not found', 'Not Found: ', url);
}
class ServerException extends AppException {
  ServerException([String? message, String? url])
    : super(message ?? 'Server error occurred', 'Server Error: ', url);
}
class TimeoutException extends AppException {
  TimeoutException([String? message, String? url])
    : super(message ?? 'Operation timed out', 'Timeout: ', url);
}
class UnexpectedException extends AppException {
  UnexpectedException([String? message, String? url])
    : super(message ?? 'Unexpected error occurred', 'Unexpected Error: ', url);
}

// D:/workspace/spaced_learning_app/lib/domain/models/book.dart
enum BookStatus {
  @JsonValue('PUBLISHED')
  published,
  @JsonValue('DRAFT')
  draft,
  @JsonValue('ARCHIVED')
  archived,
}
enum DifficultyLevel {
  @JsonValue('BEGINNER')
  beginner,
  @JsonValue('INTERMEDIATE')
  intermediate,
  @JsonValue('ADVANCED')
  advanced,
  @JsonValue('EXPERT')
  expert,
}
@freezed
abstract class BookSummary with _$BookSummary {
  const factory BookSummary({
    required String id,
    required String name,
    required BookStatus status,
    DifficultyLevel? difficultyLevel,
    String? category,
    DateTime? createdAt,
    DateTime? updatedAt,
    @Default(0) int moduleCount,
  }) = _BookSummary;
  factory BookSummary.fromJson(Map<String, dynamic> json) =>
      _$BookSummaryFromJson(json);
}
@freezed
abstract class BookDetail with _$BookDetail {
  const factory BookDetail({
    required String id,
    required String name,
    String? description,
    required BookStatus status,
    DifficultyLevel? difficultyLevel,
    String? category,
    DateTime? createdAt,
    DateTime? updatedAt,
    @Default([]) List<ModuleDetail> modules,
  }) = _BookDetail;
  factory BookDetail.fromJson(Map<String, dynamic> json) =>
      _$BookDetailFromJson(json);
}
extension BookDetailMapper on BookDetail {
  BookSummary toSummary() {
    return BookSummary(
      id: id,
      name: name,
      status: status,
      difficultyLevel: difficultyLevel,
      category: category,
      createdAt: createdAt,
      updatedAt: updatedAt,
      moduleCount: modules.length,
    );
  }
}
extension BookSummaryMapper on BookSummary {
  BookDetail toDetail({List<ModuleDetail> modules = const []}) {
    return BookDetail(
      id: id,
      name: name,
      status: status,
      difficultyLevel: difficultyLevel,
      category: category,
      createdAt: createdAt,
      updatedAt: updatedAt,
      description: null, // Vì BookSummary không có description
      modules: modules,
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/modules/module_progress_section.dart
class ModuleProgressSection extends StatelessWidget {
  final ProgressDetail progress;
  final String moduleTitle;
  final void Function(String) onTap;
  const ModuleProgressSection({
    super.key,
    required this.progress,
    required this.moduleTitle,
    required this.onTap,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Your Progress', style: theme.textTheme.titleLarge),
        const SizedBox(height: AppDimens.spaceM),
        ProgressCard(
          progress: progress,
          subtitle: moduleTitle != progress.moduleTitle ? moduleTitle : null,
          isDue: _isDue(progress),
          onTap: () => onTap(progress.id),
        ),
        const SizedBox(height: AppDimens.spaceL),
        Center(
          child: SLButton(
            text: 'View Detailed Progress',
            type: SLButtonType.outline,
            prefixIcon: Icons.visibility,
            onPressed: () => onTap(progress.id),
          ),
        ),
      ],
    );
  }
  bool _isDue(ProgressDetail progress) {
    if (progress.nextStudyDate == null) return false;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final nextDate = DateTime(
      progress.nextStudyDate!.year,
      progress.nextStudyDate!.month,
      progress.nextStudyDate!.day,
    );
    return nextDate.compareTo(today) <= 0;
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/progress/due_progress_empty_state.dart
class DueProgressEmptyState extends StatelessWidget {
  final DateTime? selectedDate;
  final VoidCallback onRefresh;
  const DueProgressEmptyState({
    super.key,
    required this.selectedDate,
    required this.onRefresh,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 120,
              height: 120,
              decoration: BoxDecoration(
                color: colorScheme.surfaceContainerHighest,
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.check_circle_outline,
                size: 64,
                color: colorScheme.tertiary.withValues(alpha: 0.5),
              ),
            ),
            const SizedBox(height: 24),
            Text(
              selectedDate == null
                  ? 'No modules due for review today!'
                  : 'No modules due for review by ${AppDateUtils.formatDate(selectedDate!)}',
              style: theme.textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              'Great job keeping up with your studies!',
              style: theme.textTheme.bodyLarge?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            FilledButton.icon(
              icon: const Icon(Icons.refresh),
              label: const Text('Refresh'),
              onPressed: onRefresh,
            ),
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/utils/book_formatter.dart
class BookFormatter {
  static String formatStatus(BookStatus status) {
    switch (status) {
      case BookStatus.published:
        return 'Published';
      case BookStatus.draft:
        return 'Draft';
      case BookStatus.archived:
        return 'Archived';
    }
  }
  static String formatDifficulty(DifficultyLevel? difficulty) {
    if (difficulty == null) return 'Unknown';
    switch (difficulty) {
      case DifficultyLevel.beginner:
        return 'Beginner';
      case DifficultyLevel.intermediate:
        return 'Intermediate';
      case DifficultyLevel.advanced:
        return 'Advanced';
      case DifficultyLevel.expert:
        return 'Expert';
    }
  }
  static Color getStatusColor(BookStatus status, ColorScheme colorScheme) {
    switch (status) {
      case BookStatus.published:
        return colorScheme.success; // Định nghĩa trong color_extensions.dart
      case BookStatus.draft:
        return colorScheme.secondary;
      case BookStatus.archived:
        return colorScheme.onSurfaceVariant;
    }
  }
  static Color getDifficultyColor(
    DifficultyLevel? difficulty,
    ColorScheme colorScheme,
  ) {
    if (difficulty == null) return colorScheme.onSurfaceVariant;
    switch (difficulty) {
      case DifficultyLevel.beginner:
        return colorScheme.success; // Định nghĩa trong color_extensions.dart
      case DifficultyLevel.intermediate:
        return colorScheme.tertiary;
      case DifficultyLevel.advanced:
        return colorScheme.secondary;
      case DifficultyLevel.expert:
        return colorScheme.error;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/data/repositories/user_repository_impl.dart
class UserRepositoryImpl implements UserRepository {
  final ApiClient _apiClient;
  UserRepositoryImpl(this._apiClient);
  @override
  Future<User> getCurrentUser() async {
    try {
      final response = await _apiClient.get(ApiEndpoints.currentUser);
      if (response['success'] != true || response['data'] == null) {
        throw AuthenticationException(
          'Failed to get current user: ${response['message']}',
        );
      }
      return User.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get current user: $e');
    }
  }
  @override
  Future<User> updateUser(
    String id, {
    String? displayName,
    String? password,
  }) async {
    try {
      final data = <String, dynamic>{};
      if (displayName != null) {
        data['displayName'] = displayName;
      }
      if (password != null) {
        data['password'] = password;
      }
      final response = await _apiClient.put(
        '${ApiEndpoints.users}/$id',
        data: data,
      );
      if (response['success'] != true || response['data'] == null) {
        throw BadRequestException(
          'Failed to update user: ${response['message']}',
        );
      }
      return User.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to update user: $e');
    }
  }
  @override
  Future<bool> checkEmailExists(String email) async {
    try {
      return false;
    } catch (e) {
      return false;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/utils/repetition_utils.dart
class RepetitionUtils {
  static Map<String, List<Repetition>> groupByCycle(
    List<Repetition> repetitions,
  ) {
    final groupedByCycle = <String, List<Repetition>>{};
    final sortedRepetitions = List<Repetition>.from(repetitions)
      ..sort((a, b) {
        if (a.createdAt == null && b.createdAt == null) return 0;
        if (a.createdAt == null) return 1;
        if (b.createdAt == null) return -1;
        return a.createdAt!.compareTo(b.createdAt!);
      });
    int cycleIndex = 1;
    int currentGroupCount = 0;
    String currentKey = '';
    int repIndex = 0;
    while (repIndex < sortedRepetitions.length) {
      final rep = sortedRepetitions[repIndex];
      if (currentGroupCount < 5) {
        if (currentGroupCount == 0) {
          currentKey = 'Cycle $cycleIndex';
          groupedByCycle[currentKey] = [];
        }
        groupedByCycle[currentKey]!.add(rep);
        currentGroupCount++;
        repIndex++;
      } else {
        cycleIndex++;
        currentGroupCount = 0;
      }
    }
    for (final key in groupedByCycle.keys) {
      groupedByCycle[key]!.sort(
        (a, b) => a.repetitionOrder.index.compareTo(b.repetitionOrder.index),
      );
    }
    return groupedByCycle;
  }
  static bool isCurrentCycle(
    List<Repetition> repetitions,
    CycleStudied currentCycleStudied,
  ) {
    if (repetitions.isEmpty) return false;
    return repetitions.any((r) => r.status == RepetitionStatus.notStarted) &&
        currentCycleStudied != CycleStudied.firstTime;
  }
  static int compareReviewDates(Repetition a, Repetition b) {
    if (a.reviewDate == null && b.reviewDate == null) {
      return a.repetitionOrder.index.compareTo(b.repetitionOrder.index);
    }
    if (a.reviewDate == null) return 1;
    if (b.reviewDate == null) return -1;
    return b.reviewDate!.compareTo(a.reviewDate!);
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/profile/profile_header.dart
class ProfileHeader extends StatelessWidget {
  final User user;
  const ProfileHeader({super.key, required this.user});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Column(
      children: [
        Container(
          width: 120,
          height: 120,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            gradient: LinearGradient(
              colors: [colorScheme.primary, colorScheme.tertiary],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            boxShadow: [
              BoxShadow(
                color: colorScheme.primary.withValues(alpha: 0.4),
                blurRadius: 20,
                offset: const Offset(0, 8),
              ),
            ],
          ),
          child: Center(
            child: Text(
              user.initials,
              style: theme.textTheme.displayMedium?.copyWith(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ),
        const SizedBox(height: AppDimens.spaceL),
        Text(
          user.displayName ?? user.email.split('@').first,
          style: theme.textTheme.headlineSmall?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: AppDimens.spaceXS),
        Text(
          user.email,
          style: theme.textTheme.titleMedium?.copyWith(
            color: colorScheme.onSurface.withValues(alpha: 0.7),
          ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/profile/login_prompt.dart
class ProfileLoginPrompt extends StatelessWidget {
  const ProfileLoginPrompt({super.key});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Card(
        elevation: 4,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        margin: const EdgeInsets.all(AppDimens.paddingL),
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingXL),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                Icons.account_circle,
                size: 80,
                color: theme.colorScheme.primary.withValues(alpha: 0.6),
              ),
              const SizedBox(height: AppDimens.spaceL),
              Text('Please log in', style: theme.textTheme.titleLarge),
              const SizedBox(height: AppDimens.spaceM),
              Text(
                'You need to be logged in to view your profile',
                textAlign: TextAlign.center,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withValues(alpha: 0.7),
                ),
              ),
              const SizedBox(height: AppDimens.spaceXL),
              SLButton(
                text: 'Log In',
                type: SLButtonType.primary,
                prefixIcon: Icons.login,
                isFullWidth: true,
                onPressed: () =>
                    NavigationHelper.clearStackAndGo(context, '/login'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/base_viewmodel.dart
abstract class BaseAsyncNotifier<T> extends AsyncNotifier<T> {
  DateTime? lastUpdated;
  bool _isRefreshing = false;
  @override
  Future<T> build(); // Để lớp con bắt buộc override
  Future<void> refresh() async {
    if (_isRefreshing) return;
    _isRefreshing = true;
    state = const AsyncValue.loading();
    try {
      final result = await build();
      lastUpdated = DateTime.now();
      state = AsyncValue.data(result);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
    } finally {
      _isRefreshing = false;
    }
  }
  Future<R> executeTask<R>(
    Future<R> Function() task, {
    bool updateOnSuccess = true,
    bool handleLoading = true,
  }) async {
    if (handleLoading) {
      state = const AsyncValue.loading();
    }
    try {
      final result = await task();
      if (updateOnSuccess) {
        lastUpdated = DateTime.now();
        await refresh();
      }
      return result;
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
      rethrow;
    }
  }
  bool shouldRefresh({Duration threshold = const Duration(minutes: 5)}) {
    if (lastUpdated == null) return true;
    final now = DateTime.now();
    return now.difference(lastUpdated!) > threshold;
  }
}
mixin ErrorHandling {
  String? errorMessage;
  void setError(String? message) {
    errorMessage = message;
    debugPrint('${runtimeType.toString()}: setError($message)');
  }
  void clearError() {
    errorMessage = null;
    debugPrint('${runtimeType.toString()}: clearError()');
  }
  void handleError(dynamic error, {String prefix = 'An error occurred'}) {
    final message = error is Exception
        ? '$prefix: ${error.toString()}'
        : '$prefix: ${error.toString()}';
    debugPrint('Error in ${runtimeType.toString()}: $message');
    setError(message);
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/user_viewmodel.dart
@riverpod
class UserState extends _$UserState {
  @override
  Future<User?> build() async {
    return loadCurrentUser();
  }
  Future<User?> loadCurrentUser() async {
    state = const AsyncValue.loading();
    try {
      final user = await ref.read(userRepositoryProvider).getCurrentUser();
      state = AsyncValue.data(user);
      return user;
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
      return null;
    }
  }
  Future<bool> updateProfile({String? displayName, String? password}) async {
    if (state.value == null) {
      state = AsyncValue.error('User is not loaded', StackTrace.current);
      return false;
    }
    state = const AsyncValue.loading();
    try {
      final result = await ref
          .read(userRepositoryProvider)
          .updateUser(
            state.value!.id,
            displayName: displayName,
            password: password,
          );
      state = AsyncValue.data(result);
      return true;
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
      return false;
    }
  }
  void clearError() {
    if (state.hasError) {
      state = const AsyncValue.loading();
      loadCurrentUser();
    }
  }
}
@riverpod
class UserError extends _$UserError {
  @override
  String? build() {
    final userState = ref.watch(userStateProvider);
    return userState.hasError ? userState.error.toString() : null;
  }
  void clearError() {
    state = null;
  }
}

// D:/workspace/spaced_learning_app/.dart_tool/build/entrypoint/build.dart
final _builders = <_i1.BuilderApplication>[
  _i1.apply(
    r'riverpod_generator:riverpod_generator',
    [_i2.riverpodBuilder],
    _i1.toDependentsOf(r'riverpod_generator'),
    hideOutput: true,
    appliesBuilders: const [r'source_gen:combining_builder'],
  ),
  _i1.apply(
    r'freezed:freezed',
    [_i3.freezed],
    _i1.toDependentsOf(r'freezed'),
    hideOutput: false,
  ),
  _i1.apply(
    r'json_serializable:json_serializable',
    [_i4.jsonSerializable],
    _i1.toDependentsOf(r'json_serializable'),
    hideOutput: true,
    appliesBuilders: const [r'source_gen:combining_builder'],
  ),
  _i1.apply(
    r'source_gen:combining_builder',
    [_i5.combiningBuilder],
    _i1.toNoneByDefault(),
    hideOutput: false,
    appliesBuilders: const [r'source_gen:part_cleanup'],
  ),
  _i1.apply(
    r'build_resolvers:transitive_digests',
    [_i6.transitiveDigestsBuilder],
    _i1.toAllPackages(),
    isOptional: true,
    hideOutput: true,
    appliesBuilders: const [r'build_resolvers:transitive_digest_cleanup'],
  ),
  _i1.applyPostProcess(
    r'build_resolvers:transitive_digest_cleanup',
    _i6.transitiveDigestCleanup,
  ),
  _i1.applyPostProcess(
    r'source_gen:part_cleanup',
    _i5.partCleanup,
  ),
];
void main(
  List<String> args, [
  _i7.SendPort? sendPort,
]) async {
  var result = await _i8.run(
    args,
    _builders,
  );
  sendPort?.send(result);
  _i9.exitCode = result;
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/main/learning_app_bar.dart
class LearningAppBar extends ConsumerWidget {
  final bool isScrolled;
  final VoidCallback onRefresh;
  final VoidCallback onHelp;
  const LearningAppBar({
    super.key,
    required this.isScrolled,
    required this.onRefresh,
    required this.onHelp,
  });
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final colorScheme = Theme.of(context).colorScheme;
    return SliverAppBar(
      title: const Text('Learning Progress'),
      pinned: true,
      floating: true,
      elevation: isScrolled ? AppDimens.elevationS : 0,
      shadowColor: Colors.black.withValues(alpha: AppDimens.opacityLight),
      backgroundColor: isScrolled
          ? colorScheme.surface
          : colorScheme.surface.withValues(alpha: AppDimens.opacityVeryHigh),
      foregroundColor: colorScheme.onSurface,
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        onPressed: () {
          final router = GoRouter.of(context);
          if (router.canPop()) {
            router.pop();
            return;
          }
          router.go('/');
        },
        tooltip: 'Back',
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.refresh),
          iconSize: AppDimens.iconL,
          tooltip: 'Refresh data',
          padding: const EdgeInsets.all(AppDimens.paddingS),
          onPressed: onRefresh,
        ),
        IconButton(
          icon: const Icon(Icons.help_outline),
          iconSize: AppDimens.iconL,
          tooltip: 'Help',
          padding: const EdgeInsets.all(AppDimens.paddingS),
          onPressed: onHelp,
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/domain/models/repetition.dart
enum RepetitionOrder {
  @JsonValue('FIRST_REPETITION')
  firstRepetition,
  @JsonValue('SECOND_REPETITION')
  secondRepetition,
  @JsonValue('THIRD_REPETITION')
  thirdRepetition,
  @JsonValue('FOURTH_REPETITION')
  fourthRepetition,
  @JsonValue('FIFTH_REPETITION')
  fifthRepetition,
}
enum RepetitionStatus {
  @JsonValue('NOT_STARTED')
  notStarted,
  @JsonValue('COMPLETED')
  completed,
  @JsonValue('SKIPPED')
  skipped,
}
@freezed
abstract class Repetition with _$Repetition {
  const factory Repetition({
    required String id,
    required String moduleProgressId,
    required RepetitionOrder repetitionOrder,
    @Default(RepetitionStatus.notStarted) RepetitionStatus status,
    DateTime? reviewDate,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _Repetition;
  factory Repetition.fromJson(Map<String, dynamic> json) =>
      _$RepetitionFromJson(json);
}
extension RepetitionExtensions on Repetition {
  String formatOrder() {
    switch (repetitionOrder) {
      case RepetitionOrder.firstRepetition:
        return '1';
      case RepetitionOrder.secondRepetition:
        return '2';
      case RepetitionOrder.thirdRepetition:
        return '3';
      case RepetitionOrder.fourthRepetition:
        return '4';
      case RepetitionOrder.fifthRepetition:
        return '5';
    }
  }
  String formatFullOrder() {
    switch (repetitionOrder) {
      case RepetitionOrder.firstRepetition:
        return 'Repetition 1';
      case RepetitionOrder.secondRepetition:
        return 'Repetition 2';
      case RepetitionOrder.thirdRepetition:
        return 'Repetition 3';
      case RepetitionOrder.fourthRepetition:
        return 'Repetition 4';
      case RepetitionOrder.fifthRepetition:
        return 'Repetition 5';
    }
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/report/log_entry_widget.dart
class LogEntryWidget extends StatelessWidget {
  final LogEntry log;
  final DateFormat dateFormat;
  const LogEntryWidget({
    super.key,
    required this.log,
    required this.dateFormat,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              log.isSuccess ? Icons.check_circle : Icons.error,
              size: AppDimens.iconS,
              color: log.isSuccess ? colorScheme.primary : colorScheme.error,
            ),
            const SizedBox(width: AppDimens.spaceXS),
            Text(
              AppDateUtils.formatDate(
                log.timestamp,
                format: 'dd/MM/yyyy HH:mm:ss',
              ),
              style: theme.textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
        const SizedBox(height: AppDimens.spaceXS),
        Text(log.message, style: theme.textTheme.bodyMedium),
        if (log.detail != null) ...[
          const SizedBox(height: AppDimens.spaceXS),
          Text(
            log.detail!,
            style: theme.textTheme.bodySmall?.copyWith(
              color: log.isSuccess
                  ? colorScheme.onSurfaceVariant
                  : colorScheme.error,
            ),
          ),
        ],
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/home/widgets/home_error.dart
class HomeError extends StatelessWidget {
  final String? errorMessage;
  final VoidCallback onRetry;
  const HomeError({
    super.key,
    required this.errorMessage,
    required this.onRetry,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingXL),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: AppDimens.iconXXL,
              color: colorScheme.error,
            ),
            const SizedBox(height: AppDimens.spaceL),
            Text(
              'Failed to load data',
              style: theme.textTheme.titleLarge?.copyWith(
                color: colorScheme.onSurface,
              ),
              textAlign: TextAlign.center,
            ),
            if (errorMessage != null) ...[
              const SizedBox(height: AppDimens.spaceM),
              Text(
                'Error: $errorMessage',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
            ],
            const SizedBox(height: AppDimens.spaceXL),
            SLButton(
              text: 'Try Again',
              type: SLButtonType.primary,
              prefixIcon: Icons.refresh,
              onPressed: onRetry,
            ),
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/learning/main/module_list_header.dart
class ModuleListHeader extends ConsumerWidget {
  const ModuleListHeader({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Container(
      margin: const EdgeInsets.only(
        bottom: AppDimens.spaceS,
        top: AppDimens.spaceL,
      ),
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingL,
        vertical: AppDimens.paddingM,
      ),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
      ),
      child: Row(
        children: [
          Expanded(
            flex: 7,
            child: Text(
              'Module',
              style: theme.textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: colorScheme.primary,
              ),
            ),
          ),
          Expanded(
            flex: 4,
            child: Text(
              'Next Study',
              style: theme.textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: colorScheme.primary,
              ),
            ),
          ),
          Expanded(
            flex: 2,
            child: Text(
              'Tasks',
              style: theme.textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: colorScheme.primary,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/constants/app_constants.dart
class AppConstants {
  static const String baseUrl =
      'http://192.168.1.12:8088'; // Local
  static const String apiPrefix = '/api/v1';
  static const int connectTimeout = 15000; // milliseconds
  static const int receiveTimeout = 15000; // milliseconds
  static const String tokenKey = 'auth_token';
  static const String refreshTokenKey = 'refresh_token';
  static const String userKey = 'user_data';
  static const String darkModeKey = 'dark_mode';
  static const String appName = 'Spaced Learning';
  static const Duration quickDuration = Duration(milliseconds: 200);
  static const Duration mediumDuration = Duration(milliseconds: 350);
  static const Duration longDuration = Duration(milliseconds: 500);
  static const int noonReminderHour = 12;
  static const int noonReminderMinute = 30;
  static const int eveningFirstReminderHour = 21;
  static const int eveningFirstReminderMinute = 0;
  static const int eveningSecondReminderHour = 22;
  static const int eveningSecondReminderMinute = 30;
  static const int endOfDayReminderHour = 23;
  static const int endOfDayReminderMinute = 30;
  static const int noonReminderCallbackId = 1001;
  static const int eveningFirstReminderCallbackId = 1002;
  static const int eveningSecondReminderCallbackId = 1003;
  static const int endOfDayReminderCallbackId = 1004;
}

// D:/workspace/spaced_learning_app/lib/data/repositories/learning_stats_repository_impl.dart
class LearningStatsRepositoryImpl implements LearningStatsRepository {
  final ApiClient _apiClient;
  LearningStatsRepositoryImpl(this._apiClient);
  @override
  Future<LearningStatsDTO> getDashboardStats({
    bool refreshCache = false,
  }) async {
    try {
      final response = await _apiClient.get(
        ApiEndpoints.dashboardStats,
        queryParameters: {'refreshCache': refreshCache},
      );
      if (response['success'] != true || response['data'] == null) {
        throw BadRequestException(
          'Failed to get dashboard stats: ${response['message']}',
        );
      }
      return LearningStatsDTO.fromJson(response['data']);
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get dashboard stats: $e');
    }
  }
  @override
  Future<List<LearningInsightRespone>> getLearningInsights() async {
    try {
      final response = await _apiClient.get(ApiEndpoints.learningInsights);
      if (response['success'] != true || response['data'] == null) {
        return [];
      }
      final List<dynamic> insightsList = response['data'];
      return insightsList
          .map((item) => LearningInsightRespone.fromJson(item))
          .toList();
    } on AppException {
      rethrow;
    } catch (e) {
      throw UnexpectedException('Failed to get learning insights: $e');
    }
  }
}

// D:/workspace/spaced_learning_app/lib/core/navigation/go_router_extensions.dart
extension GoRouterExtensions on GoRouter {
  void goAndRemoveUntil(
    String location,
    bool Function(Route<dynamic>) predicate,
  ) {
    while (canPop()) {
      pop();
    }
    go(location);
  }
  Future<T?> pushWithAnimation<T>(
    BuildContext context,
    String location, {
    Object? extra,
    Duration duration = const Duration(milliseconds: 300),
    Widget Function(BuildContext, Animation<double>, Animation<double>, Widget)?
    transition,
  }) {
    transition ??= (context, animation, secondaryAnimation, child) =>
        SlideTransition(
          position: Tween<Offset>(
            begin: const Offset(1.0, 0.0),
            end: Offset.zero,
          ).animate(animation),
          child: child,
        );
    return push<T>(location, extra: extra);
  }
  void popAllAndPush(String location, {Object? extra}) {
    while (canPop()) {
      pop();
    }
    push(location, extra: extra);
  }
  bool isCurrentRoute(String routeName) {
    final currentLocation = routeInformationProvider.value.uri.toString();
    return currentLocation == routeName ||
        currentLocation.startsWith('$routeName/');
  }
}

// D:/workspace/spaced_learning_app/lib/core/utils/date_utils.dart
class AppDateUtils {
  static bool isSameDay(DateTime date1, DateTime date2) {
    return date1.year == date2.year &&
        date1.month == date2.month &&
        date1.day == date2.day;
  }
  static String formatDate(DateTime date, {String format = 'MMM dd, yyyy'}) {
    return DateFormat(format).format(date);
  }
  static DateTime startOfDay(DateTime date) {
    return DateTime(date.year, date.month, date.day);
  }
  static DateTime startOfWeek(DateTime date) {
    final weekday = date.weekday;
    return DateTime(date.year, date.month, date.day - (weekday - 1));
  }
  static DateTime startOfMonth(DateTime date) {
    return DateTime(date.year, date.month, 1);
  }
  static DateTime endOfMonth(DateTime date) {
    return (date.month < 12)
        ? DateTime(date.year, date.month + 1, 0)
        : DateTime(date.year + 1, 1, 0);
  }
  static bool isPast(DateTime date) {
    final now = DateTime.now();
    return date.isBefore(startOfDay(now));
  }
  static bool isToday(DateTime date) {
    return isSameDay(date, DateTime.now());
  }
  static bool isThisWeek(DateTime date) {
    final now = DateTime.now();
    final startWeek = startOfWeek(now);
    final endWeek = startWeek.add(const Duration(days: 6));
    return !date.isBefore(startWeek) && !date.isAfter(endWeek);
  }
  static bool isThisMonth(DateTime date) {
    final now = DateTime.now();
    return date.year == now.year && date.month == now.month;
  }
  static int daysBetween(DateTime from, DateTime to) {
    from = startOfDay(from);
    to = startOfDay(to);
    return to.difference(from).inDays;
  }
}

// D:/workspace/spaced_learning_app/lib/core/navigation/route_constants.dart
class RouteConstants {
  static const String home = '/';
  static const String login = '/login';
  static const String register = '/register';
  static const String forgotPassword = '/forgot-password';
  static const String books = '/books';
  static const String bookDetail = '/books/:id';
  static const String moduleDetail = '/books/:id/modules/:moduleId';
  static const String learning = '/learning';
  static const String learningProgress = '/learning/progress/:id';
  static const String learningModule = '/learning/modules/:id';
  static const String profile = '/profile';
  static const String dueProgress = '/due-progress';
  static const String reminderSettings = '/settings/reminders';
  static const String help = '/help';
  static const String spacedRepetition = '/help/spaced-repetition';
  static const String taskReport = '/task-report';
  static const String progressDetail = '/progress/:id';
  static String bookDetailRoute(String bookId) => '/books/$bookId';
  static String moduleDetailRoute(String bookId, String moduleId) =>
      '/books/$bookId/modules/$moduleId';
  static String progressDetailRoute(String progressId) =>
      '/progress/$progressId';
  static String learningProgressRoute(String progressId) =>
      '/learning/progress/$progressId';
  static String learningModuleRoute(String moduleId) =>
      '/learning/modules/$moduleId';
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/common/app_bar_with_back.dart
class AppBarWithBack extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final List<Widget>? actions;
  final Color? backgroundColor;
  final Color? foregroundColor;
  final bool canPop;
  final String? fallbackRoute;
  final VoidCallback? onBackPressed;
  final bool implyLeading;
  final Widget? titleWidget;
  final bool centerTitle;
  const AppBarWithBack({
    super.key,
    this.title = '',
    this.actions,
    this.backgroundColor,
    this.foregroundColor,
    this.canPop = true,
    this.fallbackRoute,
    this.onBackPressed,
    this.implyLeading = true,
    this.titleWidget,
    this.centerTitle = true,
  });
  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: titleWidget ?? Text(title),
      actions: actions,
      backgroundColor: backgroundColor,
      foregroundColor: foregroundColor,
      automaticallyImplyLeading: implyLeading,
      centerTitle: centerTitle,
      leading: canPop && implyLeading
          ? IconButton(
              icon: const Icon(Icons.arrow_back),
              onPressed: onBackPressed ?? () => _handleBack(context),
            )
          : null,
    );
  }
  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
  void _handleBack(BuildContext context) {
    final router = GoRouter.of(context);
    if (router.canPop()) {
      router.pop();
    } else if (fallbackRoute != null) {
      router.go(fallbackRoute!);
    }
  }
}

// D:/workspace/spaced_learning_app/lib/domain/models/learning_stats.dart
@freezed
abstract class LearningStatsDTO with _$LearningStatsDTO {
  const factory LearningStatsDTO({
    @Default(0) int totalModules,
    @Default({
      'FIRST_TIME': 0,
      'FIRST_REVIEW': 0,
      'SECOND_REVIEW': 0,
      'THIRD_REVIEW': 0,
      'MORE_THAN_THREE_REVIEWS': 0,
    })
    Map<String, int> cycleStats,
    @Default(0) int dueToday,
    @Default(0) int dueThisWeek,
    @Default(0) int dueThisMonth,
    @Default(0) int wordsDueToday,
    @Default(0) int wordsDueThisWeek,
    @Default(0) int wordsDueThisMonth,
    @Default(0) int completedToday,
    @Default(0) int completedThisWeek,
    @Default(0) int completedThisMonth,
    @Default(0) int wordsCompletedToday,
    @Default(0) int wordsCompletedThisWeek,
    @Default(0) int wordsCompletedThisMonth,
    @Default(0) int streakDays,
    @Default(0) int streakWeeks,
    @Default(0) int longestStreakDays,
    @Default(0) int totalWords,
    @Default(0) int totalCompletedModules,
    @Default(0) int totalInProgressModules,
    @Default(0) int learnedWords,
    @Default(0) int pendingWords,
    @Default(0.0) double vocabularyCompletionRate,
    @Default(0.0) double weeklyNewWordsRate,
    @Default([]) List<LearningInsightRespone> learningInsights,
    DateTime? lastUpdated,
  }) = _LearningStatsDTO;
  factory LearningStatsDTO.fromJson(Map<String, dynamic> json) =>
      _$LearningStatsDTOFromJson(json);
}

// D:/workspace/spaced_learning_app/lib/domain/models/progress.dart
enum CycleStudied {
  @JsonValue('FIRST_TIME')
  firstTime,
  @JsonValue('FIRST_REVIEW')
  firstReview,
  @JsonValue('SECOND_REVIEW')
  secondReview,
  @JsonValue('THIRD_REVIEW')
  thirdReview,
  @JsonValue('MORE_THAN_THREE_REVIEWS')
  moreThanThreeReviews,
}
@freezed
abstract class ProgressSummary with _$ProgressSummary {
  const factory ProgressSummary({
    required String id,
    required String moduleId,
    DateTime? firstLearningDate,
    @Default(CycleStudied.firstTime) CycleStudied cyclesStudied,
    DateTime? nextStudyDate,
    @Default(0) double percentComplete,
    DateTime? createdAt,
    DateTime? updatedAt,
    @Default(0) int repetitionCount,
  }) = _ProgressSummary;
  factory ProgressSummary.fromJson(Map<String, dynamic> json) =>
      _$ProgressSummaryFromJson(json);
}
@freezed
abstract class ProgressDetail with _$ProgressDetail {
  const factory ProgressDetail({
    required String id,
    required String moduleId,
    String? moduleTitle,
    String? userName,
    DateTime? firstLearningDate,
    @Default(CycleStudied.firstTime) CycleStudied cyclesStudied,
    DateTime? nextStudyDate,
    @Default(0) double percentComplete,
    DateTime? createdAt,
    DateTime? updatedAt,
    @Default([]) List<Repetition> repetitions,
  }) = _ProgressDetail;
  factory ProgressDetail.fromJson(Map<String, dynamic> json) =>
      _$ProgressDetailFromJson(json);
}

// D:/workspace/spaced_learning_app/lib/core/navigation/navigation_helper.dart
class NavigationHelper {
  static void popToRoot(BuildContext context) {
    final router = GoRouter.of(context);
    while (router.canPop()) {
      router.pop();
    }
  }
  static void clearStackAndGo(BuildContext context, String route) {
    popToRoot(context);
    GoRouter.of(context).go(route);
  }
  static void safeNavigate(
    BuildContext context,
    String route, {
    String? id,
    Object? extra,
  }) {
    if (id == null || id.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Invalid ID for navigation')),
      );
      return;
    }
    final formattedRoute = route.endsWith('/') ? '$route$id' : '$route/$id';
    GoRouter.of(context).go(formattedRoute, extra: extra);
  }
  static Future<T?> pushWithResult<T>(BuildContext context, String route) {
    return GoRouter.of(context).push<T>(route);
  }
  static void logout(BuildContext context) {
    clearStackAndGo(context, '/login');
  }
  static void loginSuccess(BuildContext context) {
    clearStackAndGo(context, '/');
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/metadata_item.dart
class MetadataItemWidget extends StatelessWidget {
  final String label;
  final String value;
  final IconData icon;
  const MetadataItemWidget({
    super.key,
    required this.label,
    required this.value,
    required this.icon,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: AppDimens.spaceXS),
      child: Row(
        children: [
          Icon(
            icon,
            size: AppDimens.iconS,
            color: colorScheme.primary.withValues(
              alpha: AppDimens.opacityVeryHigh,
            ),
          ),
          const SizedBox(width: AppDimens.spaceM),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: colorScheme.onSurfaceVariant,
                  ),
                ),
                Text(
                  value,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    color: colorScheme.onSurface,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/screens/home/widgets/home_header.dart
class HomeHeader extends StatelessWidget {
  final User user;
  const HomeHeader({super.key, required this.user});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Text(
          'Welcome back,',
          style: theme.textTheme.bodyLarge?.copyWith(
            color: colorScheme.onSurface.withValues(
              alpha: AppDimens.opacityHigh,
            ),
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: AppDimens.spaceXS),
        Text(
          user.displayName ?? user.email,
          style: theme.textTheme.headlineSmall?.copyWith(
            fontWeight: FontWeight.bold,
            color: colorScheme.primary,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: AppDimens.spaceS),
        Text(
          'Ready to continue your learning journey?',
          style: theme.textTheme.bodyMedium?.copyWith(
            fontStyle: FontStyle.italic,
            color: colorScheme.onSurface.withValues(
              alpha: AppDimens.opacityHigh,
            ),
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/main.dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  final prefs = await SharedPreferences.getInstance();
  final isCheckerActive = prefs.getBool('daily_task_checker_active') ?? false;
  final container = ProviderContainer();
  await container.read(authStateProvider.future);
  if (isCheckerActive) {
    await container.read(dailyTaskCheckerProvider.future);
  }
  runApp(UncontrolledProviderScope(container: container, child: const MyApp()));
}
class MyApp extends ConsumerWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(themeModeStateProvider);
    final router = ref.watch(routerProvider);
    return MaterialApp.router(
      title: 'Spaced Learning App',
      theme: ref.watch(lightThemeProvider),
      darkTheme: ref.watch(darkThemeProvider),
      themeMode: themeMode,
      routerConfig: router,
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/insights/learning_insights_section.dart
class LearningInsightsSection extends ConsumerWidget {
  const LearningInsightsSection({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final insightsAsync = ref.watch(learningInsightsProvider);
    final statsAsync = ref.watch(learningStatsStateProvider);
    final theme = Theme.of(context);
    return insightsAsync.when(
      data: (insights) {
        if (insights.isEmpty) return const SizedBox.shrink();
        final stats = statsAsync.valueOrNull;
        final vocabularyRate = stats?.weeklyNewWordsRate ?? 0.0;
        final streakDays = stats?.streakDays ?? 0;
        final pendingWords = stats?.pendingWords ?? 0;
        final dueToday = stats?.dueToday ?? 0;
        return LearningInsightsWidget(
          vocabularyRate: vocabularyRate,
          streakDays: streakDays,
          pendingWords: pendingWords,
          dueToday: dueToday,
          theme: theme,
        );
      },
      loading: () => const SizedBox.shrink(),
      error: (_, __) => const SizedBox.shrink(),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/report/info_row_widget.dart
class InfoRowWidget extends StatelessWidget {
  final String label;
  final String value;
  final IconData icon;
  final Color? valueColor;
  const InfoRowWidget({
    super.key,
    required this.label,
    required this.value,
    required this.icon,
    this.valueColor,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, size: AppDimens.iconM, color: colorScheme.primary),
        const SizedBox(width: AppDimens.spaceM),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(height: AppDimens.spaceXS),
              Text(
                value,
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: valueColor,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/theme_viewmodel.dart
@riverpod
class ThemeState extends _$ThemeState {
  @override
  ThemeMode build() {
    _loadThemePreference();
    return ThemeMode.system;
  }
  Future<void> _loadThemePreference() async {
    try {
      final isDarkMode = await ref.read(storageServiceProvider).isDarkMode();
      state = isDarkMode ? ThemeMode.dark : ThemeMode.light;
    } catch (e) {
      state = ThemeMode.light;
    }
  }
  Future<void> toggleTheme() async {
    final newIsDarkMode = state != ThemeMode.dark;
    try {
      await ref.read(storageServiceProvider).saveDarkMode(newIsDarkMode);
      state = newIsDarkMode ? ThemeMode.dark : ThemeMode.light;
    } catch (e) {
    }
  }
  Future<void> setDarkMode(bool isDarkMode) async {
    if ((state == ThemeMode.dark) == isDarkMode) return;
    try {
      await ref.read(storageServiceProvider).saveDarkMode(isDarkMode);
      state = isDarkMode ? ThemeMode.dark : ThemeMode.light;
    } catch (e) {
    }
  }
}
@riverpod
bool isDarkMode(Ref ref) {
  final themeMode = ref.watch(themeStateProvider);
  return themeMode == ThemeMode.dark;
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/info_chip.dart
class InfoChipWidget extends StatelessWidget {
  final String label;
  final Color backgroundColor;
  final Color textColor;
  final IconData? icon;
  const InfoChipWidget({
    super.key,
    required this.label,
    required this.backgroundColor,
    required this.textColor,
    this.icon,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimens.paddingXS,
        vertical: AppDimens.paddingXXS,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(AppDimens.radiusS),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (icon != null) ...[
            Icon(icon, size: AppDimens.iconXS, color: textColor),
            const SizedBox(width: AppDimens.spaceXXS),
          ],
          Flexible(
            child: Text(
              label,
              style: theme.textTheme.labelSmall?.copyWith(
                color: textColor,
                fontWeight: FontWeight.bold,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/viewmodels/module_viewmodel.dart
@riverpod
class ModulesState extends _$ModulesState {
  @override
  Future<List<ModuleSummary>> build() async {
    return [];
  }
  Future<void> loadModulesByBookId(
    String bookId, {
    int page = 0,
    int size = 20,
  }) async {
    if (bookId.isEmpty) {
      state = AsyncValue.error('Book ID cannot be empty', StackTrace.current);
      return;
    }
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final modules = await ref
          .read(moduleRepositoryProvider)
          .getModulesByBookId(bookId, page: page, size: size);
      return modules;
    });
  }
}
@riverpod
class SelectedModule extends _$SelectedModule {
  @override
  Future<ModuleDetail?> build() async => null;
  Future<void> loadModuleDetails(String id) async {
    if (id.isEmpty) {
      state = AsyncValue.error('Module ID cannot be empty', StackTrace.current);
      return;
    }
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final module = await ref.read(moduleRepositoryProvider).getModuleById(id);
      return module;
    });
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/stat_item.dart
class StatItemWidget extends StatelessWidget {
  final String value;
  final String label;
  final IconData icon;
  final Color color;
  const StatItemWidget({
    super.key,
    required this.value,
    required this.label,
    required this.icon,
    required this.color,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          padding: const EdgeInsets.all(AppDimens.paddingS),
          decoration: BoxDecoration(
            color: color.withValues(alpha: AppDimens.opacityLight),
            shape: BoxShape.circle,
          ),
          child: Icon(icon, color: color, size: AppDimens.iconM),
        ),
        const SizedBox(height: AppDimens.spaceS),
        Text(
          value,
          style: theme.textTheme.bodyLarge?.copyWith(
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
        Text(
          label,
          style: theme.textTheme.bodySmall?.copyWith(
            color: colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/home/insights/insight_item.dart
class InsightItem extends StatelessWidget {
  final String message;
  final IconData icon;
  final String colorType;
  final ThemeData theme;
  final ColorScheme colorScheme;
  const InsightItem({
    super.key,
    required this.message,
    required this.icon,
    required this.colorType,
    required this.theme,
    required this.colorScheme,
  });
  @override
  Widget build(BuildContext context) {
    final color = colorScheme.getStatColor(colorType);
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: AppDimens.paddingM),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(icon, size: AppDimens.iconM, color: color),
          const SizedBox(width: AppDimens.spaceM),
          Expanded(
            child: Text(
              message,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/core/utils/string_utils.dart
class StringUtils {
  static String? sanitizeId(String id, {String? source}) {
    if (id.isEmpty) {
      final sourceInfo = source != null ? ' in $source' : '';
      debugPrint('WARNING: Empty ID detected$sourceInfo');
      return null;
    }
    final sanitizedId = id.trim();
    if (sanitizedId != id) {
      final sourceInfo = source != null ? ' in $source' : '';
      debugPrint('ID sanitized from "$id" to "$sanitizedId"$sourceInfo');
    }
    return sanitizedId;
  }
  static bool isValidEmail(String email) {
    return RegExp(r'^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }
  static String getInitials(String text, {int maxInitials = 2}) {
    if (text.isEmpty) return '';
    final parts = text.trim().split(' ');
    if (parts.length >= maxInitials) {
      return (parts.first[0] + parts.last[0]).toUpperCase();
    }
    return text.isNotEmpty ? text[0].toUpperCase() : '';
  }
}

// D:/workspace/spaced_learning_app/.dart_tool/dartpad/web_plugin_registrant.dart
void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  DeviceInfoPlusWebPlugin.registerWith(registrar);
  FirebaseCoreWeb.registerWith(registrar);
  FirebaseMessagingWeb.registerWith(registrar);
  FlutterNativeSplashWeb.registerWith(registrar);
  FlutterSecureStorageWeb.registerWith(registrar);
  FluttertoastWebPlugin.registerWith(registrar);
  WebPermissionHandler.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/books/filter_chip.dart
class FilterChipWidget extends StatelessWidget {
  final String label;
  final Color color;
  final VoidCallback onDeleted;
  const FilterChipWidget({
    super.key,
    required this.label,
    required this.color,
    required this.onDeleted,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Chip(
      label: Text(
        label,
        overflow: TextOverflow.ellipsis,
        style: theme.textTheme.labelMedium?.copyWith(
          color: color,
          fontSize: AppDimens.fontS,
        ),
      ),
      deleteIcon: const Icon(Icons.close, size: AppDimens.iconXS),
      onDeleted: onDeleted,
      backgroundColor: color.withValues(alpha: 0.1),
      deleteIconColor: color,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimens.radiusM),
        side: BorderSide(color: color.withValues(alpha: 0.2)),
      ),
      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
      visualDensity: VisualDensity.compact,
      padding: const EdgeInsets.symmetric(horizontal: AppDimens.paddingXS),
    );
  }
}

// D:/workspace/spaced_learning_app/test/widget_test.dart
void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    await tester.pumpWidget(const MyApp());
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

// D:/workspace/spaced_learning_app/lib/presentation/widgets/report/bottom_bar_widget.dart
class BottomBarWidget extends StatelessWidget {
  final VoidCallback onPerformManualCheck;
  final bool isManualCheckInProgress;
  const BottomBarWidget({
    super.key,
    required this.onPerformManualCheck,
    required this.isManualCheckInProgress,
  });
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(AppDimens.paddingL),
        child: Row(
          children: [
            Expanded(
              child: SLButton(
                text: 'Check Now',
                prefixIcon: Icons.refresh,
                type: SLButtonType.primary,
                isLoading: isManualCheckInProgress,
                onPressed: onPerformManualCheck,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/domain/models/module.dart
@freezed
abstract class ModuleSummary with _$ModuleSummary {
  const factory ModuleSummary({
    required String id,
    required String bookId,
    required int moduleNo,
    required String title,
    int? wordCount,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _ModuleSummary;
  factory ModuleSummary.fromJson(Map<String, dynamic> json) =>
      _$ModuleSummaryFromJson(json);
}
@freezed
abstract class ModuleDetail with _$ModuleDetail {
  const factory ModuleDetail({
    required String id,
    required String bookId,
    String? bookName,
    required int moduleNo,
    required String title,
    int? wordCount,
    DateTime? createdAt,
    DateTime? updatedAt,
    @Default([]) List<ProgressSummary> progress,
  }) = _ModuleDetail;
  factory ModuleDetail.fromJson(Map<String, dynamic> json) =>
      _$ModuleDetailFromJson(json);
}

// D:/workspace/spaced_learning_app/lib/domain/repositories/progress_repository.dart
abstract class ProgressRepository {
  Future<List<ProgressSummary>> getAllProgress({int page = 0, int size = 20});
  Future<ProgressDetail> getProgressById(String id);
  Future<List<ProgressSummary>> getProgressByModuleId(
    String moduleId, {
    int page = 0,
    int size = 20,
  });
  Future<ProgressDetail?> getCurrentUserProgressByModule(String moduleId);
  Future<List<ProgressDetail>> getDueProgress(
    String userId, {
    DateTime? studyDate,
    int page = 0,
    int size = 20,
  });
  Future<ProgressDetail> createProgress({
    required String moduleId,
    String? userId, // Changed to optional
    DateTime? firstLearningDate,
    CycleStudied? cyclesStudied,
    DateTime? nextStudyDate,
    double? percentComplete,
  });
  Future<ProgressDetail> updateProgress(
    String id, {
    DateTime? firstLearningDate,
    CycleStudied? cyclesStudied,
    DateTime? nextStudyDate,
    double? percentComplete,
  });
}

// D:/workspace/spaced_learning_app/lib/core/services/learning_data_service.dart
abstract class LearningDataService {
  Future<List<LearningModule>> getModules();
  List<LearningModule> filterByBook(List<LearningModule> modules, String book);
  List<LearningModule> filterByDate(
    List<LearningModule> modules,
    DateTime date,
  );
  bool isSameDay(DateTime date1, DateTime date2);
  int countDueModules(List<LearningModule> modules, {int daysThreshold = 7});
  int countCompletedModules(List<LearningModule> modules);
  List<String> getUniqueBooks(List<LearningModule> modules);
  Future<bool> exportData();
  int getActiveModulesCount(List<LearningModule> modules);
  List<LearningModule> getDueToday(List<LearningModule> modules);
  List<LearningModule> getDueThisWeek(List<LearningModule> modules);
  List<LearningModule> getDueThisMonth(List<LearningModule> modules);
  Future<Map<String, dynamic>> getDashboardStats({
    String? book,
    DateTime? date,
  });
  void resetCache();
}

// D:/workspace/spaced_learning_app/lib/presentation/mixins/view_model_refresher.dart
mixin ViewModelRefresher<T extends StatefulWidget> on State<T>
    implements RouteAware {
  final AppRouteObserver _routeObserver = AppRouteObserver();
  bool _isInitialized = false;
  void refreshData() {
  }
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (!_isInitialized) {
      _isInitialized = true;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final route = ModalRoute.of(context);
        if (route != null) {
          _routeObserver.subscribe(this, route);
        }
      });
    }
  }
  @override
  void didPopNext() {
    refreshData();
  }
  @override
  void didPush() {
  }
  @override
  void didPop() {
  }
  @override
  void didPushNext() {
  }
  @override
  void dispose() {
    _routeObserver.unsubscribe(this);
    super.dispose();
  }
}

// D:/workspace/spaced_learning_app/lib/domain/models/learning_insight.dart
enum InsightType {
  @JsonValue('VOCABULARY_RATE')
  vocabularyRate,
  @JsonValue('STREAK')
  streak,
  @JsonValue('PENDING_WORDS')
  pendingWords,
  @JsonValue('DUE_TODAY')
  dueToday,
  @JsonValue('ACHIEVEMENT')
  achievement,
  @JsonValue('TIP')
  tip,
}
@freezed
abstract class LearningInsightRespone with _$LearningInsightRespone {
  const factory LearningInsightRespone({
    required InsightType type,
    required String message,
    required String icon,
    required String color,
    @Default(0.0) double dataPoint,
    @Default(0) int priority,
  }) = _LearningInsightRespone;
  factory LearningInsightRespone.fromJson(Map<String, dynamic> json) =>
      _$LearningInsightResponeFromJson(json);
}

// D:/workspace/spaced_learning_app/lib/core/events/app_events.dart
class ProgressChangedEvent {
  final String userId;
  final bool hasDueTasks;
  ProgressChangedEvent({required this.userId, this.hasDueTasks = false});
}
class TaskCompletedEvent {
  final String userId;
  final String progressId;
  TaskCompletedEvent({required this.userId, required this.progressId});
}
class ReminderSettingsChangedEvent {
  final bool enabled;
  ReminderSettingsChangedEvent({required this.enabled});
}
class DailyTaskCheckEvent {
  final DateTime checkTime;
  final bool hasDueTasks;
  final int taskCount;
  final String userId;
  final bool isSuccess;
  final String? errorMessage;
  DailyTaskCheckEvent({
    required this.checkTime,
    required this.hasDueTasks,
    required this.taskCount,
    required this.userId,
    required this.isSuccess,
    this.errorMessage,
  });
}

// D:/workspace/spaced_learning_app/lib/core/utils/error_handler.dart
class ErrorHandler {
  static void logError(String source, dynamic error, {String? prefix}) {
    final message = prefix != null ? '$prefix: $error' : '$error';
    debugPrint('[$source] $message');
  }
  static Future<T?> tryAsync<T>({
    required Future<T> Function() action,
    required String source,
    String? errorPrefix,
    T? defaultValue,
  }) async {
    try {
      return await action();
    } catch (e) {
      final prefix = errorPrefix ?? 'Error';
      logError(source, e, prefix: prefix);
      return defaultValue;
    }
  }
}

// D:/workspace/spaced_learning_app/lib/domain/repositories/book_repository.dart
abstract class BookRepository {
  Future<List<BookSummary>> getAllBooks({int page = 0, int size = 20});
  Future<BookDetail> getBookById(String id);
  Future<List<BookSummary>> searchBooks(
    String query, {
    int page = 0,
    int size = 20,
  });
  Future<List<String>> getAllCategories();
  Future<List<BookSummary>> filterBooks({
    BookStatus? status,
    DifficultyLevel? difficultyLevel,
    String? category,
    int page = 0,
    int size = 20,
  });
  Future<void> deleteBook(String id);
}

// D:/workspace/spaced_learning_app/lib/domain/models/user.dart
@freezed
abstract class User with _$User {
  const factory User({
    required String id,
    required String email,
    required String username,
    String? displayName,
    @JsonKey(name: 'firstName') String? firstName,
    @JsonKey(name: 'lastName') String? lastName,
    @JsonKey(name: 'createdAt') DateTime? createdAt,
    List<String>? roles,
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

// D:/workspace/spaced_learning_app/lib/domain/repositories/repetition_repository.dart
abstract class RepetitionRepository {
  Future<List<Repetition>> getRepetitionsByProgressId(String progressId);
  Future<List<Repetition>> createDefaultSchedule(String moduleProgressId);
  Future<Repetition> updateRepetition(
    String id, {
    RepetitionStatus? status,
    DateTime? reviewDate,
    bool rescheduleFollowing = false,
    double? percentComplete,
  });
  Future<int> countByModuleProgressId(String moduleProgressId);
}

// D:/workspace/spaced_learning_app/lib/domain/models/auth_response.dart
@freezed
abstract class AuthResponse with _$AuthResponse {
  const factory AuthResponse({
    required String token,
    String? refreshToken,
    required User user,
  }) = _AuthResponse;
  factory AuthResponse.fromJson(Map<String, dynamic> json) =>
      _$AuthResponseFromJson(json);
}

// D:/workspace/spaced_learning_app/lib/domain/repositories/auth_repository.dart
abstract class AuthRepository {
  Future<AuthResponse> login(String usernameOrEmail, String password);
  Future<AuthResponse> register(
    String username,
    String email,
    String password,
    String firstName,
    String lastName,
  );
  Future<AuthResponse> refreshToken(String refreshToken);
  Future<bool> validateToken(String token);
  String? getUsernameFromToken(String token);
}

// D:/workspace/spaced_learning_app/lib/domain/models/completion_stats.dart
@freezed
abstract class CompletionStats with _$CompletionStats {
  const factory CompletionStats({
    required int completedToday,
    required int completedThisWeek,
    required int completedThisMonth,
    required int wordsCompletedToday,
    required int wordsCompletedThisWeek,
    required int wordsCompletedThisMonth,
  }) = _CompletionStats;
}

// D:/workspace/spaced_learning_app/lib/presentation/utils/snackbar_utils.dart
class SnackBarUtils {
  static void show(
    BuildContext context,
    String message, {
    Color? backgroundColor,
  }) {
    final theme = Theme.of(context);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: backgroundColor ?? theme.colorScheme.primaryContainer,
      ),
    );
  }
}

// D:/workspace/spaced_learning_app/lib/presentation/utils/user_extensions.dart
extension UserExtension on User {
  String get initials {
    final name = displayName ?? email.split('@').first;
    final parts = name.trim().split(' ');
    if (parts.length >= 2) {
      return (parts.first[0] + parts.last[0]).toUpperCase();
    }
    return name.isNotEmpty ? name[0].toUpperCase() : '';
  }
}

// D:/workspace/spaced_learning_app/lib/domain/repositories/learning_progress_repository.dart
abstract class LearningProgressRepository {
  Future<List<LearningModule>> getAllModules();
  Future<List<LearningModule>> getDueModules(int daysThreshold);
  Future<List<String>> getUniqueBooks();
  Future<Map<String, dynamic>> exportData();
  Future<Map<String, dynamic>> getDashboardStats({
    String? book,
    DateTime? date,
  });
}

// D:/workspace/spaced_learning_app/lib/domain/models/vocabulary_stats.dart
@freezed
abstract class VocabularyStats with _$VocabularyStats {
  const factory VocabularyStats({
    required int totalWords,
    required int learnedWords,
    required int pendingWords,
    required double vocabularyCompletionRate,
    required double weeklyNewWordsRate,
  }) = _VocabularyStats;
}

// D:/workspace/spaced_learning_app/lib/core/utils/debouncer.dart
class Debouncer {
  final int milliseconds;
  Timer? _timer;
  Debouncer({required this.milliseconds});
  void run(VoidCallback action) {
    cancel();
    _timer = Timer(Duration(milliseconds: milliseconds), action);
  }
  void cancel() {
    _timer?.cancel();
  }
  void dispose() {
    cancel();
    _timer = null;
  }
}

// D:/workspace/spaced_learning_app/lib/domain/models/due_stats.dart
@freezed
abstract class DueStats with _$DueStats {
  const factory DueStats({
    required int dueToday,
    required int dueThisWeek,
    required int dueThisMonth,
    required int wordsDueToday,
    required int wordsDueThisWeek,
    required int wordsDueThisMonth,
  }) = _DueStats;
}

// D:/workspace/spaced_learning_app/lib/domain/repositories/module_repository.dart
abstract class ModuleRepository {
  Future<List<ModuleSummary>> getAllModules({int page = 0, int size = 20});
  Future<ModuleDetail> getModuleById(String id);
  Future<List<ModuleSummary>> getModulesByBookId(
    String bookId, {
    int page = 0,
    int size = 20,
  });
}

// D:/workspace/spaced_learning_app/lib/domain/repositories/learning_stats_repository.dart
abstract class LearningStatsRepository {
  Future<LearningStatsDTO> getDashboardStats({bool refreshCache = false});
  Future<List<LearningInsightRespone>> getLearningInsights();
}

// D:/workspace/spaced_learning_app/lib/domain/models/module_stats.dart
@freezed
abstract class ModuleStats with _$ModuleStats {
  const factory ModuleStats({
    required int totalModules,
    required Map<String, int> cycleStats,
  }) = _ModuleStats;
}

// D:/workspace/spaced_learning_app/lib/domain/models/streak_stats.dart
@freezed
abstract class StreakStats with _$StreakStats {
  const factory StreakStats({
    required int streakDays,
    required int streakWeeks,
  }) = _StreakStats;
}

// D:/workspace/spaced_learning_app/lib/domain/repositories/user_repository.dart
abstract class UserRepository {
  Future<User> getCurrentUser();
  Future<User> updateUser(String id, {String? displayName, String? password});
  Future<bool> checkEmailExists(String email);
}

// src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java
/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 */
@Keep
public final class GeneratedPluginRegistrant {
  private static final String TAG = "GeneratedPluginRegistrant";
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    try {
      flutterEngine.getPlugins().add(new dev.fluttercommunity.plus.androidalarmmanager.AndroidAlarmManagerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin android_alarm_manager_plus, dev.fluttercommunity.plus.androidalarmmanager.AndroidAlarmManagerPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new dev.fluttercommunity.plus.device_info.DeviceInfoPlusPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin device_info_plus, dev.fluttercommunity.plus.device_info.DeviceInfoPlusPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.messaging.FlutterFirebaseMessagingPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_messaging, io.flutter.plugins.firebase.messaging.FlutterFirebaseMessagingPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_local_notifications, com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new net.jonhanson.flutter_native_splash.FlutterNativeSplashPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_native_splash, net.jonhanson.flutter_native_splash.FlutterNativeSplashPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.it_nomads.fluttersecurestorage.FlutterSecureStoragePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_secure_storage, com.it_nomads.fluttersecurestorage.FlutterSecureStoragePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.github.ponnamkarthik.toast.fluttertoast.FlutterToastPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin fluttertoast, io.github.ponnamkarthik.toast.fluttertoast.FlutterToastPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new dev.flutter.plugins.integration_test.IntegrationTestPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin integration_test, dev.flutter.plugins.integration_test.IntegrationTestPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.pathprovider.PathProviderPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin path_provider_android, io.flutter.plugins.pathprovider.PathProviderPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.baseflow.permissionhandler.PermissionHandlerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin permission_handler_android, com.baseflow.permissionhandler.PermissionHandlerPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin shared_preferences_android, io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin", e);
    }
  }
}

// D:/workspace/spaced_learning_app/build/firebase_messaging/generated/source/buildConfig/debug/io/flutter/plugins/firebase/messaging/BuildConfig.java
/**
 * Automatically generated file. DO NOT MODIFY
 */
public final class BuildConfig {
  public static final boolean DEBUG = Boolean.parseBoolean("true");
  public static final String LIBRARY_PACKAGE_NAME = "io.flutter.plugins.firebase.messaging";
  public static final String BUILD_TYPE = "debug";
  public static final String LIBRARY_NAME = "flutter-fire-fcm";
  public static final String LIBRARY_VERSION = "15.2.5";
}

// D:/workspace/spaced_learning_app/build/firebase_core/generated/source/buildConfig/debug/io/flutter/plugins/firebase/core/BuildConfig.java
/**
 * Automatically generated file. DO NOT MODIFY
 */
public final class BuildConfig {
  public static final boolean DEBUG = Boolean.parseBoolean("true");
  public static final String LIBRARY_PACKAGE_NAME = "io.flutter.plugins.firebase.core";
  public static final String BUILD_TYPE = "debug";
  public static final String LIBRARY_NAME = "flutter-fire-core";
  public static final String LIBRARY_VERSION = "3.13.0";
}

// D:/workspace/spaced_learning_app/build/firebase_messaging/generated/source/buildConfig/release/io/flutter/plugins/firebase/messaging/BuildConfig.java
/**
 * Automatically generated file. DO NOT MODIFY
 */
public final class BuildConfig {
  public static final boolean DEBUG = false;
  public static final String LIBRARY_PACKAGE_NAME = "io.flutter.plugins.firebase.messaging";
  public static final String BUILD_TYPE = "release";
  public static final String LIBRARY_NAME = "flutter-fire-fcm";
  public static final String LIBRARY_VERSION = "15.2.5";
}

// D:/workspace/spaced_learning_app/build/firebase_core/generated/source/buildConfig/release/io/flutter/plugins/firebase/core/BuildConfig.java
/**
 * Automatically generated file. DO NOT MODIFY
 */
public final class BuildConfig {
  public static final boolean DEBUG = false;
  public static final String LIBRARY_PACKAGE_NAME = "io.flutter.plugins.firebase.core";
  public static final String BUILD_TYPE = "release";
  public static final String LIBRARY_NAME = "flutter-fire-core";
  public static final String LIBRARY_VERSION = "3.13.0";
}

// D:/workspace/spaced_learning_app/build/flutter_secure_storage/generated/source/buildConfig/debug/com/it_nomads/fluttersecurestorage/BuildConfig.java
/**
 * Automatically generated file. DO NOT MODIFY
 */
public final class BuildConfig {
  public static final boolean DEBUG = Boolean.parseBoolean("true");
  public static final String LIBRARY_PACKAGE_NAME = "com.it_nomads.fluttersecurestorage";
  public static final String BUILD_TYPE = "debug";
}

// D:/workspace/spaced_learning_app/build/flutter_secure_storage/generated/source/buildConfig/release/com/it_nomads/fluttersecurestorage/BuildConfig.java
/**
 * Automatically generated file. DO NOT MODIFY
 */
public final class BuildConfig {
  public static final boolean DEBUG = false;
  public static final String LIBRARY_PACKAGE_NAME = "com.it_nomads.fluttersecurestorage";
  public static final String BUILD_TYPE = "release";
}

// src/main/kotlin/com/example/spaced_learning_app/device/DeviceOptimizationPlugin.kt
class DeviceOptimizationPlugin : FlutterPlugin, MethodCallHandler, ActivityAware {
    private lateinit var channel: MethodChannel
    private lateinit var context: Context
    private var activity: android.app.Activity? = null
    private val TAG = "DeviceOptimizationPlugin"
    override fun onAttachedToEngine(@NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {
        channel = MethodChannel(flutterPluginBinding.binaryMessenger, "com.example.spaced_learning_app.device/optimization")
        channel.setMethodCallHandler(this)
        context = flutterPluginBinding.applicationContext
    }
    override fun onMethodCall(@NonNull call: MethodCall, @NonNull result: Result) {
        when (call.method) {
            "requestExactAlarmPermission" -> result.success(requestExactAlarmPermission())
            "disableSleepingApps" -> result.success(disableSleepingApps())
            "requestBatteryOptimization" -> result.success(requestBatteryOptimization())
            "getDeviceInfo" -> result.success(getDeviceInfo())
            "hasExactAlarmPermission" -> result.success(hasExactAlarmPermission())
            "isIgnoringBatteryOptimizations" -> result.success(isIgnoringBatteryOptimizations())
            else -> result.notImplemented()
        }
    }
    private fun hasExactAlarmPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            try {
                val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
                alarmManager.canScheduleExactAlarms()
            } catch (e: Exception) {
                Log.e(TAG, "Error checking exact alarm permission: ${e.message}")
                false
            }
        } else {
            true // Permissions not required before Android S (API 31)
        }
    }
    private fun isIgnoringBatteryOptimizations(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            try {
                val packageName = context.packageName
                val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager
                pm.isIgnoringBatteryOptimizations(packageName)
            } catch (e: Exception) {
                Log.e(TAG, "Error checking battery optimization status: ${e.message}")
                false
            }
        } else {
            true // Not applicable before Android M (API 23)
        }
    }
    private fun requestExactAlarmPermission(): Boolean {
        if (activity == null) {
            Log.e(TAG, "Activity is null, cannot request permission")
            return false
        }
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
                if (!alarmManager.canScheduleExactAlarms()) {
                    val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).apply {
                        data = Uri.parse("package:${context.packageName}")
                        flags = Intent.FLAG_ACTIVITY_NEW_TASK
                    }
                    activity?.startActivity(intent)
                }
            }
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error requesting exact alarm permission: ${e.message}")
            e.printStackTrace()
            false
        }
    }
    private fun disableSleepingApps(): Boolean {
        if (activity == null) {
            Log.e(TAG, "Activity is null, cannot open settings")
            return false
        }
        return try {
            val manufacturer = Build.MANUFACTURER.lowercase()
            val intent = when {
                manufacturer.contains("samsung") -> Intent().apply {
                    component = android.content.ComponentName(
                        "com.samsung.android.lool",
                        "com.samsung.android.sm.ui.battery.BatteryActivity"
                    )
                }
                manufacturer.contains("xiaomi") || manufacturer.contains("redmi") -> Intent().apply {
                    component = android.content.ComponentName(
                        "com.miui.powerkeeper",
                        "com.miui.powerkeeper.ui.HiddenAppsConfigActivity"
                    )
                }
                manufacturer.contains("huawei") -> Intent().apply {
                    component = android.content.ComponentName(
                        "com.huawei.systemmanager",
                        "com.huawei.systemmanager.optimize.process.ProtectActivity"
                    )
                }
                manufacturer.contains("oppo") -> Intent().apply {
                    component = android.content.ComponentName(
                        "com.coloros.oppoguardelf",
                        "com.coloros.powermanager.fuelgaue.PowerUsageModelActivity"
                    )
                }
                manufacturer.contains("vivo") -> Intent().apply {
                    component = android.content.ComponentName(
                        "com.vivo.permissionmanager",
                        "com.vivo.permissionmanager.activity.BgStartUpManagerActivity"
                    )
                }
                else -> Intent(Settings.ACTION_BATTERY_SAVER_SETTINGS)
            }.apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            }
            activity?.startActivity(intent)
            true
        } catch (e: Exception) {
            try {
                val intent = Intent(Settings.ACTION_BATTERY_SAVER_SETTINGS).apply {
                    flags = Intent.FLAG_ACTIVITY_NEW_TASK
                }
                activity?.startActivity(intent)
                true
            } catch (e2: Exception) {
                Log.e(TAG, "Error disabling sleeping apps: ${e2.message}")
                e2.printStackTrace()
                false
            }
        }
    }
    private fun requestBatteryOptimization(): Boolean {
        if (activity == null) {
            Log.e(TAG, "Activity is null, cannot request battery optimization")
            return false
        }
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val packageName = context.packageName
                val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager
                if (!pm.isIgnoringBatteryOptimizations(packageName)) {
                    val intent = Intent().apply {
                        action = Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
                        data = Uri.parse("package:$packageName")
                        flags = Intent.FLAG_ACTIVITY_NEW_TASK
                    }
                    activity?.startActivity(intent)
                }
            }
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error requesting battery optimization: ${e.message}")
            e.printStackTrace()
            false
        }
    }
    private fun getDeviceInfo(): Map<String, Any> {
        val info = HashMap<String, Any>()
        info["manufacturer"] = Build.MANUFACTURER ?: "Unknown"
        info["model"] = Build.MODEL ?: "Unknown"
        info["sdkVersion"] = Build.VERSION.SDK_INT
        info["brand"] = Build.BRAND ?: "Unknown"
        info["device"] = Build.DEVICE ?: "Unknown"
        try {
            info["hasVibrator"] = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { // API 31+
                val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as? VibratorManager
                vibratorManager?.defaultVibrator?.hasVibrator() ?: false
            } else {
                @Suppress("DEPRECATION")
                val vibrator = context.getSystemService(Context.VIBRATOR_SERVICE) as? Vibrator
                vibrator?.hasVibrator() ?: false
            }
        } catch (e: Exception) {
            info["hasVibrator"] = false
            Log.e(TAG, "Error checking vibrator: ${e.message}")
        }
        info["hasExactAlarmPermission"] = hasExactAlarmPermission()
        info["isIgnoringBatteryOptimizations"] = isIgnoringBatteryOptimizations()
        return info
    }
    override fun onDetachedFromEngine(@NonNull binding: FlutterPlugin.FlutterPluginBinding) {
        channel.setMethodCallHandler(null)
    }
    override fun onAttachedToActivity(binding: ActivityPluginBinding) {
        activity = binding.activity
    }
    override fun onDetachedFromActivityForConfigChanges() {
        activity = null
    }
    override fun onReattachedToActivityForConfigChanges(binding: ActivityPluginBinding) {
        activity = binding.activity
    }
    override fun onDetachedFromActivity() {
        activity = null
    }
}

// src/main/kotlin/com/example/spaced_learning_app/MainActivity.kt
class MainActivity : FlutterActivity() {
    private val TAG = "MainActivity"
    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        try {
            flutterEngine.plugins.add(DeviceOptimizationPlugin())
            Log.i(TAG, "DeviceOptimizationPlugin registered successfully")
        } catch (e: Exception) {
            Log.e(TAG, "Error registering DeviceOptimizationPlugin: ${e.message}")
        }
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        checkCriticalPermissions()
    }
    private fun checkCriticalPermissions() {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val pm = getSystemService(POWER_SERVICE) as PowerManager
                if (!pm.isIgnoringBatteryOptimizations(packageName)) {
                    Log.i(TAG, "App is not ignoring battery optimizations")
                }
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val alarmManager = getSystemService(ALARM_SERVICE) as android.app.AlarmManager
                if (!alarmManager.canScheduleExactAlarms()) {
                    Log.i(TAG, "App cannot schedule exact alarms")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error checking permissions: ${e.message}")
        }
    }
}

